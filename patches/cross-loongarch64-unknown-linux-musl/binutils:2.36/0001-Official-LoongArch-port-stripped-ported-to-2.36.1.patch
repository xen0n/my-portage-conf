From 0546b49d437a3ab61f367c01b008d228ce7847d8 Mon Sep 17 00:00:00 2001
From: WANG Xuerui <git@xen0n.name>
Date: Fri, 7 May 2021 16:25:29 +0800
Subject: [PATCH 01/19] Official LoongArch port (stripped, ported to 2.36.1)

---
 bfd/Makefile.am                      |   21 +-
 bfd/archures.c                       |    5 +
 bfd/bfd-in2.h                        |   48 +
 bfd/config.bfd                       |   15 +
 bfd/configure.ac                     |    2 +
 bfd/cpu-loongarch.c                  |   38 +
 bfd/elf-bfd.h                        |    9 +
 bfd/elf.c                            |  109 +
 bfd/elfnn-loongarch.c                | 3256 ++++++++++++++++++++++++++
 bfd/elfxx-loongarch.c                |  172 ++
 bfd/elfxx-loongarch.h                |   11 +
 bfd/libbfd.h                         |   43 +
 bfd/reloc.c                          |   89 +
 bfd/targets.c                        |    8 +
 binutils/readelf.c                   |   24 +
 gas/Makefile.am                      |   25 +-
 gas/config/loongarch-lex-wrapper.c   |   25 +
 gas/config/loongarch-lex.l           |   37 +
 gas/config/loongarch-parse.y         |  420 ++++
 gas/config/tc-loongarch-mips.c       | 2555 ++++++++++++++++++++
 gas/config/tc-loongarch.c            | 1313 +++++++++++
 gas/config/tc-loongarch.h            |   74 +
 gas/configure.ac                     |    9 +
 gas/configure.tgt                    |    5 +-
 include/dis-asm.h                    |    1 +
 include/elf/common.h                 |    8 +
 include/elf/loongarch.h              |   94 +
 include/opcode/loongarch.h           |  217 ++
 ld/Makefile.am                       |    2 +
 ld/configure.tgt                     |    4 +
 ld/emulparams/elf64loongarch-defs.sh |   37 +
 ld/emulparams/elf64loongarch.sh      |   15 +
 ld/emultempl/loongarchelf.em         |   91 +
 opcodes/Makefile.am                  |    3 +
 opcodes/configure.ac                 |    1 +
 opcodes/disassemble.c                |   10 +
 opcodes/disassemble.h                |    1 +
 opcodes/loongarch-coder.c            |  538 +++++
 opcodes/loongarch-dis.c              |  311 +++
 opcodes/loongarch-opc.c              | 1199 ++++++++++
 40 files changed, 10841 insertions(+), 4 deletions(-)
 create mode 100644 bfd/cpu-loongarch.c
 create mode 100644 bfd/elfnn-loongarch.c
 create mode 100644 bfd/elfxx-loongarch.c
 create mode 100644 bfd/elfxx-loongarch.h
 create mode 100644 gas/config/loongarch-lex-wrapper.c
 create mode 100644 gas/config/loongarch-lex.l
 create mode 100644 gas/config/loongarch-parse.y
 create mode 100644 gas/config/tc-loongarch-mips.c
 create mode 100644 gas/config/tc-loongarch.c
 create mode 100644 gas/config/tc-loongarch.h
 create mode 100644 include/elf/loongarch.h
 create mode 100644 include/opcode/loongarch.h
 create mode 100644 ld/emulparams/elf64loongarch-defs.sh
 create mode 100644 ld/emulparams/elf64loongarch.sh
 create mode 100644 ld/emultempl/loongarchelf.em
 create mode 100644 opcodes/loongarch-coder.c
 create mode 100644 opcodes/loongarch-dis.c
 create mode 100644 opcodes/loongarch-opc.c

diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index 9908249fdd5..83762ab78c6 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -171,7 +171,8 @@ ALL_MACHINES = \
 	cpu-xstormy16.lo \
 	cpu-xtensa.lo \
 	cpu-z80.lo \
-	cpu-z8k.lo
+	cpu-z8k.lo \
+	cpu-loongarch.lo
 
 ALL_MACHINES_CFILES = \
 	cpu-aarch64.c \
@@ -255,7 +256,8 @@ ALL_MACHINES_CFILES = \
 	cpu-xstormy16.c \
 	cpu-xtensa.c \
 	cpu-z80.c \
-	cpu-z8k.c
+	cpu-z8k.c \
+	cpu-loongarch.c
 
 # The .o files needed by all of the 32 bit vectors that are configured into
 # target_vector in targets.c if configured with --enable-targets=all.
@@ -556,6 +558,8 @@ BFD64_BACKENDS = \
 	elf64-ppc.lo \
 	elf32-riscv.lo \
 	elf64-riscv.lo \
+	elf32-loongarch.lo \
+	elf64-loongarch.lo \
 	elfxx-riscv.lo \
 	elf64-s390.lo \
 	elf64-sparc.lo \
@@ -666,6 +670,7 @@ BUILD_CFILES = \
 	elf32-aarch64.c elf64-aarch64.c \
 	elf32-ia64.c elf64-ia64.c \
 	elf32-riscv.c elf64-riscv.c \
+	elf32-loongarch.c elf64-loongarch.c \
 	peigen.c pepigen.c pex64igen.c
 
 CFILES = $(SOURCE_CFILES) $(BUILD_CFILES)
@@ -850,6 +855,18 @@ elf64-riscv.c : elfnn-riscv.c
 	echo "#line 1 \"elfnn-riscv.c\"" > $@
 	$(SED) -e s/NN/64/g < $< >> $@
 
+elf32-loongarch.c : elfnn-loongarch.c
+	rm -f elf32-loongarch.c
+	echo "#line 1 \"$(srcdir)/elfnn-loongarch.c\"" > elf32-loongarch.new
+	sed -e s/NN/32/g < $(srcdir)/elfnn-loongarch.c >> elf32-loongarch.new
+	mv -f elf32-loongarch.new elf32-loongarch.c
+
+elf64-loongarch.c : elfnn-loongarch.c
+	rm -f elf64-loongarch.c
+	echo "#line 1 \"$(srcdir)/elfnn-loongarch.c\"" > elf64-loongarch.new
+	sed -e s/NN/64/g < $(srcdir)/elfnn-loongarch.c >> elf64-loongarch.new
+	mv -f elf64-loongarch.new elf64-loongarch.c
+
 peigen.c : peXXigen.c
 	echo "#line 1 \"peXXigen.c\"" > $@
 	$(SED) -e s/XX/pe/g < $< >> $@
diff --git a/bfd/archures.c b/bfd/archures.c
index 8c1d32ca930..da95c31fb11 100644
--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -555,6 +555,9 @@ DESCRIPTION
 .#define bfd_mach_ck807		6
 .#define bfd_mach_ck810		7
 .#define bfd_mach_ck860		8
+.  bfd_arch_loongarch,       {* Loongarch *}
+.#define bfd_mach_loongarch32	1
+.#define bfd_mach_loongarch64	2
 .  bfd_arch_last
 .  };
 */
@@ -692,6 +695,7 @@ extern const bfd_arch_info_type bfd_xc16x_arch;
 extern const bfd_arch_info_type bfd_xgate_arch;
 extern const bfd_arch_info_type bfd_z80_arch;
 extern const bfd_arch_info_type bfd_z8k_arch;
+extern const bfd_arch_info_type bfd_loongarch_arch;
 
 static const bfd_arch_info_type * const bfd_archures_list[] =
   {
@@ -779,6 +783,7 @@ static const bfd_arch_info_type * const bfd_archures_list[] =
     &bfd_xgate_arch,
     &bfd_z80_arch,
     &bfd_z8k_arch,
+    &bfd_loongarch_arch,
 #endif
   0
 };
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 7eff85b7eaa..b28b619f7b6 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -1960,6 +1960,9 @@ enum bfd_architecture
 #define bfd_mach_ck807         6
 #define bfd_mach_ck810         7
 #define bfd_mach_ck860         8
+  bfd_arch_loongarch,       /* Loongarch */
+#define bfd_mach_loongarch32   1
+#define bfd_mach_loongarch64   2
   bfd_arch_last
   };
 
@@ -6278,6 +6281,51 @@ assembler and not (currently) written to any object files.  */
 
 /* S12Z relocations.  */
   BFD_RELOC_S12Z_OPR,
+
+/* LoongISA relocations.  */
+  BFD_RELOC_LARCH_TLS_DTPMOD32,
+  BFD_RELOC_LARCH_TLS_DTPREL32,
+  BFD_RELOC_LARCH_TLS_DTPMOD64,
+  BFD_RELOC_LARCH_TLS_DTPREL64,
+  BFD_RELOC_LARCH_TLS_TPREL32,
+  BFD_RELOC_LARCH_TLS_TPREL64,
+  BFD_RELOC_LARCH_MARK_LA,
+  BFD_RELOC_LARCH_MARK_PCREL,
+  BFD_RELOC_LARCH_SOP_PUSH_PCREL,
+  BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE,
+  BFD_RELOC_LARCH_SOP_PUSH_DUP,
+  BFD_RELOC_LARCH_SOP_PUSH_GPREL,
+  BFD_RELOC_LARCH_SOP_PUSH_TLS_TPREL,
+  BFD_RELOC_LARCH_SOP_PUSH_TLS_GOT,
+  BFD_RELOC_LARCH_SOP_PUSH_TLS_GD,
+  BFD_RELOC_LARCH_SOP_PUSH_PLT_PCREL,
+  BFD_RELOC_LARCH_SOP_ASSERT,
+  BFD_RELOC_LARCH_SOP_NOT,
+  BFD_RELOC_LARCH_SOP_SUB,
+  BFD_RELOC_LARCH_SOP_SL,
+  BFD_RELOC_LARCH_SOP_SR,
+  BFD_RELOC_LARCH_SOP_ADD,
+  BFD_RELOC_LARCH_SOP_AND,
+  BFD_RELOC_LARCH_SOP_IF_ELSE,
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_5,
+  BFD_RELOC_LARCH_SOP_POP_32_U_10_12,
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_12,
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_16,
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2,
+  BFD_RELOC_LARCH_SOP_POP_32_S_5_20,
+  BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2,
+  BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2,
+  BFD_RELOC_LARCH_SOP_POP_32_U,
+  BFD_RELOC_LARCH_ADD8,
+  BFD_RELOC_LARCH_ADD16,
+  BFD_RELOC_LARCH_ADD24,
+  BFD_RELOC_LARCH_ADD32,
+  BFD_RELOC_LARCH_ADD64,
+  BFD_RELOC_LARCH_SUB8,
+  BFD_RELOC_LARCH_SUB16,
+  BFD_RELOC_LARCH_SUB24,
+  BFD_RELOC_LARCH_SUB32,
+  BFD_RELOC_LARCH_SUB64,
   BFD_RELOC_UNUSED };
 
 typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
diff --git a/bfd/config.bfd b/bfd/config.bfd
index e7b55b0dd78..eea4164f246 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -213,6 +213,7 @@ xtensa*)	 targ_archs=bfd_xtensa_arch ;;
 xgate)		 targ_archs=bfd_xgate_arch ;;
 z80*|r800|z180|gbz80|ez80*)	 targ_archs=bfd_z80_arch ;;
 z8k*)		 targ_archs=bfd_z8k_arch ;;
+loongarch*)		 targ_archs=bfd_loongarch_arch ;;
 *)		 targ_archs=bfd_${targ_cpu}_arch ;;
 esac
 
@@ -1417,6 +1418,20 @@ case "${targ}" in
     targ_underscore=yes
     ;;
 
+#ifdef BFD64
+  loongarch32-*)
+    targ_defvec=loongarch_elf32_vec
+    targ_selvecs="loongarch_elf32_vec"
+    want64=false
+    ;;
+
+  loongarch64-*)
+    targ_defvec=loongarch_elf64_vec
+    targ_selvecs="loongarch_elf32_vec loongarch_elf64_vec"
+    want64=true
+    ;;
+#endif
+
 # END OF targmatch.h
   bpf-*-*)
     echo "*** Configuration $targ is not fully supported." >&2
diff --git a/bfd/configure.ac b/bfd/configure.ac
index 0797a08ff37..ac9191550f7 100644
--- a/bfd/configure.ac
+++ b/bfd/configure.ac
@@ -627,6 +627,8 @@ do
     riscv_elf64_vec)		 tb="$tb elf64-riscv.lo elf64.lo elfxx-riscv.lo elf-ifunc.lo elf32.lo $elf"; target_size=64 ;;
     riscv_elf32_be_vec)		 tb="$tb elf32-riscv.lo elfxx-riscv.lo elf-ifunc.lo elf32.lo $elf" ;;
     riscv_elf64_be_vec)		 tb="$tb elf64-riscv.lo elf64.lo elfxx-riscv.lo elf-ifunc.lo elf32.lo $elf"; target_size=64 ;;
+    loongarch_elf32_vec)		 tb="$tb elf32-loongarch.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf" ;;
+    loongarch_elf64_vec)		 tb="$tb elf64-loongarch.lo elf64.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf"; target_size=64 ;;
     rl78_elf32_vec)		 tb="$tb elf32-rl78.lo elf32.lo $elf" ;;
     rs6000_xcoff64_vec)		 tb="$tb coff64-rs6000.lo aix5ppc-core.lo $xcoff"; target_size=64 ;;
     rs6000_xcoff64_aix_vec)	 tb="$tb coff64-rs6000.lo aix5ppc-core.lo $xcoff"; target_size=64 ;;
diff --git a/bfd/cpu-loongarch.c b/bfd/cpu-loongarch.c
new file mode 100644
index 00000000000..c5579f292d4
--- /dev/null
+++ b/bfd/cpu-loongarch.c
@@ -0,0 +1,38 @@
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+static const bfd_arch_info_type bfd_loongarch32_arch =
+{
+  32,				/* 32 bits in a word.  */
+  32,				/* 64 bits in an address.  */
+  8,				/* 8 bits in a byte.  */
+  bfd_arch_loongarch,		/* Architecture.  */
+  bfd_mach_loongarch32,				/* Machine number - 0 for now.  */
+  "loongarch32",			/* Architecture name.  */
+  "Loongarch32",			/* Printable name.  */
+  3,				/* Section align power.  */
+  FALSE,			/* This is the default architecture.  */
+  bfd_default_compatible,	/* Architecture comparison function.  */
+  bfd_default_scan,		/* String to architecture conversion.  */
+  bfd_arch_default_fill,	/* Default fill.  */
+  NULL,				/* Next in list.  */
+};
+
+const bfd_arch_info_type bfd_loongarch_arch =
+{
+  32,                           /* 32 bits in a word.  */
+  64,                           /* 64 bits in an address.  */
+  8,                            /* 8 bits in a byte.  */
+  bfd_arch_loongarch,            /* Architecture.  */
+  bfd_mach_loongarch64,                          /* Machine number of loongarch64 is larger so that loongarch64 is compatible to loongarch32  */
+  "loongarch64",                   /* Architecture name.  */
+  "Loongarch64",                 /* Printable name.  */
+  3,                            /* Section align power.  */
+  TRUE,                 /* This is the default architecture.  */
+  bfd_default_compatible,       /* Architecture comparison function.  */
+  bfd_default_scan,             /* String to architecture conversion.  */
+  bfd_arch_default_fill,        /* Default fill.  */
+  &bfd_loongarch32_arch,                          /* Next in list.  */
+};
+
diff --git a/bfd/elf-bfd.h b/bfd/elf-bfd.h
index 15206b4e876..577e5b02255 100644
--- a/bfd/elf-bfd.h
+++ b/bfd/elf-bfd.h
@@ -523,6 +523,7 @@ enum elf_target_id
   TILEGX_ELF_DATA,
   TILEPRO_ELF_DATA,
   RISCV_ELF_DATA,
+  LARCH_ELF_DATA,
   GENERIC_ELF_DATA
 };
 
@@ -2797,6 +2798,14 @@ extern char *elfcore_write_aarch_pauth
   (bfd *, char *, int *, const void *, int);
 extern char *elfcore_write_arc_v2
   (bfd *, char *, int *, const void *, int);
+extern char *elfcore_write_loongarch_cpucfg
+  (bfd *, char *, int *, const void *, int);
+extern char *elfcore_write_loongarch_lbt
+  (bfd *, char *, int *, const void *, int);
+extern char *elfcore_write_loongarch_lsx
+  (bfd *, char *, int *, const void *, int);
+extern char *elfcore_write_loongarch_lasx
+  (bfd *, char *, int *, const void *, int);
 extern char *elfcore_write_lwpstatus
   (bfd *, char *, int *, long, int, const void *);
 extern char *elfcore_write_register_note
diff --git a/bfd/elf.c b/bfd/elf.c
index 84a5d942817..e2d19819242 100644
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -9912,6 +9912,30 @@ elfcore_grok_arc_v2 (bfd *abfd, Elf_Internal_Note *note)
   return elfcore_make_note_pseudosection (abfd, ".reg-arc-v2", note);
 }
 
+static bfd_boolean
+elfcore_grok_loongarch_cpucfg (bfd *abfd, Elf_Internal_Note *note)
+{
+  return elfcore_make_note_pseudosection (abfd, ".reg-loongarch-cpucfg", note);
+}
+
+static bfd_boolean
+elfcore_grok_loongarch_lbt (bfd *abfd, Elf_Internal_Note *note)
+{
+  return elfcore_make_note_pseudosection (abfd, ".reg-loongarch-lbt", note);
+}
+
+static bfd_boolean
+elfcore_grok_loongarch_lsx (bfd *abfd, Elf_Internal_Note *note)
+{
+  return elfcore_make_note_pseudosection (abfd, ".reg-loongarch-lsx", note);
+}
+
+static bfd_boolean
+elfcore_grok_loongarch_lasx (bfd *abfd, Elf_Internal_Note *note)
+{
+  return elfcore_make_note_pseudosection (abfd, ".reg-loongarch-lasx", note);
+}
+
 #if defined (HAVE_PRPSINFO_T)
 typedef prpsinfo_t   elfcore_psinfo_t;
 #if defined (HAVE_PRPSINFO32_T)		/* Sparc64 cross Sparc32 */
@@ -10570,6 +10594,34 @@ elfcore_grok_note (bfd *abfd, Elf_Internal_Note *note)
       else
 	return TRUE;
 
+    case NT_LARCH_CPUCFG:
+      if (note->namesz == 6
+	  && strcmp (note->namedata, "LINUX") == 0)
+	return elfcore_grok_loongarch_cpucfg (abfd, note);
+      else
+	return TRUE;
+
+    case NT_LARCH_LBT:
+      if (note->namesz == 6
+	  && strcmp (note->namedata, "LINUX") == 0)
+	return elfcore_grok_loongarch_lbt (abfd, note);
+      else
+	return TRUE;
+
+    case NT_LARCH_LSX:
+      if (note->namesz == 6
+	  && strcmp (note->namedata, "LINUX") == 0)
+	return elfcore_grok_loongarch_lsx (abfd, note);
+      else
+	return TRUE;
+
+    case NT_LARCH_LASX:
+      if (note->namesz == 6
+	  && strcmp (note->namedata, "LINUX") == 0)
+	return elfcore_grok_loongarch_lasx (abfd, note);
+      else
+	return TRUE;
+
     case NT_PRPSINFO:
     case NT_PSINFO:
       if (bed->elf_backend_grok_psinfo)
@@ -11951,6 +12003,55 @@ elfcore_write_arc_v2 (bfd *abfd,
 			     note_name, NT_ARC_V2, arc_v2, size);
 }
 
+char *
+elfcore_write_loongarch_cpucfg (bfd *abfd,
+				char *buf,
+				int *bufsiz,
+				const void *loongarch_cpucfg,
+				int size)
+{
+  char *note_name = "LINUX";
+  return elfcore_write_note (abfd, buf, bufsiz,
+			     note_name, NT_LARCH_CPUCFG,
+			     loongarch_cpucfg, size);
+}
+
+char *
+elfcore_write_loongarch_lbt (bfd *abfd,
+			     char *buf,
+			     int *bufsiz,
+			     const void *loongarch_lbt,
+			     int size)
+{
+  char *note_name = "LINUX";
+  return elfcore_write_note (abfd, buf, bufsiz,
+			     note_name, NT_LARCH_LBT, loongarch_lbt, size);
+}
+
+char *
+elfcore_write_loongarch_lsx (bfd *abfd,
+			     char *buf,
+			     int *bufsiz,
+			     const void *loongarch_lsx,
+			     int size)
+{
+  char *note_name = "LINUX";
+  return elfcore_write_note (abfd, buf, bufsiz,
+			     note_name, NT_LARCH_LSX, loongarch_lsx, size);
+}
+
+char *
+elfcore_write_loongarch_lasx (bfd *abfd,
+			      char *buf,
+			      int *bufsiz,
+			      const void *loongarch_lasx,
+			      int size)
+{
+  char *note_name = "LINUX";
+  return elfcore_write_note (abfd, buf, bufsiz,
+			     note_name, NT_LARCH_LASX, loongarch_lasx, size);
+}
+
 char *
 elfcore_write_register_note (bfd *abfd,
 			     char *buf,
@@ -12035,6 +12136,14 @@ elfcore_write_register_note (bfd *abfd,
     return elfcore_write_aarch_pauth (abfd, buf, bufsiz, data, size);
   if (strcmp (section, ".reg-arc-v2") == 0)
     return elfcore_write_arc_v2 (abfd, buf, bufsiz, data, size);
+  if (strcmp (section, ".reg-loongarch-cpucfg") == 0)
+    return elfcore_write_loongarch_cpucfg (abfd, buf, bufsiz, data, size);
+  if (strcmp (section, ".reg-loongarch-lbt") == 0)
+    return elfcore_write_loongarch_lbt (abfd, buf, bufsiz, data, size);
+  if (strcmp (section, ".reg-loongarch-lsx") == 0)
+    return elfcore_write_loongarch_lsx (abfd, buf, bufsiz, data, size);
+  if (strcmp (section, ".reg-loongarch-lasx") == 0)
+    return elfcore_write_loongarch_lasx (abfd, buf, bufsiz, data, size);
   return NULL;
 }
 
diff --git a/bfd/elfnn-loongarch.c b/bfd/elfnn-loongarch.c
new file mode 100644
index 00000000000..52eb3c42966
--- /dev/null
+++ b/bfd/elfnn-loongarch.c
@@ -0,0 +1,3256 @@
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#define ARCH_SIZE NN
+#include "elf-bfd.h"
+#include "objalloc.h"
+#include "elf/loongarch.h"
+#include "elfxx-loongarch.h"
+
+static bfd_boolean
+loongarch_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
+			      arelent *cache_ptr,
+			      Elf_Internal_Rela *dst)
+{
+  cache_ptr->howto = loongarch_elf_rtype_to_howto (ELFNN_R_TYPE (dst->r_info));
+  return cache_ptr->howto != NULL;
+}
+
+/* Loongarch ELF linker hash entry.  */
+
+struct loongarch_elf_link_hash_entry
+{
+  struct elf_link_hash_entry elf;
+
+  /* Track dynamic relocs copied for this symbol.  */
+  struct elf_dyn_relocs *dyn_relocs;
+
+#define GOT_UNKNOWN     0
+#define GOT_NORMAL      1
+#define GOT_TLS_GD      2
+#define GOT_TLS_IE      4
+#define GOT_TLS_LE      8
+  char tls_type;
+};
+
+#define loongarch_elf_hash_entry(ent) \
+  ((struct loongarch_elf_link_hash_entry *)(ent))
+
+struct _bfd_loongarch_elf_obj_tdata
+{
+  struct elf_obj_tdata root;
+
+  /* tls_type for each local got entry.  */
+  char *local_got_tls_type;
+};
+
+#define _bfd_loongarch_elf_tdata(abfd) \
+  ((struct _bfd_loongarch_elf_obj_tdata *) (abfd)->tdata.any)
+
+#define _bfd_loongarch_elf_local_got_tls_type(abfd) \
+  (_bfd_loongarch_elf_tdata (abfd)->local_got_tls_type)
+
+#define _bfd_loongarch_elf_tls_type(abfd, h, symndx)		\
+  (*((h) != NULL ? &loongarch_elf_hash_entry (h)->tls_type	\
+     : &_bfd_loongarch_elf_local_got_tls_type (abfd) [symndx]))
+
+#define is_loongarch_elf(bfd)				\
+  (bfd_get_flavour (bfd) == bfd_target_elf_flavour	\
+   && elf_tdata (bfd) != NULL				\
+   && elf_object_id (bfd) == LARCH_ELF_DATA)
+
+struct loongarch_elf_link_hash_table
+{
+  struct elf_link_hash_table elf;
+
+  /* Short-cuts to get to dynamic linker sections.  */
+  asection *sdyntdata;
+
+  /* Small local sym to section mapping cache.  */
+  struct sym_cache sym_cache;
+
+  /* Used by local STT_GNU_IFUNC symbols.  */
+  htab_t loc_hash_table;
+  void *loc_hash_memory;
+
+  /* The max alignment of output sections.  */
+  bfd_vma max_alignment;
+};
+
+/* Get the Loongarch ELF linker hash table from a link_info structure.  */
+#define loongarch_elf_hash_table(p) \
+  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
+   == LARCH_ELF_DATA \
+      ? ((struct loongarch_elf_link_hash_table *) ((p)->hash)) : NULL)
+
+#define MINUS_ONE ((bfd_vma)0 - 1)
+
+#define sec_addr(sec) ((sec)->output_section->vma + (sec)->output_offset)
+
+#define LARCH_ELF_LOG_WORD_BYTES (ARCH_SIZE == 32 ? 2 : 3)
+#define LARCH_ELF_WORD_BYTES (1 << LARCH_ELF_LOG_WORD_BYTES)
+
+#define PLT_HEADER_INSNS 8
+#define PLT_HEADER_SIZE (PLT_HEADER_INSNS * 4)
+
+#define PLT_ENTRY_INSNS 4
+#define PLT_ENTRY_SIZE (PLT_ENTRY_INSNS * 4)
+
+#define GOT_ENTRY_SIZE (LARCH_ELF_WORD_BYTES)
+
+/* .got.plt的前两项预留。我们约定：
+   第一项在运行时被动态连接器填入_dl_runtime_resolve的地址
+   第二项在连接时，非0指plt header的地址（在no-pic下或prelink）。
+   第二项在运行时被动态连接器填入本模块的struct link_map实例的地址。
+   详见$glibc/sysdeps/loongarch/dl-machine.h中的elf_machine_runtime_setup */
+#define GOTPLT_HEADER_SIZE (GOT_ENTRY_SIZE * 2)
+
+/* .got和.got.plt不合并的好处是，.got.plt和.plt的entry是顺序对应的。
+   设法使得stub的size为2的幂，知道.plt和stub的地址就知道了index。 */
+#define elf_backend_want_got_plt	1
+
+#define elf_backend_plt_readonly	1
+
+#define elf_backend_want_plt_sym	0
+/* 1. 本来想着定义_PROCEDURE_LINKAGE_TABLE_，多了不嫌多。
+   2. 但实际上，这个符号会使得GDB调试ifunc函数失效。因为lazy-bind的情况下，
+   plt GOT entry中的地址都指向这个符号；GDB读取plt GOT entry来确定ifunc的
+   目标函数，从而以为_PROCEDURE_LINKAGE_TABLE_就是ifunc的目标函数（好奇的人
+   可以把断点打在elf_gnu_ifunc_record_cache上面看一下GDB的行为，总之是校验从
+   GOT entry中拿到的地址，结果发现 'BMSYMBOL_VALUE_ADDRESS (msym) == addr'
+   为真），然后直接跳转到plt header上面了，这当然不行。
+   3. 我们期望，调用ifunc函数时，要么跳到对应的plt stub上；要么GDB运行一遍
+   resolver得到ifunc目标函数的地址后再调用（这是GDB公共代码的做法）。
+   4. 观察了aarch64的做法，发现他们就没_PROCEDURE_LINKAGE_TABLE_，
+   就不存在msym.minsym，然后认为从GOT entry读ifunc目标函数失败直接退出了。
+   5. 我想了想，_PROCEDURE_LINKAGE_TABLE_的存在没有意义，因为对plt stub
+   的处理是有重定位R_LARCH_SOP_PUSH_PLT_PCREL由静态连接器一手操办。
+   所以就把_PROCEDURE_LINKAGE_TABLE_去了吧。 */
+#define elf_backend_plt_alignment	4
+#define elf_backend_can_gc_sections	1
+//#define elf_backend_can_refcount	1
+#define elf_backend_want_got_sym	1
+
+/* .got的第一项预留。我们约定.got的第一项为.dynamic的连接时地址（如果有） */
+#define elf_backend_got_header_size	(GOT_ENTRY_SIZE * 1)
+
+#define elf_backend_want_dynrelro	1
+//#define elf_backend_rela_normal		1
+//#define elf_backend_default_execstack	0
+
+/* Generate a PLT header.  */
+
+static void
+loongarch_make_plt_header (bfd_vma got_plt_addr,
+			   bfd_vma plt_header_addr,
+			   uint32_t *entry)
+{
+  int64_t pcrel = got_plt_addr - plt_header_addr;
+  int64_t hi = (pcrel & 0x800? 1 : 0) + (pcrel >> 12);
+  int64_t lo = pcrel & 0xfff;
+  if ((hi >> 19) != 0 && (hi >> 19) != -1)
+    abort ();//overflow
+
+  /* pcaddu12i	$t2, %hi(%pcrel(.got.plt))
+     sub.[wd]	$t1, $t1, $t3
+     ld.[wd]	$t3, $t2, %lo(%pcrel(.got.plt)) # _dl_runtime_resolve
+     addi.[wd]	$t1, $t1, -(PLT_HEADER_SIZE + 12) + 4 
+     addi.[wd]	$t0, $t2, %lo(%pcrel(.got.plt))
+     srli.[wd]	$t1, $t1, log2(16 / GOT_ENTRY_SIZE)
+     ld.[wd]	$t0, $t0, GOT_ENTRY_SIZE
+     jirl	$r0, $t3, 0 */
+
+  if (GOT_ENTRY_SIZE == 8)
+    {
+      entry[0] = 0x1c00000e
+	       | (hi & 0xfffff) << 5;
+      entry[1] = 0x0011bdad;
+      entry[2] = 0x28c001cf
+	       | (lo & 0xfff) << 10;
+      entry[3] = 0x02c001ad
+	       | ((-(PLT_HEADER_SIZE + 12) + 4) & 0xfff) << 10;
+      entry[4] = 0x02c001cc
+	       | (lo & 0xfff) << 10;
+      entry[5] = 0x004501ad
+	       | (4 - LARCH_ELF_LOG_WORD_BYTES) << 10;
+      entry[6] = 0x28c0018c
+	       | GOT_ENTRY_SIZE << 10;
+      entry[7] = 0x4c0001e0;
+    }
+  else
+    {
+      entry[0] = 0x1c00000e
+	       | (hi & 0xfffff) << 5;
+      entry[1] = 0x00113dad;
+      entry[2] = 0x288001cf
+	       | (lo & 0xfff) << 10;
+      entry[3] = 0x028001ad
+	       | ((-(PLT_HEADER_SIZE + 12)) & 0xfff) << 10;
+      entry[4] = 0x028001cc
+	       | (lo & 0xfff) << 10;
+      entry[5] = 0x004481ad
+	       | (4 - LARCH_ELF_LOG_WORD_BYTES) << 10;
+      entry[6] = 0x2880018c
+	       | GOT_ENTRY_SIZE << 10;
+      entry[7] = 0x4c0001e0;
+    }
+}
+
+/* Generate a PLT entry.  */
+
+static void
+loongarch_make_plt_entry (bfd_vma got_plt_entry_addr,
+			  bfd_vma plt_entry_addr,
+			  uint32_t *entry)
+{
+  int64_t pcrel = got_plt_entry_addr - plt_entry_addr;
+  int64_t hi = (pcrel & 0x800? 1 : 0) + (pcrel >> 12);
+  int64_t lo = pcrel & 0xfff;
+  if ((hi >> 19) != 0 && (hi >> 19) != -1)
+    abort ();//overflow
+
+  /* pcaddu12i	$t3, %hi(%pcrel(.got.plt entry))
+     ld.[wd]	$t3, $t3, %lo(%pcrel(.got.plt entry))
+     jirl	$t1, $t3, 0
+     addi	$r0, $r0, 0 */
+
+  entry[0] = 0x1c00000f
+	   | (hi & 0xfffff) << 5;
+  entry[1] = (GOT_ENTRY_SIZE == 8? 0x28c001ef : 0x288001ef)
+	   | (lo & 0xfff) << 10;
+  //entry[2] = 0x4c0001ed;	/* jirl $r13, $15, 0 */
+  //entry[3] = 0x03400000;	/* nop */
+  //entry[2] = 0x1800002d;	/* pcaddi $13, 4 */
+  entry[2] = 0x1c00000d;	/* pcaddu12i $13, 4 */
+  entry[3] = 0x4c0001e0;	/* jirl $r0, $15, 0 */
+}
+
+/* Create an entry in an Loongarch ELF linker hash table.  */
+
+static struct bfd_hash_entry *
+link_hash_newfunc (struct bfd_hash_entry *entry,
+		   struct bfd_hash_table *table, const char *string)
+{
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (entry == NULL)
+    {
+      entry = bfd_hash_allocate
+		(table, sizeof (struct loongarch_elf_link_hash_entry));
+      if (entry == NULL)
+	return entry;
+    }
+
+  /* Call the allocation method of the superclass.  */
+  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
+  if (entry != NULL)
+    {
+      struct loongarch_elf_link_hash_entry *eh;
+
+      eh = (struct loongarch_elf_link_hash_entry *) entry;
+      eh->dyn_relocs = NULL;
+      eh->tls_type = GOT_UNKNOWN;
+    }
+
+  return entry;
+}
+
+/* Compute a hash of a local hash entry.  We use elf_link_hash_entry
+  for local symbol so that we can handle local STT_GNU_IFUNC symbols
+  as global symbol.  We reuse indx and dynstr_index for local symbol
+  hash since they aren't used by global symbols in this backend.  */
+
+static hashval_t
+elfNN_loongarch_local_htab_hash (const void *ptr)
+{
+  struct elf_link_hash_entry *h
+    = (struct elf_link_hash_entry *) ptr;
+  return ELF_LOCAL_SYMBOL_HASH (h->indx, h->dynstr_index);
+}
+
+/* Compare local hash entries.  */
+
+static int
+elfNN_loongarch_local_htab_eq (const void *ptr1, const void *ptr2)
+{
+  struct elf_link_hash_entry *h1
+    = (struct elf_link_hash_entry *) ptr1;
+  struct elf_link_hash_entry *h2
+    = (struct elf_link_hash_entry *) ptr2;
+
+  return h1->indx == h2->indx && h1->dynstr_index == h2->dynstr_index;
+}
+
+/* Find and/or create a hash entry for local symbol.  */
+static struct elf_link_hash_entry *
+elfNN_loongarch_get_local_sym_hash (struct loongarch_elf_link_hash_table *htab,
+				    bfd *abfd, const Elf_Internal_Rela *rel,
+				    bfd_boolean create)
+{
+  struct loongarch_elf_link_hash_entry e, *ret;
+  asection *sec = abfd->sections;
+  hashval_t h = ELF_LOCAL_SYMBOL_HASH (sec->id, ELFNN_R_SYM (rel->r_info));
+  void **slot;
+
+  e.elf.indx = sec->id;
+  e.elf.dynstr_index = ELFNN_R_SYM (rel->r_info);
+  slot = htab_find_slot_with_hash
+	   (htab->loc_hash_table, &e, h, create ? INSERT : NO_INSERT);
+
+  if (!slot)
+    return NULL;
+
+  if (*slot)
+    {
+      ret = (struct loongarch_elf_link_hash_entry *) *slot;
+      return &ret->elf;
+    }
+
+  ret = (struct loongarch_elf_link_hash_entry *)
+	  objalloc_alloc ((struct objalloc *) htab->loc_hash_memory,
+			  sizeof (struct loongarch_elf_link_hash_entry));
+  if (ret)
+    {
+      memset (ret, 0, sizeof (*ret));
+      ret->elf.indx = sec->id;
+      ret->elf.pointer_equality_needed = 0;
+      ret->elf.dynstr_index = ELFNN_R_SYM (rel->r_info);
+      ret->elf.dynindx = -1;
+      ret->elf.needs_plt = 0;
+      ret->elf.plt.refcount = -1;
+      ret->elf.got.refcount = -1;
+      ret->elf.def_dynamic = 0;
+      ret->elf.def_regular = 1;
+      ret->elf.ref_dynamic = 0; /* this should be always 0 for local  */
+      ret->elf.ref_regular = 0;
+      ret->elf.forced_local = 1;
+      ret->elf.root.type = bfd_link_hash_defined;
+      *slot = ret;
+    }
+  return &ret->elf;
+}
+
+/* Destroy an Loongarch elf linker hash table.  */
+
+static void
+elfNN_loongarch_link_hash_table_free (bfd *obfd)
+{
+  struct loongarch_elf_link_hash_table *ret
+    = (struct loongarch_elf_link_hash_table *) obfd->link.hash;
+
+  if (ret->loc_hash_table)
+    htab_delete (ret->loc_hash_table);
+  if (ret->loc_hash_memory)
+    objalloc_free ((struct objalloc *) ret->loc_hash_memory);
+
+  _bfd_elf_link_hash_table_free (obfd);
+}
+
+/* Create a Loongarch ELF linker hash table.  */
+
+static struct bfd_link_hash_table *
+loongarch_elf_link_hash_table_create (bfd *abfd)
+{
+  struct loongarch_elf_link_hash_table *ret;
+  bfd_size_type amt = sizeof (struct loongarch_elf_link_hash_table);
+
+  ret = (struct loongarch_elf_link_hash_table *) bfd_zmalloc (amt);
+  if (ret == NULL)
+    return NULL;
+
+  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc,
+	 sizeof (struct loongarch_elf_link_hash_entry), LARCH_ELF_DATA))
+    {
+      free (ret);
+      return NULL;
+    }
+
+  ret->max_alignment = MINUS_ONE;
+
+  ret->loc_hash_table = htab_try_create (1024,
+					 elfNN_loongarch_local_htab_hash,
+					 elfNN_loongarch_local_htab_eq,
+					 NULL);
+  ret->loc_hash_memory = objalloc_create ();
+  if (!ret->loc_hash_table || !ret->loc_hash_memory)
+    {
+      elfNN_loongarch_link_hash_table_free (abfd);
+      return NULL;
+    }
+  ret->elf.root.hash_table_free = elfNN_loongarch_link_hash_table_free;
+
+  return &ret->elf.root;
+}
+
+/* Merge backend specific data from an object file to the output
+   object file when linking.  */
+
+static bfd_boolean
+_bfd_loongarch_elf_merge_private_bfd_data (bfd *ibfd,
+					   struct bfd_link_info *info)
+{
+  bfd *obfd = info->output_bfd;
+  flagword in_flags = elf_elfheader (ibfd)->e_flags;
+  flagword out_flags = elf_elfheader (obfd)->e_flags;
+
+  if (!is_loongarch_elf (ibfd) || !is_loongarch_elf (obfd))
+    {
+      /* Make sure one of ibfd or obfd e_flags must be set.  */
+      /* FIXME: EF_LARCH_ABI_LP64 ? .  */
+      if (!is_loongarch_elf (ibfd) && !elf_flags_init (obfd))
+	{
+	  elf_flags_init (obfd) = TRUE;
+	  elf_elfheader (obfd)->e_flags = EF_LARCH_ABI_LP64;
+	}
+
+      if (!is_loongarch_elf (obfd) && !elf_flags_init (ibfd))
+	{
+	  elf_flags_init (ibfd) = TRUE;
+	  elf_elfheader (ibfd)->e_flags = EF_LARCH_ABI_LP64;
+	}
+
+      return TRUE;
+    }
+
+  if (strcmp (bfd_get_target (ibfd), bfd_get_target (obfd)) != 0)
+    {
+      _bfd_error_handler
+	(_("%pB: ABI is incompatible with that of the selected emulation:\n"
+	   "  target emulation `%s' does not match `%s'"),
+	 ibfd, bfd_get_target (ibfd), bfd_get_target (obfd));
+      return FALSE;
+    }
+
+  if (!_bfd_elf_merge_object_attributes (ibfd, info))
+    return FALSE;
+
+  if (!elf_flags_init (obfd))
+    {
+      elf_flags_init (obfd) = TRUE;
+      elf_elfheader (obfd)->e_flags = in_flags;
+      return TRUE;
+    }
+
+  /* Disallow linking different float ABIs.  */
+  if ((out_flags ^ in_flags) & EF_LARCH_ABI)
+    {
+      _bfd_error_handler
+	(_("%pB: can't link different ABI object."), ibfd);
+      goto fail;
+    }
+
+  return TRUE;
+
+fail:
+  bfd_set_error (bfd_error_bad_value);
+  return FALSE;
+}
+
+/* Create the .got section.  */
+
+static bfd_boolean
+loongarch_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)
+{
+  flagword flags;
+  asection *s, *s_got;
+  struct elf_link_hash_entry *h;
+  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  struct elf_link_hash_table *htab = elf_hash_table (info);
+
+  /* This function may be called more than once.  */
+  if (htab->sgot != NULL)
+    return TRUE;
+
+  flags = bed->dynamic_sec_flags;
+
+  s = bfd_make_section_anyway_with_flags
+	(abfd, bed->rela_plts_and_copies_p ? ".rela.got" : ".rel.got",
+	 bed->dynamic_sec_flags | SEC_READONLY);
+  if (s == NULL
+      || !bfd_set_section_alignment (s, bed->s->log_file_align))
+    return FALSE;
+  htab->srelgot = s;
+
+  s = s_got = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
+  if (s == NULL
+      || !bfd_set_section_alignment (s, bed->s->log_file_align))
+    return FALSE;
+  htab->sgot = s;
+
+  /* The first bit of the global offset table is the header.  */
+  s->size += bed->got_header_size;
+
+  if (bed->want_got_plt)
+    {
+      s = bfd_make_section_anyway_with_flags (abfd, ".got.plt", flags);
+      if (s == NULL
+	  || !bfd_set_section_alignment (s, bed->s->log_file_align))
+	return FALSE;
+      htab->sgotplt = s;
+
+      /* 相比_bfd_elf_create_got_section：
+	 一方面，RISCV似乎是希望.got.plt和.got都有header；
+	 而且_GLOBAL_OFFSET_TABLE_是.got的开头，而不是.got.plt的开头。
+	 和公共部分需求有冲突。所以自己实现了 */
+
+      /* Reserve room for the header.  */
+      s->size = GOTPLT_HEADER_SIZE;
+    }
+
+  if (bed->want_got_sym)
+    {
+      /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
+	 section.  We don't do this in the linker script because we don't want
+	 to define the symbol if we are not creating a global offset table.  */
+      h = _bfd_elf_define_linkage_sym (abfd, info, s_got,
+				       "_GLOBAL_OFFSET_TABLE_");
+      elf_hash_table (info)->hgot = h;
+      if (h == NULL)
+	return FALSE;
+    }
+  return TRUE;
+}
+
+/* Create .plt, .rela.plt, .got, .got.plt, .rela.got, .dynbss, and
+   .rela.bss sections in DYNOBJ, and set up shortcuts to them in our
+   hash table.  */
+
+static bfd_boolean
+loongarch_elf_create_dynamic_sections (bfd *dynobj,
+				       struct bfd_link_info *info)
+{
+  struct loongarch_elf_link_hash_table *htab;
+
+  htab = loongarch_elf_hash_table (info);
+  BFD_ASSERT (htab != NULL);
+
+  if (!loongarch_elf_create_got_section (dynobj, info))
+    return FALSE;
+
+  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
+    return FALSE;
+
+  if (!bfd_link_pic (info))
+    {
+      htab->sdyntdata =
+	bfd_make_section_anyway_with_flags (dynobj, ".tdata.dyn",
+					    SEC_ALLOC | SEC_THREAD_LOCAL);
+    }
+
+  if (!htab->elf.splt || !htab->elf.srelplt || !htab->elf.sdynbss
+      || (!bfd_link_pic (info) && (!htab->elf.srelbss || !htab->sdyntdata)))
+    abort ();
+
+  return TRUE;
+}
+
+static bfd_boolean
+loongarch_elf_record_tls_and_got_reference (bfd *abfd,
+					    struct bfd_link_info *info,
+					    struct elf_link_hash_entry *h,
+					    unsigned long symndx,
+					    char tls_type)
+{
+  struct loongarch_elf_link_hash_table *htab = loongarch_elf_hash_table (info);
+  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+
+  /* This is a global offset table entry for a local symbol.  */
+  if (elf_local_got_refcounts (abfd) == NULL)
+    {
+      bfd_size_type size =
+	symtab_hdr->sh_info * (sizeof (bfd_vma) + sizeof (tls_type));
+      if (!(elf_local_got_refcounts (abfd) = bfd_zalloc (abfd, size)))
+	return FALSE;
+      _bfd_loongarch_elf_local_got_tls_type (abfd)
+	= (char *) (elf_local_got_refcounts (abfd) + symtab_hdr->sh_info);
+    }
+
+  switch (tls_type)
+    {
+    case GOT_NORMAL:
+    case GOT_TLS_GD:
+    case GOT_TLS_IE:
+      /* need GOT */
+      if (htab->elf.sgot == NULL
+	  && !loongarch_elf_create_got_section (htab->elf.dynobj, info))
+	return FALSE;
+      if (h)
+	{
+	  if (h->got.refcount < 0)
+	    h->got.refcount = 0;
+	  h->got.refcount++;
+	}
+      else
+	elf_local_got_refcounts (abfd) [symndx] ++;
+      break;
+    case GOT_TLS_LE:
+      /* no need for GOT */
+      break;
+    default:
+      _bfd_error_handler (_("%pB: Interl error: unreachable."));
+      return FALSE;
+    }
+
+  char *new_tls_type = &_bfd_loongarch_elf_tls_type (abfd, h, symndx);
+  *new_tls_type |= tls_type;
+  if ((*new_tls_type & GOT_NORMAL) && (*new_tls_type & ~GOT_NORMAL))
+    {
+      _bfd_error_handler
+	(_("%pB: `%s' accessed both as normal and thread local symbol"),
+	 abfd, h ? h->root.root.string : "<local>");
+      return FALSE;
+    }
+
+  return TRUE;
+} 
+
+/* Look through the relocs for a section during the first phase, and
+   allocate space in the global offset table or procedure linkage
+   table.  */
+
+static bfd_boolean
+loongarch_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
+			    asection *sec, const Elf_Internal_Rela *relocs)
+{
+  struct loongarch_elf_link_hash_table *htab;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel;
+  asection *sreloc = NULL;
+
+  if (bfd_link_relocatable (info))
+    return TRUE;
+
+  htab = loongarch_elf_hash_table (info);
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+
+  if (htab->elf.dynobj == NULL)
+    htab->elf.dynobj = abfd;
+
+  /* 这个函数的遍历每一个重定位，将一些信息归置到符号中。这之后的处理
+     都会通过遍历符号进行，根据符号中的信息来确定最终二进制文件的形态。
+     1.根据重定位类型记录那个符号是否需要GOT entry
+     2.根据重定位类型记录那个符号的TLS引用模型
+     3.处理IFUNC
+     4.等等
+  */
+
+  for (rel = relocs; rel < relocs + sec->reloc_count; rel++)
+    {
+      unsigned int r_type;
+      unsigned int r_symndx;
+      struct elf_link_hash_entry *h;
+      Elf_Internal_Sym *isym = NULL;
+
+      /* 意味着在dynamic_sections_created置位的情况下，这个重定位可能需要动态
+	 连接器的帮助。如果是这样，我们会在动态重定位表中为其分配一个表项。 */
+      int need_dynreloc;
+
+      /* 意味着这个动态重定位仅需要符号的pcrel信息，即符号定义在自身模块内
+	 及延伸出来的其他信息。如果是这样，我们就在连接时知道了这个重定位的值，
+	 就可以把这个动态重定位取消掉。 */
+      int only_need_pcrel;
+
+      r_symndx = ELFNN_R_SYM (rel->r_info);
+      r_type = ELFNN_R_TYPE (rel->r_info);
+
+      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
+	{
+	  _bfd_error_handler
+	    (_("%pB: bad symbol index: %d"), abfd, r_symndx);
+	  return FALSE;
+	}
+
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  /* A local symbol.  */
+	  isym = bfd_sym_from_r_symndx (&htab->sym_cache, abfd, r_symndx);
+	  if (isym == NULL)
+	    return FALSE;
+
+	  if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
+	    {
+	      h = elfNN_loongarch_get_local_sym_hash (htab, abfd, rel, TRUE);
+	      if (h == NULL)
+		return FALSE;
+
+	      h->type = STT_GNU_IFUNC;
+	      h->ref_regular = 1;
+	    }
+	  else
+	    h = NULL;
+	}
+      else
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	}
+
+      if (h && h->type == STT_GNU_IFUNC)
+	{
+	  if (htab->elf.dynobj == NULL)
+	    htab->elf.dynobj = abfd;
+
+	  if (!htab->elf.splt
+	      && !_bfd_elf_create_ifunc_sections (htab->elf.dynobj, info))
+	    /* If '.plt' not represent, create '.iplt' to deal with ifunc. */
+	    return FALSE;
+
+	  if (h->plt.refcount < 0)
+	    h->plt.refcount = 0;
+	  h->plt.refcount++;
+	  h->needs_plt = 1;
+
+	  elf_tdata (info->output_bfd)->has_gnu_osabi
+	    |= elf_gnu_osabi_ifunc;
+	}
+
+      need_dynreloc = 0;
+      only_need_pcrel = 0;
+      switch (r_type)
+	{
+	case R_LARCH_SOP_PUSH_GPREL:
+	  if (!loongarch_elf_record_tls_and_got_reference
+		 (abfd, info, h, r_symndx, GOT_NORMAL))
+	    return FALSE;
+	  break;
+
+	case R_LARCH_SOP_PUSH_TLS_GD:
+	  if (!loongarch_elf_record_tls_and_got_reference
+		 (abfd, info, h, r_symndx, GOT_TLS_GD))
+	    return FALSE;
+	  break;
+
+	case R_LARCH_SOP_PUSH_TLS_GOT:
+	  if (bfd_link_pic (info))
+	    /* may fail for lazy-bind */
+	    info->flags |= DF_STATIC_TLS;
+
+	  if (!loongarch_elf_record_tls_and_got_reference
+		 (abfd, info, h, r_symndx, GOT_TLS_IE))
+	    return FALSE;
+	  break;
+
+	case R_LARCH_SOP_PUSH_TLS_TPREL:
+	  if (!bfd_link_executable (info))
+	    return FALSE;
+
+	  info->flags |= DF_STATIC_TLS;
+
+	  if (!loongarch_elf_record_tls_and_got_reference
+                 (abfd, info, h, r_symndx, GOT_TLS_LE))
+	    return FALSE;
+	  break;
+
+	case R_LARCH_SOP_PUSH_ABSOLUTE:
+	  if (h != NULL)
+	    /* If this reloc is in a read-only section, we might
+	       need a copy reloc.  We can't check reliably at this
+	       stage whether the section is read-only, as input
+	       sections have not yet been mapped to output sections.
+	       Tentatively set the flag for now, and correct in
+	       adjust_dynamic_symbol.  */
+	    /* 这个flag的本质是关注对一个符号的引用能否被动态连接器改变。
+	       比如la.pcrel，在连接时会将符号的pc相对偏移量写入指令立即数；
+	       而代码段是只读的，动态连接器无法改动指令，这时，那个la只能引用
+	       local的那个符号的定义了，无法被动态连接器改变。
+	       而使用got表的话，因为got entry可以被动态连接器改变，因此可以改变
+	       la到底哪个模块中的符号。
+	       动态库里的符号定义可能被可执行文件中的符号定义覆盖，由此，动态库
+	       中对符号的引用必须可以被动态连接器改变；
+	       而如果在可执行文件中la.pcrel一个动态库中的对象，按常理来说，如果
+	       不走got表，这个引用是错误的。但如果我们真的把这个符号定义在
+	       可执行文件中，而将动态库中对象的初始值复制到可执行文件中
+	       （R_LARCH_COPY），这其实等效于引用动态库中的对象了。
+	       由此，如果某个重定位一旦可能不被动态链接器控制，这个flag被置位，
+	       接下来的处理会根据情况加上R_LARCH_COPY重定位。这样，我们也只能
+	       在可执行文件中做这件事；动态库中的R_LARCH_COPY是很奇怪的。 */
+	    h->non_got_ref = 1;
+	  break;
+
+	case R_LARCH_SOP_PUSH_PCREL:
+	  if (h != NULL)
+	    {
+	      h->non_got_ref = 1;
+
+	      /* We try to create PLT stub for all non-local function.  */
+	      if (h->plt.refcount < 0)
+		h->plt.refcount = 0;
+	      h->plt.refcount++;
+	    }
+	  break;
+
+	case R_LARCH_SOP_PUSH_PLT_PCREL:
+	  /* This symbol requires a procedure linkage table entry.  We
+	     actually build the entry in adjust_dynamic_symbol,
+	     because this might be a case of linking PIC code without
+	     linking in any dynamic objects, in which case we don't
+	     need to generate a procedure linkage table after all.  */
+	  if (h != NULL)
+	    {
+	      h->needs_plt = 1;
+	      if (h->plt.refcount < 0)
+		h->plt.refcount = 0;
+	      h->plt.refcount++;
+	    }
+	  break;
+
+	case R_LARCH_TLS_DTPREL32:
+	case R_LARCH_TLS_DTPREL64:
+	  need_dynreloc = 1;
+	  only_need_pcrel = 1;
+	  break;
+
+	case R_LARCH_JUMP_SLOT:
+	case R_LARCH_32:
+	case R_LARCH_64:
+	  need_dynreloc = 1;
+
+	  /* If resolved symbol is defined in this object,
+	       1. Under pie, the symbol is known. We convert it
+		  into R_LARCH_RELATIVE and need load-addr still.
+	       2. Under pde, the symbol is known and we can discard R_LARCH_NN.
+	       3. Under dll, R_LARCH_NN can't be changed normally, since
+		  its defination could be covered by the one in executable.
+		  For symbolic, we convert it into R_LARCH_RELATIVE.
+	     Thus, only under pde, it needs pcrel only. We discard it. */
+	  only_need_pcrel = bfd_link_pde (info);
+
+	  if (h != NULL)
+	    h->non_got_ref = 1;
+	  break;
+
+	case R_LARCH_GNU_VTINHERIT:
+	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+	    return FALSE;
+	  break;
+
+	case R_LARCH_GNU_VTENTRY:
+	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
+	    return FALSE;
+	  break;
+
+	default:
+	  break;
+	}
+
+      /* Record some info for sizing and allocating dynamic entry */
+      if (need_dynreloc && (sec->flags & SEC_ALLOC))
+	{
+	  /* When creating a shared object, we must copy these
+	     relocs into the output file.  We create a reloc
+	     section in dynobj and make room for the reloc.  */
+	  struct elf_dyn_relocs *p;
+	  struct elf_dyn_relocs **head;
+
+	  if (sreloc == NULL)
+	    {
+	      sreloc = _bfd_elf_make_dynamic_reloc_section
+			 (sec, htab->elf.dynobj, LARCH_ELF_LOG_WORD_BYTES,
+			  abfd, /*rela?*/ TRUE);
+
+	      if (sreloc == NULL)
+		return FALSE;
+	    }
+
+	  /* If this is a global symbol, we count the number of
+	     relocations we need for this symbol.  */
+	  if (h != NULL)
+	    head = &((struct loongarch_elf_link_hash_entry *) h)->dyn_relocs;
+	  else
+	    {
+	      /* Track dynamic relocs needed for local syms too.
+		 We really need local syms available to do this
+		 easily.  Oh well.  */
+
+	      asection *s;
+	      void *vpp;
+
+	      s = bfd_section_from_elf_index (abfd, isym->st_shndx);
+	      if (s == NULL)
+		s = sec;
+
+	      vpp = &elf_section_data (s)->local_dynrel;
+	      head = (struct elf_dyn_relocs **) vpp;
+	    }
+
+	  p = *head;
+	  if (p == NULL || p->sec != sec)
+	    {
+	      bfd_size_type amt = sizeof *p;
+	      p = (struct elf_dyn_relocs *) bfd_alloc (htab->elf.dynobj, amt);
+	      if (p == NULL)
+		return FALSE;
+	      p->next = *head;
+	      *head = p;
+	      p->sec = sec;
+	      p->count = 0;
+	      p->pc_count = 0;
+	    }
+
+	  p->count++;
+	  p->pc_count += only_need_pcrel;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Find dynamic relocs for H that apply to read-only sections.  */
+
+static asection *
+readonly_dynrelocs (struct elf_link_hash_entry *h)
+{
+  struct elf_dyn_relocs *p;
+
+  for (p = loongarch_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *s = p->sec->output_section;
+
+      if (s != NULL && (s->flags & SEC_READONLY) != 0)
+	return p->sec;
+    }
+  return NULL;
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+static bfd_boolean
+loongarch_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
+				     struct elf_link_hash_entry *h)
+{
+  struct loongarch_elf_link_hash_table *htab;
+  struct loongarch_elf_link_hash_entry * eh;
+  bfd *dynobj;
+  asection *s, *srel;
+
+  htab = loongarch_elf_hash_table (info);
+  BFD_ASSERT (htab != NULL);
+
+  dynobj = htab->elf.dynobj;
+
+  /* Make sure we know what is going on here.  */
+  BFD_ASSERT (dynobj != NULL
+	      && (h->needs_plt
+		  || h->type == STT_GNU_IFUNC
+		  || h->is_weakalias
+		  || (h->def_dynamic
+		      && h->ref_regular
+		      && !h->def_regular)));
+
+  /* If this is a function, put it in the procedure linkage table.  We
+     will fill in the contents of the procedure linkage table later
+     (although we could actually do it here).  */
+  if (h->type == STT_FUNC || h->type == STT_GNU_IFUNC || h->needs_plt)
+    {
+      if (h->plt.refcount < 0
+	  || (h->type != STT_GNU_IFUNC
+	      && (SYMBOL_REFERENCES_LOCAL (info, h)
+		  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
+		      && h->root.type == bfd_link_hash_undefweak))))
+	{
+	  /* This case can occur if we saw a R_LARCH_SOP_PUSH_PLT_PCREL reloc
+	     in an input file, but the symbol was never referred to by a
+	     dynamic object, or if all references were garbage collected.
+	     In such a case, we don't actually need to build a PLT entry.  */
+	  h->plt.offset = MINUS_ONE;
+	  h->needs_plt = 0;
+	}
+      else
+	h->needs_plt = 1;
+
+      return TRUE;
+    }
+  else
+    h->plt.offset = MINUS_ONE;
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->is_weakalias)
+    {
+      struct elf_link_hash_entry *def = weakdef (h);
+      BFD_ASSERT (def->root.type == bfd_link_hash_defined);
+      h->root.u.def.section = def->root.u.def.section;
+      h->root.u.def.value = def->root.u.def.value;
+      return TRUE;
+    }
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (bfd_link_dll (info))
+    return TRUE;
+
+  /* If there are no references to this symbol that do not use the
+     GOT, we don't need to generate a copy reloc.  */
+  if (!h->non_got_ref)
+    return TRUE;
+
+  /* If -z nocopyreloc was given, we won't generate them either.  */
+  if (info->nocopyreloc)
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  /* If we don't find any dynamic relocs in read-only sections, then
+     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
+  if (!readonly_dynrelocs (h))
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+  /* We must generate a R_LARCH_COPY reloc to tell the dynamic linker
+     to copy the initial value out of the dynamic object and into the
+     runtime process image.  We need to remember the offset into the
+     .rel.bss section we are going to use.  */
+  eh = (struct loongarch_elf_link_hash_entry *) h;
+  if (eh->tls_type & ~GOT_NORMAL)
+    {
+      s = htab->sdyntdata;
+      srel = htab->elf.srelbss;
+    }
+  else
+    if ((h->root.u.def.section->flags & SEC_READONLY) != 0)
+      {
+	s = htab->elf.sdynrelro;
+	srel = htab->elf.sreldynrelro;
+      }
+    else
+      {
+	s = htab->elf.sdynbss;
+	srel = htab->elf.srelbss;
+      }
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
+    {
+      srel->size += sizeof (ElfNN_External_Rela);
+      h->needs_copy = 1;
+    }
+
+  return _bfd_elf_adjust_dynamic_copy (info, h, s);
+}
+
+
+/* Allocate space in .plt, .got and associated reloc sections for
+   dynamic relocs.  */
+
+static bfd_boolean
+allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
+{
+  struct bfd_link_info *info;
+  struct loongarch_elf_link_hash_table *htab;
+  struct loongarch_elf_link_hash_entry *eh;
+  struct elf_dyn_relocs *p;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  eh = (struct loongarch_elf_link_hash_entry *) h;
+  info = (struct bfd_link_info *) inf;
+  htab = loongarch_elf_hash_table (info);
+  BFD_ASSERT (htab != NULL);
+
+  /* 在这里针对符号对.got .iplt .plt的扩充和后续elf_finish_dynamic_symbol补充
+     内容对照；WILL_CALL_FINISH_DYNAMIC_SYMBOL似乎指的是这个符号在将来会不会被
+     finish_dynamic_symbol调用。
+     a. 对于非IFUNC符号，被allocate_dynrelocs照顾到的符号h要保证在链接后期被
+     elf_finish_dynamic_symbol调用
+     b. STT_GNU_IFUNC符号一定走plt，但是对于那些local转化为h的符号，默认是不会
+     被调用allocate_dynrelocs和elf_finish_dynamic_symbol的，要手动遍历
+     这些符号来调用这两个函数，从而为它们分配plt stub；
+     而WILL_CALL_FINISH_DYNAMIC_SYMBOL返回false，因此下面的逻辑都是
+     WILL_CALL_FINISH_DYNAMIC_SYMBOL和对IFUNC的判断配合起来。  */
+
+  do
+    {
+      asection *plt, *gotplt, *relplt;
+
+      if (!h->needs_plt)
+	break;
+
+      h->needs_plt = 0;
+
+      if (htab->elf.splt)
+	{
+	  if (h->dynindx == -1 && !h->forced_local
+	      && !bfd_elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+
+	  if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, bfd_link_pic (info), h)
+	      && h->type != STT_GNU_IFUNC)
+	    break;
+
+	  plt = htab->elf.splt;
+	  gotplt = htab->elf.sgotplt;
+	  relplt = htab->elf.srelplt;
+	}
+      else if (htab->elf.iplt)
+	{
+	  /* .iplt only for IFUNC */
+	  if (h->type != STT_GNU_IFUNC)
+	    break;
+
+	  plt = htab->elf.iplt;
+	  gotplt = htab->elf.igotplt;
+	  relplt = htab->elf.irelplt;
+	}
+      else
+	break;
+
+      if (plt->size == 0)
+	plt->size = PLT_HEADER_SIZE;
+
+      h->plt.offset = plt->size;
+      plt->size += PLT_ENTRY_SIZE;
+      gotplt->size += GOT_ENTRY_SIZE;
+      relplt->size += sizeof (ElfNN_External_Rela);
+
+      h->needs_plt = 1;
+    }
+  while (0);
+
+  if (!h->needs_plt)
+    h->plt.offset = MINUS_ONE;
+
+  if (0 < h->got.refcount)
+    {
+      asection *s;
+      bfd_boolean dyn;
+      int tls_type = loongarch_elf_hash_entry (h)->tls_type;
+
+      /* Make sure this symbol is output as a dynamic symbol.
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1 && !h->forced_local
+	  && !bfd_elf_link_record_dynamic_symbol (info, h))
+	return FALSE;
+
+      s = htab->elf.sgot;
+      h->got.offset = s->size;
+      dyn = htab->elf.dynamic_sections_created;
+      if (tls_type & (GOT_TLS_GD | GOT_TLS_IE))
+	{
+	  /* TLS_GD needs two dynamic relocs and two GOT slots.  */
+	  if (tls_type & GOT_TLS_GD)
+	    {
+	      s->size += 2 * GOT_ENTRY_SIZE;
+	      htab->elf.srelgot->size += 2 * sizeof (ElfNN_External_Rela);
+	    }
+
+	  /* TLS_IE needs one dynamic reloc and one GOT slot.  */
+	  if (tls_type & GOT_TLS_IE)
+	    {
+	      s->size += GOT_ENTRY_SIZE;
+	      htab->elf.srelgot->size += sizeof (ElfNN_External_Rela);
+	    }
+	}
+      else
+	{
+	  s->size += GOT_ENTRY_SIZE;
+	  if ((WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, bfd_link_pic (info), h)
+	       && !UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))
+	      || h->type == STT_GNU_IFUNC)
+	    htab->elf.srelgot->size += sizeof (ElfNN_External_Rela);
+	}
+    }
+  else
+    h->got.offset = MINUS_ONE;
+
+  if (eh->dyn_relocs == NULL)
+    return TRUE;
+
+  /* 如果某些函数未被定义，SYMBOL_CALLS_LOCAL返回1；
+     而SYMBOL_REFERENCES_LOCAL返回0。
+     似乎是因为未定义的函数可以有plt从而将其转化为local的。 */
+  if (SYMBOL_REFERENCES_LOCAL (info, h))
+    {
+      struct elf_dyn_relocs **pp;
+
+      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
+	{
+	  p->count -= p->pc_count;
+	  p->pc_count = 0;
+	  if (p->count == 0)
+	    *pp = p->next;
+	  else
+	    pp = &p->next;
+	}
+    }
+
+  if (h->root.type == bfd_link_hash_undefweak)
+    {
+      if (UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))
+	eh->dyn_relocs = NULL;
+      else if (h->dynindx == -1 && !h->forced_local
+	       /* Make sure this symbol is output as a dynamic symbol.
+		  Undefined weak syms won't yet be marked as dynamic.  */
+	       && !bfd_elf_link_record_dynamic_symbol (info, h))
+	return FALSE;
+    }
+
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *sreloc = elf_section_data (p->sec)->sreloc;
+      sreloc->size += p->count * sizeof (ElfNN_External_Rela);
+    }
+
+  return TRUE;
+}
+
+static bfd_boolean
+elfNN_loongarch_allocate_local_dynrelocs (void **slot, void *inf)
+{
+  struct elf_link_hash_entry *h
+    = (struct elf_link_hash_entry *) *slot;
+
+  if (!h->def_regular
+      || !h->ref_regular
+      || !h->forced_local
+      || h->root.type != bfd_link_hash_defined)
+    abort ();
+
+  return allocate_dynrelocs (h, inf);
+}
+
+/* Set DF_TEXTREL if we find any dynamic relocs that apply to
+   read-only sections.  */
+
+static bfd_boolean
+maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
+{
+  asection *sec;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  sec = readonly_dynrelocs (h);
+  if (sec != NULL)
+    {
+      struct bfd_link_info *info = (struct bfd_link_info *) info_p;
+
+      info->flags |= DF_TEXTREL;
+      info->callbacks->minfo (
+	_("%pB: dynamic relocation against `%pT' in read-only section `%pA'\n"),
+	sec->owner, h->root.root.string, sec);
+
+      /* Not an error, just cut short the traversal.  */
+      return FALSE;
+    }
+  return TRUE;
+}
+
+static bfd_boolean
+loongarch_elf_size_dynamic_sections (bfd *output_bfd,
+				     struct bfd_link_info *info)
+{
+  struct loongarch_elf_link_hash_table *htab;
+  bfd *dynobj;
+  asection *s;
+  bfd *ibfd;
+
+  htab = loongarch_elf_hash_table (info);
+  BFD_ASSERT (htab != NULL);
+  dynobj = htab->elf.dynobj;
+  BFD_ASSERT (dynobj != NULL);
+
+  if (htab->elf.dynamic_sections_created)
+    {
+      /* Set the contents of the .interp section to the interpreter.  */
+      if (bfd_link_executable (info) && !info->nointerp)
+	{
+	  const char *interpreter;
+	  flagword flags = elf_elfheader (output_bfd)->e_flags;
+	  s = bfd_get_linker_section (dynobj, ".interp");
+	  BFD_ASSERT (s != NULL);
+	  if ((flags & EF_LARCH_ABI) == EF_LARCH_ABI_LP32)
+	    interpreter = "/lib32/ld.so.1";
+	  else if ((flags & EF_LARCH_ABI) == EF_LARCH_ABI_LP64)
+	    interpreter = "/lib64/ld.so.1";
+	  else
+	    interpreter = "/lib/ld.so.1";
+	  s->contents = (unsigned char *) interpreter;
+	  s->size = strlen (interpreter) + 1;
+	}
+    }
+
+  /* Set up .got offsets for local syms, and space for local dynamic
+     relocs.  */
+  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link.next)
+    {
+      bfd_signed_vma *local_got;
+      bfd_signed_vma *end_local_got;
+      char *local_tls_type;
+      bfd_size_type locsymcount;
+      Elf_Internal_Shdr *symtab_hdr;
+      asection *srel;
+
+      if (!is_loongarch_elf (ibfd))
+	continue;
+
+      for (s = ibfd->sections; s != NULL; s = s->next)
+	{
+	  struct elf_dyn_relocs *p;
+
+	  for (p = elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
+	    {
+	      p->count -= p->pc_count;
+	      if (!bfd_is_abs_section (p->sec)
+		  && bfd_is_abs_section (p->sec->output_section))
+		{
+		  /* Input section has been discarded, either because
+		     it is a copy of a linkonce section or due to
+		     linker script /DISCARD/, so we'll be discarding
+		     the relocs too.  */
+		}
+	      else if (0 < p->count)
+		{
+		  srel = elf_section_data (p->sec)->sreloc;
+		  srel->size += p->count * sizeof (ElfNN_External_Rela);
+		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
+		    info->flags |= DF_TEXTREL;
+		}
+	    }
+	}
+
+      local_got = elf_local_got_refcounts (ibfd);
+      if (!local_got)
+	continue;
+
+      symtab_hdr = &elf_symtab_hdr (ibfd);
+      locsymcount = symtab_hdr->sh_info;
+      end_local_got = local_got + locsymcount;
+      local_tls_type = _bfd_loongarch_elf_local_got_tls_type (ibfd);
+      s = htab->elf.sgot;
+      srel = htab->elf.srelgot;
+      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
+	{
+	  if (0 < *local_got)
+	    {
+	      *local_got = s->size;
+	      s->size += GOT_ENTRY_SIZE;
+
+	      if (*local_tls_type & GOT_TLS_GD)
+		s->size += GOT_ENTRY_SIZE;
+
+	      if (bfd_link_pic (info) /* R_LARCH_RELATIVE */
+		  || (*local_tls_type &
+		      (GOT_TLS_GD /* R_LARCH_TLS_DTPRELNN */
+		       | GOT_TLS_IE /* R_LARCH_TLS_TPRELNN */)))
+		srel->size += sizeof (ElfNN_External_Rela);
+	    }
+	  else
+	    *local_got = MINUS_ONE;
+	}
+    }
+
+  /* Allocate global sym .plt and .got entries, and space for global
+     sym dynamic relocs.  */
+  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);
+  /* Allocate .plt and .got entries, and space for local ifunc symbols.  */
+  htab_traverse (htab->loc_hash_table,
+		 elfNN_loongarch_allocate_local_dynrelocs,
+		 info);
+
+  /* Don't allocate .got.plt section if there are no PLT.  */
+  if (htab->elf.sgotplt
+      && htab->elf.sgotplt->size == GOTPLT_HEADER_SIZE
+      && (htab->elf.splt == NULL
+	  || htab->elf.splt->size == 0))
+    htab->elf.sgotplt->size = 0;
+
+  /* The check_relocs and adjust_dynamic_symbol entry points have
+     determined the sizes of the various dynamic sections.  Allocate
+     memory for them.  */
+  for (s = dynobj->sections; s != NULL; s = s->next)
+    {
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+	continue;
+
+      if (s == htab->elf.splt
+	  || s == htab->elf.iplt
+	  || s == htab->elf.sgot
+	  || s == htab->elf.sgotplt
+	  || s == htab->elf.igotplt
+	  || s == htab->elf.sdynbss
+	  || s == htab->elf.sdynrelro)
+	{
+	  /* Strip this section if we don't need it; see the
+	     comment below.  */
+	}
+      else if (strncmp (s->name, ".rela", 5) == 0)
+	{
+	  if (s->size != 0)
+	    {
+	      /* We use the reloc_count field as a counter if we need
+		 to copy relocs into the output file.  */
+	      s->reloc_count = 0;
+	    }
+	}
+      else
+	{
+	  /* It's not one of our sections.  */
+	  continue;
+	}
+
+      if (s->size == 0)
+	{
+	  /* If we don't need this section, strip it from the
+	     output file.  This is mostly to handle .rela.bss and
+	     .rela.plt.  We must create both sections in
+	     create_dynamic_sections, because they must be created
+	     before the linker maps input sections to output
+	     sections.  The linker does that before
+	     adjust_dynamic_symbol is called, and it is that
+	     function which decides whether anything needs to go
+	     into these sections.  */
+	  s->flags |= SEC_EXCLUDE;
+	  continue;
+	}
+
+      if ((s->flags & SEC_HAS_CONTENTS) == 0)
+	continue;
+
+      /* Allocate memory for the section contents.  Zero the memory
+	 for the benefit of .rela.plt, which has 4 unused entries
+	 at the beginning, and we don't want garbage.  */
+      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
+      if (s->contents == NULL)
+	return FALSE;
+    }
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+	 values later, in loongarch_elf_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
+#define add_dynamic_entry(TAG, VAL) \
+      _bfd_elf_add_dynamic_entry (info, TAG, VAL)
+
+      if (bfd_link_executable (info))
+	{
+	  if (!add_dynamic_entry (DT_DEBUG, 0))
+	    return FALSE;
+	}
+
+      if (htab->elf.srelplt->size != 0)
+	{
+	  if (!add_dynamic_entry (DT_PLTGOT, 0)
+	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
+	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
+	      || !add_dynamic_entry (DT_JMPREL, 0))
+	    return FALSE;
+	}
+
+      if (!add_dynamic_entry (DT_RELA, 0)
+	  || !add_dynamic_entry (DT_RELASZ, 0)
+	  || !add_dynamic_entry (DT_RELAENT, sizeof (ElfNN_External_Rela)))
+	return FALSE;
+
+      /* If any dynamic relocs apply to a read-only section,
+	 then we need a DT_TEXTREL entry.  */
+      if ((info->flags & DF_TEXTREL) == 0)
+	elf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);
+
+      if (info->flags & DF_TEXTREL)
+	{
+	  if (!add_dynamic_entry (DT_TEXTREL, 0))
+	    return FALSE;
+	  /* Clear the DF_TEXTREL flag.  It will be set again if we
+             write out an actual text relocation; we may not, because
+             at this point we do not know whether e.g. any .eh_frame
+             absolute relocations have been converted to PC-relative.  */
+	  info->flags &= ~DF_TEXTREL;
+	}
+    }
+#undef add_dynamic_entry
+
+  return TRUE;
+}
+
+
+#define LARCH_LD_STACK_DEPTH 16
+static int64_t lisa_opc_stack[LARCH_LD_STACK_DEPTH];
+static size_t lisa_stack_top = 0;
+
+static bfd_reloc_status_type
+loongarch_push (int64_t val)
+{
+  if (LARCH_LD_STACK_DEPTH <= lisa_stack_top)
+    return bfd_reloc_outofrange;
+  lisa_opc_stack[lisa_stack_top++] = val;
+  return bfd_reloc_ok;
+}
+
+static bfd_reloc_status_type
+loongarch_pop (int64_t *val)
+{
+  if (lisa_stack_top == 0)
+    return bfd_reloc_outofrange;
+  BFD_ASSERT (val);
+  *val = lisa_opc_stack[--lisa_stack_top];
+  return bfd_reloc_ok;
+}
+
+static bfd_reloc_status_type
+loongarch_top (int64_t *val)
+{
+  if (lisa_stack_top == 0)
+    return bfd_reloc_outofrange;
+  BFD_ASSERT (val);
+  *val = lisa_opc_stack[lisa_stack_top - 1];
+  return bfd_reloc_ok;
+}
+
+static void
+loongarch_elf_append_rela (bfd *abfd, asection *s, Elf_Internal_Rela *rel)
+{
+  const struct elf_backend_data *bed;
+  bfd_byte *loc;
+
+  bed = get_elf_backend_data (abfd);
+  loc = s->contents + (s->reloc_count++ * bed->s->sizeof_rela);
+  bed->s->swap_reloca_out (abfd, rel, loc);
+}
+
+/* Emplace a static relocation.  */
+
+static bfd_reloc_status_type
+perform_relocation (const Elf_Internal_Rela *rel,
+		    bfd_vma value,
+		    bfd *input_bfd,
+		    bfd_byte *contents)
+{
+
+  uint32_t insn1;
+  int64_t opr1, opr2, opr3;
+  bfd_reloc_status_type r = bfd_reloc_ok;
+  switch (ELFNN_R_TYPE (rel->r_info))
+    {
+    case R_LARCH_SOP_PUSH_PCREL:
+    case R_LARCH_SOP_PUSH_ABSOLUTE:
+    case R_LARCH_SOP_PUSH_GPREL:
+    case R_LARCH_SOP_PUSH_TLS_TPREL:
+    case R_LARCH_SOP_PUSH_TLS_GOT:
+    case R_LARCH_SOP_PUSH_TLS_GD:
+    case R_LARCH_SOP_PUSH_PLT_PCREL:
+      r = loongarch_push (value);
+      break;
+
+    case R_LARCH_SOP_PUSH_DUP:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1) != bfd_reloc_ok)
+	break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_ASSERT:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok && opr1 == FALSE)
+	r = bfd_reloc_notsupported;
+      break;
+
+    case R_LARCH_SOP_NOT:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (!opr1) != bfd_reloc_ok)
+	break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_SUB:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok
+	  || loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1 - opr2) != bfd_reloc_ok)
+	break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_SL:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok
+	  || loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1 << opr2) != bfd_reloc_ok)
+	break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_SR:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok
+	  || loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1 >> opr2) != bfd_reloc_ok)
+	break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_AND:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok
+	  || loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1 & opr2) != bfd_reloc_ok)
+	break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_ADD:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok
+	  || loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1 + opr2) != bfd_reloc_ok)
+	break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_IF_ELSE:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr3) != bfd_reloc_ok
+	  || loongarch_pop (&opr2) != bfd_reloc_ok
+	  || loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1 ? opr2 : opr3) != bfd_reloc_ok)
+	break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_POP_32_S_10_5:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+	break;
+      if ((opr1 & ~(uint64_t)0xf) != 0x0
+	  && (opr1 & ~(uint64_t)0xf) != ~(uint64_t)0xf)
+	r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+	break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & (~(uint32_t)0x7c00)) | ((opr1 & 0x1f) << 10);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_U_10_12:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+	break;
+      if (opr1 & ~(uint64_t)0xfff)
+	r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+	break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & (~(uint32_t)0x3ffc00)) | ((opr1 & 0xfff) << 10);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_S_10_12:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+	break;
+      if ((opr1 & ~(uint64_t)0x7ff) != 0x0
+	  && (opr1 & ~(uint64_t)0x7ff) != ~(uint64_t)0x7ff)
+	r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+	break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & (~(uint32_t)0x3ffc00)) | ((opr1 & 0xfff) << 10);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_S_10_16:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+	break;
+      if ((opr1 & ~(uint64_t)0x7fff) != 0x0
+	  && (opr1 & ~(uint64_t)0x7fff) != ~(uint64_t)0x7fff)
+	r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+	break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & 0xfc0003ff) | ((opr1 & 0xffff) << 10);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_S_10_16_S2:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+	break;
+      if ((opr1 & 0x3) != 0)
+	r = bfd_reloc_overflow;
+      opr1 >>= 2;
+      if ((opr1 & ~(uint64_t)0x7fff) != 0x0
+	  && (opr1 & ~(uint64_t)0x7fff) != ~(uint64_t)0x7fff)
+	r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+	break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & 0xfc0003ff) | ((opr1 & 0xffff) << 10);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_S_0_5_10_16_S2:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+	break;
+      if ((opr1 & 0x3) != 0)
+	r = bfd_reloc_overflow;
+      opr1 >>= 2;
+      if ((opr1 & ~(uint64_t)0xfffff) != 0x0
+	  && (opr1 & ~(uint64_t)0xfffff) != ~(uint64_t)0xfffff)
+	r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+	break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & 0xfc0003e0)
+	    | ((opr1 & 0xffff) << 10) | ((opr1 & 0x1f0000) >> 16);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_S_5_20:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+	break;
+      if ((opr1 & ~(uint64_t)0x7ffff) != 0x0
+	  && (opr1 & ~(uint64_t)0x7ffff) != ~(uint64_t)0x7ffff)
+	r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+	break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & (~(uint32_t)0x1ffffe0)) | ((opr1 & 0xfffff) << 5);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_S_0_10_10_16_S2:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+	break;
+      if ((opr1 & 0x3) != 0)
+	r = bfd_reloc_overflow;
+      opr1 >>= 2;
+      if ((opr1 & ~(uint64_t)0x1ffffff) != 0x0
+	  && (opr1 & ~(uint64_t)0x1ffffff) != ~(uint64_t)0x1ffffff)
+	r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+	break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & 0xfc000000)
+	    | ((opr1 & 0xffff) << 10) | ((opr1 & 0x3ff0000) >> 16);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_U:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+	break;
+      if (opr1 & ~(uint64_t)0xffffffff)
+	r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+	break;
+      bfd_put (32, input_bfd, opr1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_TLS_DTPREL32:
+    case R_LARCH_32:
+      bfd_put (32, input_bfd, value, contents + rel->r_offset);
+      break;
+    case R_LARCH_TLS_DTPREL64:
+    case R_LARCH_64:
+      bfd_put (64, input_bfd, value, contents + rel->r_offset);
+      break;
+    case R_LARCH_ADD8:
+      opr1 = bfd_get (8, input_bfd, contents + rel->r_offset);
+      bfd_put (8, input_bfd, opr1 + value, contents + rel->r_offset);
+      break;
+    case R_LARCH_ADD16:
+      opr1 = bfd_get (16, input_bfd, contents + rel->r_offset);
+      bfd_put (16, input_bfd, opr1 + value, contents + rel->r_offset);
+      break;
+    case R_LARCH_ADD24:
+      opr1 = bfd_get (24, input_bfd, contents + rel->r_offset);
+      bfd_put (24, input_bfd, opr1 + value, contents + rel->r_offset);
+      break;
+    case R_LARCH_ADD32:
+      opr1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      bfd_put (32, input_bfd, opr1 + value, contents + rel->r_offset);
+      break;
+    case R_LARCH_ADD64:
+      opr1 = bfd_get (64, input_bfd, contents + rel->r_offset);
+      bfd_put (64, input_bfd, opr1 + value, contents + rel->r_offset);
+      break;
+    case R_LARCH_SUB8:
+      opr1 = bfd_get (8, input_bfd, contents + rel->r_offset);
+      bfd_put (8, input_bfd, opr1 - value, contents + rel->r_offset);
+      break;
+    case R_LARCH_SUB16:
+      opr1 = bfd_get (16, input_bfd, contents + rel->r_offset);
+      bfd_put (16, input_bfd, opr1 - value, contents + rel->r_offset);
+      break;
+    case R_LARCH_SUB24:
+      opr1 = bfd_get (24, input_bfd, contents + rel->r_offset);
+      bfd_put (24, input_bfd, opr1 - value, contents + rel->r_offset);
+      break;
+    case R_LARCH_SUB32:
+      opr1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      bfd_put (32, input_bfd, opr1 - value, contents + rel->r_offset);
+      break;
+    case R_LARCH_SUB64:
+      opr1 = bfd_get (64, input_bfd, contents + rel->r_offset);
+      bfd_put (64, input_bfd, opr1 - value, contents + rel->r_offset);
+      break;
+
+    default:
+      r = bfd_reloc_notsupported;
+    }
+  return r;
+}
+
+
+#define LARCH_RECENT_RELOC_QUEUE_LENGTH 72
+static struct
+{
+  bfd *bfd;
+  asection *section;
+  bfd_vma r_offset;
+  int r_type;
+  bfd_vma relocation;
+  Elf_Internal_Sym *sym;
+  struct elf_link_hash_entry *h;
+  bfd_vma addend;
+  int64_t top_then;
+} lisa_reloc_queue [LARCH_RECENT_RELOC_QUEUE_LENGTH];
+static size_t lisa_reloc_queue_head = 0;
+static size_t lisa_reloc_queue_tail = 0;
+
+static const char *
+loongarch_sym_name (bfd *input_bfd, struct elf_link_hash_entry *h,
+		    Elf_Internal_Sym *sym)
+{
+  const char *ret = NULL;
+  if (sym)
+    ret = bfd_elf_string_from_elf_section
+	    (input_bfd, elf_symtab_hdr (input_bfd).sh_link, sym->st_name);
+  else if (h)
+    ret = h->root.root.string;
+
+  if (ret == NULL || *ret == '\0')
+    ret = "<nameless>";
+  return ret;
+}
+
+static void
+loongarch_record_one_reloc (bfd *abfd, asection *section, int r_type,
+			    bfd_vma r_offset, Elf_Internal_Sym *sym,
+			    struct elf_link_hash_entry *h, bfd_vma addend)
+{
+  if ((lisa_reloc_queue_head == 0
+       && lisa_reloc_queue_tail == LARCH_RECENT_RELOC_QUEUE_LENGTH - 1)
+      || (lisa_reloc_queue_head == lisa_reloc_queue_tail + 1))
+    lisa_reloc_queue_head =
+      (lisa_reloc_queue_head + 1) % LARCH_RECENT_RELOC_QUEUE_LENGTH;
+  lisa_reloc_queue[lisa_reloc_queue_tail].bfd = abfd;
+  lisa_reloc_queue[lisa_reloc_queue_tail].section = section;
+  lisa_reloc_queue[lisa_reloc_queue_tail].r_offset = r_offset;
+  lisa_reloc_queue[lisa_reloc_queue_tail].r_type = r_type;
+  lisa_reloc_queue[lisa_reloc_queue_tail].sym = sym;
+  lisa_reloc_queue[lisa_reloc_queue_tail].h = h;
+  lisa_reloc_queue[lisa_reloc_queue_tail].addend = addend;
+  loongarch_top (&lisa_reloc_queue[lisa_reloc_queue_tail].top_then);
+  lisa_reloc_queue_tail =
+    (lisa_reloc_queue_tail + 1) % LARCH_RECENT_RELOC_QUEUE_LENGTH;
+}
+
+static void
+loongarch_dump_reloc_record (void (*p) (const char *fmt, ...))
+{
+  size_t i = lisa_reloc_queue_head;
+  bfd *a_bfd = NULL;
+  asection *section = NULL;
+  bfd_vma r_offset = 0;
+  int inited = 0;
+  p ("Dump relocate record:\n");
+  p ("stack top\t\trelocation name\t\tsymbol");
+  while (i != lisa_reloc_queue_tail)
+    {
+      if (a_bfd != lisa_reloc_queue[i].bfd
+	  || section != lisa_reloc_queue[i].section
+	  || r_offset != lisa_reloc_queue[i].r_offset)
+	{
+	  a_bfd = lisa_reloc_queue[i].bfd;
+	  section = lisa_reloc_queue[i].section;
+	  r_offset = lisa_reloc_queue[i].r_offset;
+	  p ("\nat %pB(%pA+0x%v):\n",
+	     lisa_reloc_queue[i].bfd,
+	     lisa_reloc_queue[i].section,
+	     lisa_reloc_queue[i].r_offset);
+	}
+
+      if (!inited)
+	inited = 1, p ("...\n");
+
+      reloc_howto_type *howto =
+	loongarch_elf_rtype_to_howto (lisa_reloc_queue[i].r_type);
+      p ("0x%V %s\t`%s'",
+	 (bfd_vma) lisa_reloc_queue[i].top_then,
+	 howto ? howto->name : "<unknown reloc>",
+	 loongarch_sym_name (lisa_reloc_queue[i].bfd,
+			     lisa_reloc_queue[i].h,
+			     lisa_reloc_queue[i].sym));
+
+      long addend = lisa_reloc_queue[i].addend;
+      if (addend < 0)
+	p (" - %ld", -addend);
+      else if (0 < addend)
+	p (" + %ld(0x%v)", addend, lisa_reloc_queue[i].addend);
+
+      p ("\n");
+      i = (i + 1) % LARCH_RECENT_RELOC_QUEUE_LENGTH;
+    }
+  p ("\n" "-- Record dump end --\n\n");
+}
+
+
+static bfd_boolean
+loongarch_elf_relocate_section (bfd *output_bfd,
+				struct bfd_link_info *info,
+				bfd *input_bfd,
+				asection *input_section,
+				bfd_byte *contents,
+				Elf_Internal_Rela *relocs,
+				Elf_Internal_Sym *local_syms,
+				asection **local_sections)
+{
+  Elf_Internal_Rela *rel;
+  Elf_Internal_Rela *relend;
+  bfd_boolean fatal = FALSE;
+  asection *sreloc = elf_section_data (input_section)->sreloc;
+  struct loongarch_elf_link_hash_table *htab = loongarch_elf_hash_table (info);
+  Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (input_bfd);
+  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);
+  bfd_vma *local_got_offsets = elf_local_got_offsets (input_bfd);
+  bfd_boolean is_pic = bfd_link_pic (info);
+  bfd_boolean is_dyn = elf_hash_table (info)->dynamic_sections_created;
+  asection *plt = htab->elf.splt ? htab->elf.splt : htab->elf.iplt;
+  asection *got = htab->elf.sgot;
+
+  relend = relocs + input_section->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    {
+      int r_type = ELFNN_R_TYPE (rel->r_info);
+      unsigned long r_symndx = ELFNN_R_SYM (rel->r_info);
+      bfd_vma pc = sec_addr (input_section) + rel->r_offset;
+      reloc_howto_type *howto = loongarch_elf_rtype_to_howto (r_type);
+      asection *sec = NULL;
+      Elf_Internal_Sym *sym = NULL;
+      struct elf_link_hash_entry *h = NULL;
+      const char *name;
+      bfd_reloc_status_type r = bfd_reloc_ok;
+      bfd_boolean is_ie, is_undefweak, unresolved_reloc, defined_local;
+      bfd_boolean resolved_local, resolved_dynly, resolved_to_const;
+      char tls_type;
+      bfd_vma relocation;
+      bfd_vma off, ie_off;
+      int i, j;
+
+      if (howto == NULL
+	  || r_type == R_LARCH_GNU_VTINHERIT
+	  || r_type == R_LARCH_GNU_VTENTRY)
+	continue;
+
+      /* This is a final link.  */
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  is_undefweak = FALSE;
+	  unresolved_reloc = FALSE;
+	  sym = local_syms + r_symndx;
+	  sec = local_sections[r_symndx];
+	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
+
+	  /* Relocate against local STT_GNU_IFUNC symbol.  */
+	  if (!bfd_link_relocatable (info)
+	      && ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
+	    {
+	      h = elfNN_loongarch_get_local_sym_hash
+		    (htab, input_bfd, rel, FALSE);
+	      if (h == NULL)
+		abort ();
+
+	      /* Set STT_GNU_IFUNC symbol value.  */
+	      h->root.u.def.value = sym->st_value;
+	      h->root.u.def.section = sec;
+	    }
+	  defined_local = TRUE;
+	  resolved_local = TRUE;
+	  resolved_dynly = FALSE;
+	  resolved_to_const = FALSE;
+	}
+      else
+	{
+	  bfd_boolean warned, ignored;
+
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, sym_hashes,
+				   h, sec, relocation,
+				   unresolved_reloc, warned, ignored);
+	  /* here means symbol isn't local symbol only and 'h != NULL' */
+
+	  /* 'unresolved_syms_in_objects' specify how to deal with undefined
+	     symbol. And 'dynamic_undefined_weak' specify what to do when
+	     meeting undefweak.  */
+
+	  if ((is_undefweak = h->root.type == bfd_link_hash_undefweak))
+	    {
+	      defined_local = FALSE;
+	      resolved_local = FALSE;
+	      resolved_to_const = !is_dyn || h->dynindx == -1
+				|| UNDEFWEAK_NO_DYNAMIC_RELOC (info, h);
+	      resolved_dynly = !resolved_local && !resolved_to_const;
+	    }
+	  else if (warned)
+	    {
+	      /* Symbol undefined offen means failed already. I don't know why
+		 'warned' here but I guess it want to continue relocating as if
+		 no error occures to find other errors as more as possible. */
+
+	      /* To avoid generating warning messages about truncated
+		 relocations, set the relocation's address to be the same as
+		 the start of this section.  */
+	      relocation = input_section->output_section
+			 ? input_section->output_section->vma : 0;
+
+	      defined_local = relocation != 0;
+	      resolved_local = defined_local;
+	      resolved_to_const = !resolved_local;
+	      resolved_dynly = FALSE;
+	    }
+	  else
+	    {
+	      defined_local = !unresolved_reloc && !ignored;
+	      resolved_local =
+		defined_local && SYMBOL_REFERENCES_LOCAL (info, h);
+	      resolved_dynly = !resolved_local;
+	      resolved_to_const = !resolved_local && !resolved_dynly;
+	    }
+	}
+
+      name = loongarch_sym_name (input_bfd, h, sym);
+
+      if (sec != NULL && discarded_section (sec))
+	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+					 rel, 1, relend, howto, 0, contents);
+
+      if (bfd_link_relocatable (info))
+	continue;
+
+      /* r_symndx will be STN_UNDEF (zero) only for relocs against symbols
+	 from removed linkonce sections, or sections discarded by a linker
+	 script. Also for R_*_SOP_PUSH_ABSOLUTE and PCREL to specify const.  */
+      if (r_symndx == STN_UNDEF || bfd_is_abs_section (sec))
+	resolved_dynly = resolved_local = defined_local = FALSE
+	  , resolved_to_const = TRUE;
+
+      if (h && h->type == STT_GNU_IFUNC)
+	{
+	  /* a. 动态连接器可以直接处理STT_GNU_IFUNC，因为动态连接器可以察觉到
+	     一个动态符号是STT_GNU_IFUNC，从而在装载时执行resolver；
+	     但local符号不行，因为根本没有动态符号，所以要将R_LARCH_64转化为
+	     R_LARCH_IRELATIVE，类似的，所有其他重定位类型可能都要针对IFUNC
+	     做一些特殊操作，我觉得有点麻烦了。
+	     b. 此外，比如代码段的重定位无法动态改变其的引用位置，所以必须走plt
+	     来实现IFUNC。
+	     c. 因此，为方便实现，我们将plt stub的位置当作IFUNC符号的定义。 */
+	  if (h->plt.offset == MINUS_ONE)
+	    info->callbacks->info
+	      ("%X%pB(%pA+0x%v): error: %s against `%s':\n"
+	       "STT_GNU_IFUNC must have PLT stub" "\n",
+	       input_bfd, input_section, (bfd_vma) rel->r_offset,
+	       howto->name, name);
+	  defined_local = TRUE;
+	  resolved_local = TRUE;
+	  resolved_dynly = FALSE;
+	  resolved_to_const = FALSE;
+	  relocation = sec_addr (plt) + h->plt.offset;
+	}
+
+      unresolved_reloc = resolved_dynly;
+
+      BFD_ASSERT (resolved_local + resolved_dynly + resolved_to_const == 1);
+
+      /* a. 命题 'resolved_dynly' ==> 'h && h->dynindx != -1' 成立。
+	 b. 需要动态重定位一个符号当然需要动态符号表。这个断言失败意味着某个
+	 动态符号没有执行bfd_elf_link_record_dynamic_symbol。之前的逻辑有问题
+	 c. 另外，即使resolved_dynly为真，也不一定真的生成动态重定位表项，因为
+	 有时section没有SEC_ALLOC这个flag，当段不需要被加载进内存自然不需要动态
+	 重定位。 */
+      BFD_ASSERT (!resolved_dynly || (h && h->dynindx != -1));
+
+      BFD_ASSERT (!resolved_local || defined_local);
+
+      is_ie = FALSE;
+      switch (r_type)
+	{
+#define LARCH_ASSERT(cond, bfd_fail_state, message)			\
+  ({if (!(cond)) {							\
+    r = bfd_fail_state;							\
+    switch (r) {							\
+    /* 'dangerous' means we do it but can't promise it's ok		\
+       'unsupport' means out of ability of relocation type		\
+       'undefined' means we can't deal with the undefined symbol  */	\
+    case bfd_reloc_undefined:						\
+      info->callbacks->undefined_symbol					\
+	(info, name, input_bfd, input_section, rel->r_offset, TRUE);	\
+    default:								\
+      fatal = TRUE;							\
+      info->callbacks->info						\
+	("%X%pB(%pA+0x%v): error: %s against %s`%s':\n"			\
+	 message "\n",							\
+	 input_bfd, input_section, (bfd_vma) rel->r_offset,		\
+	 howto->name, is_undefweak? "[undefweak] " : "", name);		\
+      break;								\
+    case bfd_reloc_dangerous:						\
+      info->callbacks->info						\
+	("%pB(%pA+0x%v): warning: %s against %s`%s':\n"			\
+	 message "\n",							\
+	 input_bfd, input_section, (bfd_vma) rel->r_offset,		\
+	 howto->name, is_undefweak? "[undefweak] " : "", name);		\
+      break;								\
+    case bfd_reloc_ok:							\
+    case bfd_reloc_continue:						\
+      info->callbacks->info						\
+	("%pB(%pA+0x%v): message: %s against %s`%s':\n"			\
+	 message "\n",							\
+	 input_bfd, input_section, (bfd_vma) rel->r_offset,		\
+	 howto->name, is_undefweak? "[undefweak] " : "", name);		\
+      break;								\
+    }									\
+    if (fatal) break;							\
+  }})
+	case R_LARCH_MARK_PCREL:
+	case R_LARCH_MARK_LA:
+	case R_LARCH_NONE:
+	  r = bfd_reloc_continue;
+	  unresolved_reloc = FALSE;
+	  break;
+
+	case R_LARCH_32:
+	case R_LARCH_64:
+	  if (resolved_dynly || (is_pic && resolved_local))
+	    {
+	      Elf_Internal_Rela outrel;
+
+	      /* When generating a shared object, these relocations are copied
+		 into the output file to be resolved at run time.  */
+
+	      outrel.r_offset =
+		_bfd_elf_section_offset (output_bfd, info, input_section,
+					 rel->r_offset);
+
+	      unresolved_reloc = !((bfd_vma) -2 <= outrel.r_offset)
+			       && (input_section->flags & SEC_ALLOC);
+
+	      outrel.r_offset += sec_addr (input_section);
+	      if (resolved_dynly)
+		{
+		  outrel.r_info = ELFNN_R_INFO (h->dynindx, r_type);
+		  outrel.r_addend = rel->r_addend;
+		}
+	      else
+		{
+		  outrel.r_info = ELFNN_R_INFO (0, R_LARCH_RELATIVE);
+		  outrel.r_addend = relocation + rel->r_addend;
+		}
+
+	      if (unresolved_reloc)
+		loongarch_elf_append_rela (output_bfd, sreloc, &outrel);
+	    }
+
+	  relocation += rel->r_addend;
+	  break;
+
+	case R_LARCH_ADD8:
+	case R_LARCH_ADD16:
+	case R_LARCH_ADD24:
+	case R_LARCH_ADD32:
+	case R_LARCH_ADD64:
+	case R_LARCH_SUB8:
+	case R_LARCH_SUB16:
+	case R_LARCH_SUB24:
+	case R_LARCH_SUB32:
+	case R_LARCH_SUB64:
+	  LARCH_ASSERT (!resolved_dynly, bfd_reloc_undefined,
+"Can't be resolved dynamically. If this procedure is hand-writing assemble,\n"
+"there must be something like '.dword sym1 - sym2' to generate these relocs\n"
+"and we can't get known link-time address of these symbols.");
+	  relocation += rel->r_addend;
+	  break;
+
+	case R_LARCH_TLS_DTPREL32:
+	case R_LARCH_TLS_DTPREL64:
+	  if (resolved_dynly)
+	    {
+	      Elf_Internal_Rela outrel;
+
+	      outrel.r_offset =
+		_bfd_elf_section_offset (output_bfd, info, input_section,
+					 rel->r_offset);
+
+	      unresolved_reloc = !((bfd_vma) -2 <= outrel.r_offset)
+			       && (input_section->flags & SEC_ALLOC);
+	      outrel.r_info = ELFNN_R_INFO (h->dynindx, r_type);
+	      outrel.r_offset += sec_addr (input_section);
+	      outrel.r_addend = rel->r_addend;
+	      if (unresolved_reloc)
+		loongarch_elf_append_rela (output_bfd, sreloc, &outrel);
+	      break;
+	    }
+
+	  LARCH_ASSERT (!resolved_to_const, bfd_reloc_notsupported,
+	    "Internal:");
+
+	case R_LARCH_SOP_PUSH_TLS_TPREL:
+	  if (resolved_local)
+	    {
+	      LARCH_ASSERT (elf_hash_table (info)->tls_sec,
+		bfd_reloc_notsupported, "TLS section not be created");
+	      relocation -= elf_hash_table (info)->tls_sec->vma;
+	    }
+
+	  LARCH_ASSERT (resolved_local, bfd_reloc_undefined,
+	    "TLS LE just can be resolved local only.");
+	  break;
+
+	case R_LARCH_SOP_PUSH_ABSOLUTE:
+	  if (is_undefweak)
+	    {
+	      LARCH_ASSERT (!resolved_dynly, bfd_reloc_dangerous,
+"Someone require us to resolve undefweak symbol dynamically.\n"
+"But this reloc can't be done. I think I can't throw error for this\n"
+"so I resolved it to 0. I suggest to re-compile with '-fpic'.");
+	      relocation = 0;
+	      unresolved_reloc = FALSE;
+	      break;
+	    }
+
+	  if (resolved_to_const)
+	    {
+	      relocation += rel->r_addend;
+	      break;
+	    }
+
+	  LARCH_ASSERT (!is_pic, bfd_reloc_notsupported,
+"Under PIC we don't know load address. Re-compile src with '-fpic'?");
+
+	  if (resolved_dynly)
+	    {
+	      LARCH_ASSERT (plt && h && h->plt.offset != MINUS_ONE,
+			   bfd_reloc_undefined,
+"Can't be resolved dynamically. Try to re-compile src with '-fpic'?");
+
+	      LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
+		"Shouldn't be with r_addend.");
+
+	      relocation = sec_addr (plt) + h->plt.offset;
+	      unresolved_reloc = FALSE;
+	      break;
+	    }
+
+	  if (resolved_local)
+	    {
+	      relocation += rel->r_addend;
+	      break;
+	    }
+
+	  break;
+
+	case R_LARCH_SOP_PUSH_PCREL:
+	case R_LARCH_SOP_PUSH_PLT_PCREL:
+	  unresolved_reloc = FALSE;
+
+	  if (resolved_to_const)
+	    {
+	      relocation += rel->r_addend;
+	      break;
+	    }
+	  else if (is_undefweak)
+	    {
+	      i = 0, j = 0;
+	      relocation = 0;
+	      if (resolved_dynly)
+		{
+		  if (h && h->plt.offset != MINUS_ONE)
+		    i = 1, j = 2;
+		  else
+		    LARCH_ASSERT (0, bfd_reloc_dangerous,
+"Undefweak need to be resolved dynamically, but PLT stub doesn't represent.");
+		}
+	    }
+	  else
+	    {
+	      LARCH_ASSERT
+		(defined_local || (h && h->plt.offset != MINUS_ONE),
+		 bfd_reloc_undefined,
+		 "PLT stub does not represent and symbol not defined.");
+
+	      if (resolved_local)
+		i = 0, j = 2;
+	      else /* if (resolved_dynly) */
+		{
+		  LARCH_ASSERT
+		    (h && h->plt.offset != MINUS_ONE, bfd_reloc_dangerous,
+"Internal: PLT stub doesn't represent. Resolve it with pcrel");
+		  i = 1, j = 3;
+		}
+	    }
+
+	  for (; i < j; i++)
+	    {
+	      if ((i & 1) == 0 && defined_local)
+		{
+		  relocation -= pc;
+		  relocation += rel->r_addend;
+		  break;
+		}
+
+	      if ((i & 1) && h && h->plt.offset != MINUS_ONE)
+		{
+		  LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
+			       "PLT shouldn't be with r_addend.");
+		  relocation = sec_addr (plt) + h->plt.offset - pc;
+		  break;
+		}
+	    }
+	  break;
+
+	case R_LARCH_SOP_PUSH_GPREL:
+	  unresolved_reloc = FALSE;
+
+	  LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
+	    "Shouldn't be with r_addend.");
+
+	  /* 约定在GOT表中写入连接时地址。动态连接器通过_GLOBAL_OFFSET_TABLE_的
+	     连接时地址和运行时地址拿到模块的加载地址，拿到连接时地址的办法就是
+	     拿到那个got entry。一些体系结构通过.dynamic的段基址拿到模块加载
+	     地址，我没有这么做，因为这个段在static-pie下不存在。 */
+
+	  if (h != NULL)
+	    {
+	      off = h->got.offset;
+
+	      LARCH_ASSERT (off != MINUS_ONE, bfd_reloc_notsupported,
+		"Internal: GOT entry doesn't represent.");
+
+	      if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (is_dyn, is_pic, h)
+		  || (is_pic && SYMBOL_REFERENCES_LOCAL (info, h)))
+		{
+		  /* This is actually a static link, or it is a
+		     -Bsymbolic link and the symbol is defined
+		     locally, or the symbol was forced to be local
+		     because of a version file.  We must initialize
+		     this entry in the global offset table.  Since the
+		     offset must always be a multiple of the word size,
+		     we use the least significant bit to record whether
+		     we have initialized it already.
+
+		     When doing a dynamic link, we create a .rela.got
+		     relocation entry to initialize the value.  This
+		     is done in the finish_dynamic_symbol routine.  */
+
+		  /* 在这里先不用管STT_GNU_IFUNC。elf_finish_dynamic_symbol
+		     会单独处理。 */
+
+		  LARCH_ASSERT (!resolved_dynly, bfd_reloc_dangerous,
+		    "Internal: here shouldn't dynamic.");
+		  LARCH_ASSERT (defined_local || resolved_to_const,
+		    bfd_reloc_undefined, "Internal: ");
+
+		  if ((off & 1) != 0)
+		    off &= ~1;
+		  else
+		    {
+		      bfd_put_NN (output_bfd, relocation, got->contents + off);
+		      h->got.offset |= 1;
+		    }
+		}
+	    }
+	  else
+	    {
+	      LARCH_ASSERT (local_got_offsets, bfd_reloc_notsupported,
+		"Internal: local got offsets not reporesent.");
+
+	      off = local_got_offsets[r_symndx];
+
+	      LARCH_ASSERT (off != MINUS_ONE, bfd_reloc_notsupported,
+		"Internal: GOT entry doesn't represent.");
+
+	      /* The offset must always be a multiple of the word size.
+		 So, we can use the least significant bit to record
+		 whether we have already processed this entry.  */
+	      if ((off & 1) != 0)
+		off &= ~1;
+	      else
+		{
+		  if (is_pic)
+		    {
+		      asection *s;
+		      Elf_Internal_Rela outrel;
+		      /* We need to generate a R_LARCH_RELATIVE reloc
+			 for the dynamic linker.  */
+		      s = htab->elf.srelgot;
+		      LARCH_ASSERT (s, bfd_reloc_notsupported,
+			"Internal: '.rel.got' not represent");
+
+		      outrel.r_offset = sec_addr (got) + off;
+		      outrel.r_info = ELFNN_R_INFO (0, R_LARCH_RELATIVE);
+		      outrel.r_addend = relocation; /* link-time addr */
+		      loongarch_elf_append_rela (output_bfd, s, &outrel);
+		    }
+
+		  bfd_put_NN (output_bfd, relocation, got->contents + off);
+		  local_got_offsets[r_symndx] |= 1;
+		}
+	    }
+	  relocation = off;
+	  break;
+
+	case R_LARCH_SOP_PUSH_TLS_GOT:
+	  is_ie = TRUE;
+	case R_LARCH_SOP_PUSH_TLS_GD:
+	  unresolved_reloc = FALSE;
+
+	  LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
+	    "Shouldn't be with r_addend.");
+
+	  if (resolved_to_const && is_undefweak && h->dynindx != -1)
+	    {
+	      /* What if undefweak? Let rtld make a decision. */
+	      resolved_to_const = resolved_local = FALSE;
+	      resolved_dynly = TRUE;
+	    }
+
+	  LARCH_ASSERT (!resolved_to_const, bfd_reloc_notsupported,
+	    "Internal: Shouldn't be resolved to const.");
+
+	  if (h != NULL)
+	    {
+	      off = h->got.offset;
+	      h->got.offset |= 1;
+	    }
+	  else
+	    {
+	      off = local_got_offsets[r_symndx];
+	      local_got_offsets[r_symndx] |= 1;
+	    }
+
+	  LARCH_ASSERT (off != MINUS_ONE, bfd_reloc_notsupported,
+	    "Internal: TLS GOT entry doesn't represent.");
+
+	  tls_type = _bfd_loongarch_elf_tls_type (input_bfd, h, r_symndx);
+
+	  /* If this symbol is referenced by both GD and IE TLS, the IE
+	     reference's GOT slot follows the GD reference's slots.  */
+	  ie_off = 0;
+	  if ((tls_type & GOT_TLS_GD) && (tls_type & GOT_TLS_IE))
+	    ie_off = 2 * GOT_ENTRY_SIZE;
+
+	  if ((off & 1) != 0)
+	    off &= ~1;
+	  else
+	    {
+	      bfd_vma tls_block_off = 0;
+	      Elf_Internal_Rela outrel;
+
+	      if (resolved_local)
+		{
+		  LARCH_ASSERT
+		    (elf_hash_table (info)->tls_sec, bfd_reloc_notsupported,
+		     "Internal: TLS sec not represent.");
+		  tls_block_off = relocation
+				- elf_hash_table (info)->tls_sec->vma;
+		}
+
+	      if (tls_type & GOT_TLS_GD)
+		{
+		  outrel.r_offset = sec_addr (got) + off;
+		  outrel.r_addend = 0;
+		  bfd_put_NN (output_bfd, 0, got->contents + off);
+		  if (resolved_local && bfd_link_executable (info))
+		    /* a. 第一个被装载模块的Module ID为1。$glibc/elf/rtld.c中
+		       的dl_main有一句'main_map->l_tls_modid = 1'；
+		       b. 静态程序的Module ID不重要，但为了省事仍然是1。
+		       详见$glibc/csu/libc-tls.c中的init_static_tls。 */
+		    bfd_put_NN (output_bfd, 1, got->contents + off);
+		  else if (resolved_local/* && !bfd_link_executable (info) */)
+		    {
+		      outrel.r_info = ELFNN_R_INFO (0, R_LARCH_TLS_DTPMODNN);
+		      loongarch_elf_append_rela
+			(output_bfd, htab->elf.srelgot, &outrel);
+		    }
+		  else /* if (resolved_dynly) */
+		    {
+		      outrel.r_info =
+			ELFNN_R_INFO (h->dynindx, R_LARCH_TLS_DTPMODNN);
+		      loongarch_elf_append_rela
+			(output_bfd, htab->elf.srelgot, &outrel);
+		    }
+
+		  outrel.r_offset += GOT_ENTRY_SIZE;
+		  bfd_put_NN (output_bfd, tls_block_off,
+			      got->contents + off + GOT_ENTRY_SIZE);
+		  if (resolved_local)
+		    /* DTPREL known */;
+		  else /* if (resolved_dynly) */
+		    {
+		      outrel.r_info =
+			ELFNN_R_INFO (h->dynindx, R_LARCH_TLS_DTPRELNN);
+		      loongarch_elf_append_rela
+			(output_bfd, htab->elf.srelgot, &outrel);
+		    }
+		}
+
+	      if (tls_type & GOT_TLS_IE)
+		{
+		  outrel.r_offset = sec_addr (got) + off + ie_off;
+		  bfd_put_NN (output_bfd, tls_block_off,
+			      got->contents + off + ie_off);
+		  if (resolved_local && bfd_link_executable (info))
+		    /* TPREL known */;
+		  else if (resolved_local/* && !bfd_link_executable (info) */)
+		    {
+		      outrel.r_info = ELFNN_R_INFO (0, R_LARCH_TLS_TPRELNN);
+		      outrel.r_addend = tls_block_off;
+		      loongarch_elf_append_rela
+			(output_bfd, htab->elf.srelgot, &outrel);
+		    }
+		  else /* if (resolved_dynly) */
+		    {
+		      outrel.r_info =
+			ELFNN_R_INFO (h->dynindx, R_LARCH_TLS_TPRELNN);
+		      outrel.r_addend = 0;
+		      loongarch_elf_append_rela
+			(output_bfd, htab->elf.srelgot, &outrel);
+		    }
+		}
+	    }
+
+	  relocation = off + (is_ie ? ie_off : 0);
+	  break;
+
+	default:
+	  break;
+	}
+
+      if (fatal)
+	break;
+
+      do
+	{
+	  /* 'unresolved_reloc' means we haven't done it yet.
+	     We need help of dynamic linker to fix this memory location up. */
+	  if (!unresolved_reloc)
+	    break;
+
+	  if (_bfd_elf_section_offset (output_bfd, info, input_section,
+				       rel->r_offset) == MINUS_ONE)
+	    /* WHY? May because it's invalid so skip checking.
+	       But why dynamic reloc a invalid section? */
+	    break;
+
+	  if (input_section->output_section->flags & SEC_DEBUGGING)
+	    {
+	      LARCH_ASSERT  (0, bfd_reloc_dangerous,
+		"Seems dynamic linker not process sections 'SEC_DEBUGGING'.");
+	      break;
+	    }
+	  if (!is_dyn)
+	    break;
+
+	  if ((info->flags & DF_TEXTREL) == 0)
+	    if (input_section->output_section->flags & SEC_READONLY)
+	      info->flags |= DF_TEXTREL;
+	}
+      while (0);
+#undef LARCH_ASSERT
+
+      if (fatal)
+	break;
+
+      loongarch_record_one_reloc (input_bfd, input_section, r_type,
+				  rel->r_offset, sym, h, rel->r_addend);
+
+      if (r != bfd_reloc_continue)
+	r = perform_relocation (rel, relocation, input_bfd, contents);
+
+      switch (r)
+	{
+	case bfd_reloc_dangerous:
+	case bfd_reloc_continue:
+	case bfd_reloc_ok:
+	  continue;
+
+	case bfd_reloc_overflow:
+	  /* Overflow value can't be filled in */
+	  loongarch_dump_reloc_record (info->callbacks->info);
+	  info->callbacks->reloc_overflow
+	    (info, (h ? &h->root : NULL), name, howto->name,
+	     rel->r_addend, input_bfd, input_section, rel->r_offset);
+	  break;
+
+	case bfd_reloc_outofrange:
+	  /* Stack state incorrect */
+	  loongarch_dump_reloc_record (info->callbacks->info);
+	  info->callbacks->info
+	    ("%X%H: Internal stack state is incorrect.\n"
+	     "Want to push to full stack or pop from empty stack?\n",
+	     input_bfd, input_section, rel->r_offset);
+	  break;
+
+	case bfd_reloc_notsupported:
+	  info->callbacks->info
+	    ("%X%H: Unknown relocation type.\n",
+	     input_bfd, input_section, rel->r_offset);
+	  break;
+
+	default:
+	  info->callbacks->info
+	    ("%X%H: Internal: unknown error.\n",
+	     input_bfd, input_section, rel->r_offset);
+	  break;
+	}
+
+      fatal = TRUE;
+      break;
+    }
+
+  return !fatal;
+}
+
+/* Finish up dynamic symbol handling.  We set the contents of various
+   dynamic sections here.  */
+
+static bfd_boolean
+loongarch_elf_finish_dynamic_symbol (bfd *output_bfd,
+				     struct bfd_link_info *info,
+				     struct elf_link_hash_entry *h,
+				     Elf_Internal_Sym *sym)
+{
+  struct loongarch_elf_link_hash_table *htab = loongarch_elf_hash_table (info);
+  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
+  asection *plt = NULL;
+
+  if (h->plt.offset != MINUS_ONE)
+    {
+      size_t i, plt_idx;
+      asection *gotplt, *relplt;
+      bfd_vma got_address;
+      uint32_t plt_entry[PLT_ENTRY_INSNS];
+      bfd_byte *loc;
+      Elf_Internal_Rela rela;
+
+      plt_idx = (h->plt.offset - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
+
+      /* one of '.plt' and '.iplt' represents */
+      BFD_ASSERT (!!htab->elf.splt ^ !!htab->elf.iplt);
+
+      if (htab->elf.splt)
+	{
+	  BFD_ASSERT ((h->type == STT_GNU_IFUNC
+		       && SYMBOL_REFERENCES_LOCAL (info, h))
+		      || h->dynindx != -1);
+
+	  plt = htab->elf.splt;
+	  gotplt = htab->elf.sgotplt;
+	  relplt = htab->elf.srelplt;
+	  got_address = sec_addr (gotplt) + GOTPLT_HEADER_SIZE
+		      + plt_idx * GOT_ENTRY_SIZE;
+	}
+      else /* if (htab->elf.iplt) */
+	{
+	  BFD_ASSERT (h->type == STT_GNU_IFUNC
+		      && SYMBOL_REFERENCES_LOCAL (info, h));
+
+	  plt = htab->elf.iplt;
+	  gotplt = htab->elf.igotplt;
+	  relplt = htab->elf.irelplt;
+	  got_address = sec_addr (gotplt)
+		      + plt_idx * GOT_ENTRY_SIZE;
+	}
+
+      /* Find out where the .plt entry should go.  */
+      loc = plt->contents + h->plt.offset;
+
+      /* Fill in the PLT entry itself.  */
+      loongarch_make_plt_entry
+	(got_address, sec_addr (plt) + h->plt.offset, plt_entry);
+      for (i = 0; i < PLT_ENTRY_INSNS; i++)
+	bfd_put_32 (output_bfd, plt_entry[i], loc + 4 * i);
+
+      /* Fill in the initial value of the .got.plt entry.  */
+      loc = gotplt->contents + (got_address - sec_addr (gotplt));
+      bfd_put_NN (output_bfd, sec_addr (plt), loc);
+
+      rela.r_offset = got_address;
+      if (h->type == STT_GNU_IFUNC && SYMBOL_REFERENCES_LOCAL (info, h))
+	{
+	  rela.r_info = ELFNN_R_INFO (0, R_LARCH_IRELATIVE);
+	  rela.r_addend = h->root.u.def.value
+			+ h->root.u.def.section->output_section->vma
+			+ h->root.u.def.section->output_offset;
+	}
+      else
+	{
+	  /* Fill in the entry in the .rela.plt section.  */
+	  rela.r_info = ELFNN_R_INFO (h->dynindx, R_LARCH_JUMP_SLOT);
+	  rela.r_addend = 0;
+	}
+
+      loc = relplt->contents + plt_idx * sizeof (ElfNN_External_Rela);
+      bed->s->swap_reloca_out (output_bfd, &rela, loc);
+
+      if (!h->def_regular)
+	{
+	  /* Mark the symbol as undefined, rather than as defined in
+	     the .plt section.  Leave the value alone.  */
+	  sym->st_shndx = SHN_UNDEF;
+	  /* If the symbol is weak, we do need to clear the value.
+	     Otherwise, the PLT entry would provide a definition for
+	     the symbol even if the symbol wasn't defined anywhere,
+	     and so the symbol would never be NULL.  */
+	  if (!h->ref_regular_nonweak)
+	    sym->st_value = 0;
+	}
+    }
+
+  if (h->got.offset != MINUS_ONE
+
+      && /* TLS got entry have been handled in elf_relocate_section */
+	 !(loongarch_elf_hash_entry (h)->tls_type & (GOT_TLS_GD | GOT_TLS_IE))
+
+      && /* have allocated got entry but not allocated rela before */
+	 !UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))
+    {
+      asection *sgot, *srela;
+      Elf_Internal_Rela rela;
+      bfd_vma off = h->got.offset & ~(bfd_vma) 1;
+
+      /* This symbol has an entry in the GOT.  Set it up.  */
+
+      sgot = htab->elf.sgot;
+      srela = htab->elf.srelgot;
+      BFD_ASSERT (sgot && srela);
+
+      rela.r_offset = sec_addr (sgot) + off;
+
+      if (h->type == STT_GNU_IFUNC)
+	{
+	  if (/* 加入这个条件的原因是，对于静态链接，IRELATIVE重定位类型在
+		 __libc_start_main中调用apply_irel，通过链接脚本提供的
+		 __rela_iplt_start和__rela_iplt_end遍历.rela.iplt中的动态重定位
+		 表项，来调用各个resolver并将返回结果写入.igot.plt中。
+		 问题是照顾不到.rela.iplt之外的IRELATIVE重定位，因此我们在静态
+		 连接的情况下绝对不将IRELATIVE写入.igot.plt之外。这样做在运行时
+		 可能会有一些性能影响，毕竟ifunc函数都走plt，需要load两次
+		 got entry。没什么好的解决方法，未来可以搞.iplt2用于延迟调用
+		 resolver。 */
+	      elf_hash_table (info)->dynamic_sections_created
+	      
+	      && SYMBOL_REFERENCES_LOCAL (info, h))
+	    {
+	      asection *sec = h->root.u.def.section;
+	      rela.r_info = ELFNN_R_INFO (0, R_LARCH_IRELATIVE);
+	      rela.r_addend = h->root.u.def.value
+			    + sec->output_section->vma
+			    + sec->output_offset;
+	      bfd_put_NN (output_bfd, 0, sgot->contents + off);
+	    }
+	  else
+	    {
+	      BFD_ASSERT (plt);
+	      rela.r_info =
+		ELFNN_R_INFO
+		  (0, bfd_link_pic (info) ? R_LARCH_RELATIVE : R_LARCH_NONE);
+	      rela.r_addend = plt->output_section->vma
+			    + plt->output_offset
+			    + h->plt.offset;
+	      bfd_put_NN (output_bfd, rela.r_addend, sgot->contents + off);
+	    }
+	}
+      else if (bfd_link_pic (info) && SYMBOL_REFERENCES_LOCAL (info, h))
+	{
+	  BFD_ASSERT (h->got.offset & 1/* has been filled in addr */);
+	  asection *sec = h->root.u.def.section;
+	  rela.r_info = ELFNN_R_INFO (0, R_LARCH_RELATIVE);
+	  rela.r_addend = h->root.u.def.value
+			+ sec->output_section->vma
+			+ sec->output_offset;
+	}
+      else
+	{
+	  BFD_ASSERT ((h->got.offset & 1) == 0);
+	  BFD_ASSERT (h->dynindx != -1);
+	  rela.r_info = ELFNN_R_INFO (h->dynindx, R_LARCH_NN);
+	  rela.r_addend = 0;
+	}
+
+      loongarch_elf_append_rela (output_bfd, srela, &rela);
+    }
+
+  if (h->needs_copy)
+    {
+      Elf_Internal_Rela rela;
+      asection *s;
+
+      /* This symbols needs a copy reloc.  Set it up.  */
+      BFD_ASSERT (h->dynindx != -1);
+
+      rela.r_offset = sec_addr (h->root.u.def.section) + h->root.u.def.value;
+      rela.r_info = ELFNN_R_INFO (h->dynindx, R_LARCH_COPY);
+      rela.r_addend = 0;
+      if (h->root.u.def.section == htab->elf.sdynrelro)
+	s = htab->elf.sreldynrelro;
+      else
+	s = htab->elf.srelbss;
+      loongarch_elf_append_rela (output_bfd, s, &rela);
+    }
+
+  /* Mark some specially defined symbols as absolute.  */
+  if (h == htab->elf.hdynamic || h == htab->elf.hgot || h == htab->elf.hplt)
+    sym->st_shndx = SHN_ABS;
+
+  return TRUE;
+}
+
+/* Finish up the dynamic sections.  */
+
+static bfd_boolean
+loongarch_finish_dyn (bfd *output_bfd, struct bfd_link_info *info,
+		      bfd *dynobj, asection *sdyn)
+{
+  struct loongarch_elf_link_hash_table *htab = loongarch_elf_hash_table (info);
+  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
+  size_t dynsize = bed->s->sizeof_dyn, skipped_size = 0;
+  bfd_byte *dyncon, *dynconend;
+
+  dynconend = sdyn->contents + sdyn->size;
+  for (dyncon = sdyn->contents; dyncon < dynconend; dyncon += dynsize)
+    {
+      Elf_Internal_Dyn dyn;
+      asection *s;
+      int skipped = 0;
+
+      bed->s->swap_dyn_in (dynobj, dyncon, &dyn);
+
+      switch (dyn.d_tag)
+	{
+	case DT_PLTGOT:
+	  s = htab->elf.sgotplt;
+	  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	  break;
+	case DT_JMPREL:
+	  s = htab->elf.srelplt;
+	  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	  break;
+	case DT_PLTRELSZ:
+	  s = htab->elf.srelplt;
+	  dyn.d_un.d_val = s->size;
+	  break;
+	case DT_TEXTREL:
+	  if ((info->flags & DF_TEXTREL) == 0)
+	    skipped = 1;
+	  break;
+	case DT_FLAGS:
+	  if ((info->flags & DF_TEXTREL) == 0)
+	    dyn.d_un.d_val &= ~DF_TEXTREL;
+	  break;
+	}
+      if (skipped)
+	skipped_size += dynsize;
+      else
+	bed->s->swap_dyn_out (output_bfd, &dyn, dyncon - skipped_size);
+    }
+  /* Wipe out any trailing entries if we shifted down a dynamic tag.  */
+  memset (dyncon - skipped_size, 0, skipped_size);
+  return TRUE;
+}
+
+/* Finish up local dynamic symbol handling.  We set the contents of
+   various dynamic sections here.  */
+
+static bfd_boolean
+elfNN_loongarch_finish_local_dynamic_symbol (void **slot, void *inf)
+{
+  struct elf_link_hash_entry *h = (struct elf_link_hash_entry *) *slot;
+  struct bfd_link_info *info = (struct bfd_link_info *) inf;
+
+  return loongarch_elf_finish_dynamic_symbol (info->output_bfd, info, h, NULL);
+}
+
+static bfd_boolean
+loongarch_elf_finish_dynamic_sections (bfd *output_bfd,
+				       struct bfd_link_info *info)
+{
+  bfd *dynobj;
+  asection *sdyn, *plt, *gotplt;
+  struct loongarch_elf_link_hash_table *htab;
+
+  htab = loongarch_elf_hash_table (info);
+  BFD_ASSERT (htab);
+  dynobj = htab->elf.dynobj;
+  sdyn = bfd_get_linker_section (dynobj, ".dynamic");
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      BFD_ASSERT (htab->elf.splt && sdyn);
+
+      if (!loongarch_finish_dyn (output_bfd, info, dynobj, sdyn))
+	return FALSE;
+    }
+
+  if ((plt = htab->elf.splt))
+    gotplt = htab->elf.sgotplt;
+  else if ((plt = htab->elf.iplt))
+    gotplt = htab->elf.igotplt;
+
+  if (plt && 0 < plt->size)
+    {
+      size_t i;
+      uint32_t plt_header[PLT_HEADER_INSNS];
+      loongarch_make_plt_header (sec_addr (gotplt), sec_addr (plt), plt_header);
+      for (i = 0; i < PLT_HEADER_INSNS; i++)
+	bfd_put_32 (output_bfd, plt_header[i], plt->contents + 4 * i);
+
+      elf_section_data (plt->output_section)->this_hdr.sh_entsize
+	= PLT_ENTRY_SIZE;
+    }
+
+  if (htab->elf.sgotplt)
+    {
+      asection *output_section = htab->elf.sgotplt->output_section;
+
+      if (bfd_is_abs_section (output_section))
+	{
+	  _bfd_error_handler
+	    (_("discarded output section: `%pA'"), htab->elf.sgotplt);
+	  return FALSE;
+	}
+
+      if (0 < htab->elf.sgotplt->size)
+	{
+	  /* Write the first two entries in .got.plt, needed for the dynamic
+	     linker.  */
+	  bfd_put_NN (output_bfd, MINUS_ONE, htab->elf.sgotplt->contents);
+
+	  /* 第二项非0时动态连接器认为它是plt header的地址，从而影响到所有
+	     R_LARCH_JUMP_SLOT。这似乎是为了prelink预留的。 */
+	  bfd_put_NN (output_bfd, (bfd_vma) 0,
+		      htab->elf.sgotplt->contents + GOT_ENTRY_SIZE);
+	}
+
+      elf_section_data (output_section)->this_hdr.sh_entsize = GOT_ENTRY_SIZE;
+    }
+
+  if (htab->elf.sgot)
+    {
+      asection *output_section = htab->elf.sgot->output_section;
+
+      if (0 < htab->elf.sgot->size)
+	{
+	  /* Set the first entry in the global offset table to the address of
+	     the dynamic section.  */
+	  bfd_vma val = sdyn ? sec_addr (sdyn) : 0;
+	  bfd_put_NN (output_bfd, val, htab->elf.sgot->contents);
+	}
+
+      elf_section_data (output_section)->this_hdr.sh_entsize = GOT_ENTRY_SIZE;
+    }
+
+  /* Fill PLT and GOT entries for local STT_GNU_IFUNC symbols.  */
+  htab_traverse
+    (htab->loc_hash_table, elfNN_loongarch_finish_local_dynamic_symbol, info);
+
+  return TRUE;
+}
+
+/* Return address for Ith PLT stub in section PLT, for relocation REL
+   or (bfd_vma) -1 if it should not be included.  */
+
+static bfd_vma
+loongarch_elf_plt_sym_val (bfd_vma i, const asection *plt,
+		       const arelent *rel ATTRIBUTE_UNUSED)
+{
+  return plt->vma + PLT_HEADER_SIZE + i * PLT_ENTRY_SIZE;
+}
+
+static enum elf_reloc_type_class
+loongarch_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
+			    const asection *rel_sec ATTRIBUTE_UNUSED,
+			    const Elf_Internal_Rela *rela)
+{
+  struct loongarch_elf_link_hash_table *htab;
+  htab = loongarch_elf_hash_table (info);
+
+  if (htab->elf.dynsym != NULL
+      && htab->elf.dynsym->contents != NULL)
+    {
+      /* Check relocation against STT_GNU_IFUNC symbol if there are
+	 dynamic symbols.
+	 一定要保证先完成非IFUNC重定位。因为如果IFUNC的resolover尚未完成
+	 重定位，那么调用它返回的结果是错误的。非IFUNC重定位类型，比如R_LARCH_64
+	 也可以携带IFUNC符号信息。我们在elf_machine_rela中可以察觉到一个符号是
+	 IFUNC，而在动态重定位时调用resolver。但八成这个resolver也需要一个
+	 R_LARCH_64重定位，可能还未完成，这时就会出问题。
+	 在这里识别出来和STT_GNU_IFUNC相关的重定位，将他们往后排。 */
+      bfd *abfd = info->output_bfd;
+      const struct elf_backend_data *bed = get_elf_backend_data (abfd);
+      unsigned long r_symndx = ELFNN_R_SYM (rela->r_info);
+      if (r_symndx != STN_UNDEF)
+	{
+	  Elf_Internal_Sym sym;
+	  if (!bed->s->swap_symbol_in (abfd,
+		 htab->elf.dynsym->contents + r_symndx * bed->s->sizeof_sym,
+		 0, &sym))
+	    {
+	      /* xgettext:c-format */
+	      _bfd_error_handler (_("%pB symbol number %lu references"
+				    " nonexistent SHT_SYMTAB_SHNDX section"),
+				    abfd, r_symndx);
+	      /* Ideally an error class should be returned here.  */
+	    }
+	  else if (ELF_ST_TYPE (sym.st_info) == STT_GNU_IFUNC)
+	    return reloc_class_ifunc;
+	}
+    }
+
+  switch (ELFNN_R_TYPE (rela->r_info))
+    {
+    case R_LARCH_IRELATIVE:
+      return reloc_class_ifunc;
+    case R_LARCH_RELATIVE:
+      return reloc_class_relative;
+    case R_LARCH_JUMP_SLOT:
+      return reloc_class_plt;
+    case R_LARCH_COPY:
+      return reloc_class_copy;
+    default:
+      return reloc_class_normal;
+    }
+}
+
+
+/* Copy the extra info we tack onto an elf_link_hash_entry.  */
+
+static void
+loongarch_elf_copy_indirect_symbol (struct bfd_link_info *info,
+				    struct elf_link_hash_entry *dir,
+				    struct elf_link_hash_entry *ind)
+{
+  struct loongarch_elf_link_hash_entry *edir, *eind;
+
+  edir = (struct loongarch_elf_link_hash_entry *) dir;
+  eind = (struct loongarch_elf_link_hash_entry *) ind;
+
+  if (eind->dyn_relocs != NULL)
+    {
+      if (edir->dyn_relocs != NULL)
+	{
+	  struct elf_dyn_relocs **pp;
+	  struct elf_dyn_relocs *p;
+
+	  /* Add reloc counts against the indirect sym to the direct sym
+	     list.  Merge any entries against the same section.  */
+	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
+	    {
+	      struct elf_dyn_relocs *q;
+
+	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
+		if (q->sec == p->sec)
+		  {
+		    q->pc_count += p->pc_count;
+		    q->count += p->count;
+		    *pp = p->next;
+		    break;
+		  }
+	      if (q == NULL)
+		pp = &p->next;
+	    }
+	  *pp = edir->dyn_relocs;
+	}
+
+      edir->dyn_relocs = eind->dyn_relocs;
+      eind->dyn_relocs = NULL;
+    }
+
+  if (ind->root.type == bfd_link_hash_indirect
+      && dir->got.refcount < 0)
+    {
+      edir->tls_type = eind->tls_type;
+      eind->tls_type = GOT_UNKNOWN;
+    }
+  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
+}
+
+#if ARCH_SIZE == 32
+# define PRSTATUS_SIZE			0 /* FIXME */
+# define PRSTATUS_OFFSET_PR_CURSIG	0
+# define PRSTATUS_OFFSET_PR_PID		0
+# define PRSTATUS_OFFSET_PR_REG		0
+# define ELF_GREGSET_T_SIZE		264
+# define PRPSINFO_SIZE			0
+# define PRPSINFO_OFFSET_PR_PID		0
+# define PRPSINFO_OFFSET_PR_FNAME	0
+# define PRPSINFO_OFFSET_PR_PSARGS	0
+#else
+# define PRSTATUS_SIZE			384
+# define PRSTATUS_OFFSET_PR_CURSIG	12
+# define PRSTATUS_OFFSET_PR_PID		32
+# define PRSTATUS_OFFSET_PR_REG		112
+# define ELF_GREGSET_T_SIZE		264
+# define PRPSINFO_SIZE			144
+# define PRPSINFO_OFFSET_PR_PID		32
+# define PRPSINFO_OFFSET_PR_FNAME	48
+# define PRPSINFO_OFFSET_PR_PSARGS	64
+#endif
+
+/* Support for core dump NOTE sections.  */
+
+static bfd_boolean
+loongarch_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
+{
+  switch (note->descsz)
+    {
+    default:
+      return FALSE;
+
+    case PRSTATUS_SIZE:  /* sizeof(struct elf_prstatus) on Linux/Loongarch.  */
+      /* pr_cursig */
+      elf_tdata (abfd)->core->signal
+	= bfd_get_16 (abfd, note->descdata + PRSTATUS_OFFSET_PR_CURSIG);
+
+      /* pr_pid */
+      elf_tdata (abfd)->core->lwpid
+	= bfd_get_32 (abfd, note->descdata + PRSTATUS_OFFSET_PR_PID);
+      break;
+    }
+
+  /* Make a ".reg/999" section.  */
+  return _bfd_elfcore_make_pseudosection (abfd, ".reg", ELF_GREGSET_T_SIZE,
+					  note->descpos + PRSTATUS_OFFSET_PR_REG);
+}
+
+static bfd_boolean
+loongarch_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
+{
+  switch (note->descsz)
+    {
+    default:
+      return FALSE;
+
+    case PRPSINFO_SIZE: /* sizeof(struct elf_prpsinfo) on Linux/Loongarch.  */
+      /* pr_pid */
+      elf_tdata (abfd)->core->pid
+	= bfd_get_32 (abfd, note->descdata + PRPSINFO_OFFSET_PR_PID);
+
+      /* pr_fname */
+      elf_tdata (abfd)->core->program = _bfd_elfcore_strndup
+	(abfd, note->descdata + PRPSINFO_OFFSET_PR_FNAME, 16);
+
+      /* pr_psargs */
+      elf_tdata (abfd)->core->command = _bfd_elfcore_strndup
+	(abfd, note->descdata + PRPSINFO_OFFSET_PR_PSARGS, 80);
+      break;
+    }
+
+  /* Note that for some reason, a spurious space is tacked
+     onto the end of the args in some (at least one anyway)
+     implementations, so strip it off if it exists.  */
+
+    {
+      char *command = elf_tdata (abfd)->core->command;
+      int n = strlen (command);
+
+      if (0 < n && command[n - 1] == ' ')
+	command[n - 1] = '\0';
+    }
+
+  return TRUE;
+}
+
+/* Set the right mach type.  */
+static bfd_boolean
+loongarch_elf_object_p (bfd *abfd)
+{
+  /* There are only two mach types in Loongarch currently.  */
+  if (strcmp (abfd->xvec->name, "elf64-loongarch") == 0)
+    bfd_default_set_arch_mach (abfd, bfd_arch_loongarch, bfd_mach_loongarch64);
+  else
+    bfd_default_set_arch_mach (abfd, bfd_arch_loongarch, bfd_mach_loongarch32);
+  return TRUE;
+}
+
+static asection *
+loongarch_elf_gc_mark_hook (asection *sec,
+			    struct bfd_link_info *info,
+			    Elf_Internal_Rela *rel,
+			    struct elf_link_hash_entry *h,
+			    Elf_Internal_Sym *sym)
+{
+  if (h != NULL)
+    switch (ELFNN_R_TYPE (rel->r_info))
+      {
+      case R_LARCH_GNU_VTINHERIT:
+      case R_LARCH_GNU_VTENTRY:
+	return NULL;
+      }
+
+  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
+}
+
+#define TARGET_LITTLE_SYM		loongarch_elfNN_vec
+#define TARGET_LITTLE_NAME		"elfNN-loongarch"
+#define ELF_ARCH			bfd_arch_loongarch
+#define ELF_TARGET_ID			LARCH_ELF_DATA
+#define ELF_MACHINE_CODE		EM_LOONGARCH
+#define ELF_MAXPAGESIZE			0x4000
+#define bfd_elfNN_bfd_reloc_type_lookup loongarch_reloc_type_lookup
+#define bfd_elfNN_bfd_link_hash_table_create loongarch_elf_link_hash_table_create
+#define bfd_elfNN_bfd_reloc_name_lookup loongarch_reloc_name_lookup
+#define elf_info_to_howto_rel		NULL /* fall through to elf_info_to_howto */
+#define elf_info_to_howto		loongarch_info_to_howto_rela
+#define bfd_elfNN_bfd_merge_private_bfd_data \
+  _bfd_loongarch_elf_merge_private_bfd_data
+
+#define elf_backend_reloc_type_class	     loongarch_reloc_type_class
+#define elf_backend_copy_indirect_symbol     loongarch_elf_copy_indirect_symbol
+#define elf_backend_create_dynamic_sections  loongarch_elf_create_dynamic_sections
+#define elf_backend_check_relocs	     loongarch_elf_check_relocs
+#define elf_backend_adjust_dynamic_symbol    loongarch_elf_adjust_dynamic_symbol
+#define elf_backend_size_dynamic_sections    loongarch_elf_size_dynamic_sections
+#define elf_backend_relocate_section	     loongarch_elf_relocate_section
+#define elf_backend_finish_dynamic_symbol    loongarch_elf_finish_dynamic_symbol
+#define elf_backend_finish_dynamic_sections  loongarch_elf_finish_dynamic_sections
+#define elf_backend_object_p		     loongarch_elf_object_p
+#define elf_backend_gc_mark_hook	     loongarch_elf_gc_mark_hook
+#define elf_backend_plt_sym_val		     loongarch_elf_plt_sym_val
+#define elf_backend_grok_prstatus	     loongarch_elf_grok_prstatus
+#define elf_backend_grok_psinfo		     loongarch_elf_grok_psinfo
+
+#include "elfNN-target.h"
diff --git a/bfd/elfxx-loongarch.c b/bfd/elfxx-loongarch.c
new file mode 100644
index 00000000000..3f8534bf8fc
--- /dev/null
+++ b/bfd/elfxx-loongarch.c
@@ -0,0 +1,172 @@
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/loongarch.h"
+#include "elfxx-loongarch.h"
+
+
+
+/* This does not include any relocation information, but should be
+   good enough for GDB or objdump to read the file.  */
+
+static reloc_howto_type howto_table[] =
+{
+#define LOONGARCH_HOWTO(r_name) HOWTO (R_LARCH_##r_name,0,3,32,FALSE,0,complain_overflow_signed,bfd_elf_generic_reloc,"R_LARCH_"#r_name,FALSE,0,0,FALSE)
+LOONGARCH_HOWTO (NONE),
+LOONGARCH_HOWTO (32),
+LOONGARCH_HOWTO (64),
+LOONGARCH_HOWTO (RELATIVE),
+LOONGARCH_HOWTO (COPY),
+LOONGARCH_HOWTO (JUMP_SLOT),
+LOONGARCH_HOWTO (TLS_DTPMOD32),
+LOONGARCH_HOWTO (TLS_DTPMOD64),
+LOONGARCH_HOWTO (TLS_DTPREL32),
+LOONGARCH_HOWTO (TLS_DTPREL64),
+LOONGARCH_HOWTO (TLS_TPREL32),
+LOONGARCH_HOWTO (TLS_TPREL64),
+LOONGARCH_HOWTO (IRELATIVE),
+
+LOONGARCH_HOWTO (MARK_LA),
+LOONGARCH_HOWTO (MARK_PCREL),
+  HOWTO (R_LARCH_SOP_PUSH_PCREL,			/* type */
+	 2,				/* rightshift */
+	 3,				/* size */
+	 32,				/* bitsize */
+	 TRUE/* FIXME: somewhat use this */,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_signed,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_LARCH_SOP_PUSH_PCREL",		/* name */
+	 FALSE,				/* partial_inplace */
+	 0x03ffffff,				/* src_mask */
+	 0x03ffffff,				/* dst_mask */
+	 FALSE),			/* pcrel_offset */
+LOONGARCH_HOWTO (SOP_PUSH_ABSOLUTE),
+LOONGARCH_HOWTO (SOP_PUSH_DUP),
+LOONGARCH_HOWTO (SOP_PUSH_GPREL),
+LOONGARCH_HOWTO (SOP_PUSH_TLS_TPREL),
+LOONGARCH_HOWTO (SOP_PUSH_TLS_GOT),
+LOONGARCH_HOWTO (SOP_PUSH_TLS_GD),
+LOONGARCH_HOWTO (SOP_PUSH_PLT_PCREL),
+LOONGARCH_HOWTO (SOP_ASSERT),
+LOONGARCH_HOWTO (SOP_NOT),
+LOONGARCH_HOWTO (SOP_SUB),
+LOONGARCH_HOWTO (SOP_SL),
+LOONGARCH_HOWTO (SOP_SR),
+LOONGARCH_HOWTO (SOP_ADD),
+LOONGARCH_HOWTO (SOP_AND),
+LOONGARCH_HOWTO (SOP_IF_ELSE),
+LOONGARCH_HOWTO (SOP_POP_32_S_10_5),
+LOONGARCH_HOWTO (SOP_POP_32_U_10_12),
+LOONGARCH_HOWTO (SOP_POP_32_S_10_12),
+LOONGARCH_HOWTO (SOP_POP_32_S_10_16),
+LOONGARCH_HOWTO (SOP_POP_32_S_10_16_S2),
+LOONGARCH_HOWTO (SOP_POP_32_S_5_20),
+LOONGARCH_HOWTO (SOP_POP_32_S_0_5_10_16_S2),
+LOONGARCH_HOWTO (SOP_POP_32_S_0_10_10_16_S2),
+LOONGARCH_HOWTO (SOP_POP_32_U),
+LOONGARCH_HOWTO (ADD8),
+LOONGARCH_HOWTO (ADD16),
+LOONGARCH_HOWTO (ADD24),
+LOONGARCH_HOWTO (ADD32),
+LOONGARCH_HOWTO (ADD64),
+LOONGARCH_HOWTO (SUB8),
+LOONGARCH_HOWTO (SUB16),
+LOONGARCH_HOWTO (SUB24),
+LOONGARCH_HOWTO (SUB32),
+LOONGARCH_HOWTO (SUB64),
+};
+
+struct elf_reloc_map
+{
+  bfd_reloc_code_real_type bfd_val;
+  enum elf_loongarch_reloc_type elf_val;
+};
+
+static const struct elf_reloc_map loong_reloc_map[] =
+{
+    { BFD_RELOC_NONE, R_LARCH_NONE },
+    { BFD_RELOC_32, R_LARCH_32 },
+    { BFD_RELOC_64, R_LARCH_64 },
+
+#define LOONGARCH_reloc_map(r_name) {BFD_RELOC_LARCH_##r_name,R_LARCH_##r_name}
+LOONGARCH_reloc_map (TLS_DTPMOD32),
+LOONGARCH_reloc_map (TLS_DTPMOD64),
+LOONGARCH_reloc_map (TLS_DTPREL32),
+LOONGARCH_reloc_map (TLS_DTPREL64),
+LOONGARCH_reloc_map (TLS_TPREL32),
+LOONGARCH_reloc_map (TLS_TPREL64),
+
+LOONGARCH_reloc_map (MARK_LA),
+LOONGARCH_reloc_map (MARK_PCREL),
+LOONGARCH_reloc_map (SOP_PUSH_PCREL),
+LOONGARCH_reloc_map (SOP_PUSH_ABSOLUTE),
+LOONGARCH_reloc_map (SOP_PUSH_DUP),
+LOONGARCH_reloc_map (SOP_PUSH_GPREL),
+LOONGARCH_reloc_map (SOP_PUSH_TLS_TPREL),
+LOONGARCH_reloc_map (SOP_PUSH_TLS_GOT),
+LOONGARCH_reloc_map (SOP_PUSH_TLS_GD),
+LOONGARCH_reloc_map (SOP_PUSH_PLT_PCREL),
+LOONGARCH_reloc_map (SOP_ASSERT),
+LOONGARCH_reloc_map (SOP_NOT),
+LOONGARCH_reloc_map (SOP_SUB),
+LOONGARCH_reloc_map (SOP_SL),
+LOONGARCH_reloc_map (SOP_SR),
+LOONGARCH_reloc_map (SOP_ADD),
+LOONGARCH_reloc_map (SOP_AND),
+LOONGARCH_reloc_map (SOP_IF_ELSE),
+LOONGARCH_reloc_map (SOP_POP_32_S_10_5),
+LOONGARCH_reloc_map (SOP_POP_32_U_10_12),
+LOONGARCH_reloc_map (SOP_POP_32_S_10_12),
+LOONGARCH_reloc_map (SOP_POP_32_S_10_16),
+LOONGARCH_reloc_map (SOP_POP_32_S_10_16_S2),
+LOONGARCH_reloc_map (SOP_POP_32_S_5_20),
+LOONGARCH_reloc_map (SOP_POP_32_S_0_5_10_16_S2),
+LOONGARCH_reloc_map (SOP_POP_32_S_0_10_10_16_S2),
+LOONGARCH_reloc_map (SOP_POP_32_U),
+LOONGARCH_reloc_map (ADD8),
+LOONGARCH_reloc_map (ADD16),
+LOONGARCH_reloc_map (ADD24),
+LOONGARCH_reloc_map (ADD32),
+LOONGARCH_reloc_map (ADD64),
+LOONGARCH_reloc_map (SUB8),
+LOONGARCH_reloc_map (SUB16),
+LOONGARCH_reloc_map (SUB24),
+LOONGARCH_reloc_map (SUB32),
+LOONGARCH_reloc_map (SUB64),
+};
+
+reloc_howto_type *
+loongarch_elf_rtype_to_howto (unsigned int r_type)
+{
+  size_t i;
+  for (i = 0; i < ARRAY_SIZE (howto_table); i++)
+    if (howto_table[i].type == r_type)
+      return &howto_table[i];
+  return NULL;
+}
+
+reloc_howto_type *
+loongarch_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED, bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+  for (i = 0; i < ARRAY_SIZE (loong_reloc_map); i++)
+    if (loong_reloc_map[i].bfd_val == code)
+      return loongarch_elf_rtype_to_howto ((int) loong_reloc_map[i].elf_val);
+  //      return &howto_table[(int) loong_reloc_map[i].elf_val];
+
+  return NULL;
+}
+
+reloc_howto_type *
+loongarch_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED, const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0; i < ARRAY_SIZE (howto_table); i++)
+    if (howto_table[i].name && strcasecmp (howto_table[i].name, r_name) == 0)
+      return &howto_table[i];
+
+  return NULL;
+}
diff --git a/bfd/elfxx-loongarch.h b/bfd/elfxx-loongarch.h
new file mode 100644
index 00000000000..0e9808648d7
--- /dev/null
+++ b/bfd/elfxx-loongarch.h
@@ -0,0 +1,11 @@
+#include "elf/common.h"
+#include "elf/internal.h"
+
+extern reloc_howto_type *
+loongarch_elf_rtype_to_howto (unsigned int r_type);
+
+extern reloc_howto_type *
+loongarch_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code);
+
+extern reloc_howto_type *
+loongarch_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED, const char *r_name);
diff --git a/bfd/libbfd.h b/bfd/libbfd.h
index 7271a2ad5a1..5f37e34ed65 100644
--- a/bfd/libbfd.h
+++ b/bfd/libbfd.h
@@ -3396,6 +3396,49 @@ static const char *const bfd_reloc_code_real_names[] = { "@@uninitialized@@",
   "BFD_RELOC_CKCORE_PCREL_BLOOP_IMM4BY4",
   "BFD_RELOC_CKCORE_PCREL_BLOOP_IMM12BY4",
   "BFD_RELOC_S12Z_OPR",
+  "BFD_RELOC_LARCH_TLS_DTPMOD32",
+  "BFD_RELOC_LARCH_TLS_DTPREL32",
+  "BFD_RELOC_LARCH_TLS_DTPMOD64",
+  "BFD_RELOC_LARCH_TLS_DTPREL64",
+  "BFD_RELOC_LARCH_TLS_TPREL32",
+  "BFD_RELOC_LARCH_TLS_TPREL64",
+  "BFD_RELOC_LARCH_MARK_LA",
+  "BFD_RELOC_LARCH_MARK_PCREL",
+  "BFD_RELOC_LARCH_SOP_PUSH_PCREL",
+  "BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE",
+  "BFD_RELOC_LARCH_SOP_PUSH_DUP",
+  "BFD_RELOC_LARCH_SOP_PUSH_GPREL",
+  "BFD_RELOC_LARCH_SOP_PUSH_TLS_TPREL",
+  "BFD_RELOC_LARCH_SOP_PUSH_TLS_GOT",
+  "BFD_RELOC_LARCH_SOP_PUSH_TLS_GD",
+  "BFD_RELOC_LARCH_SOP_PUSH_PLT_PCREL",
+  "BFD_RELOC_LARCH_SOP_ASSERT",
+  "BFD_RELOC_LARCH_SOP_NOT",
+  "BFD_RELOC_LARCH_SOP_SUB",
+  "BFD_RELOC_LARCH_SOP_SL",
+  "BFD_RELOC_LARCH_SOP_SR",
+  "BFD_RELOC_LARCH_SOP_ADD",
+  "BFD_RELOC_LARCH_SOP_AND",
+  "BFD_RELOC_LARCH_SOP_IF_ELSE",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_10_5",
+  "BFD_RELOC_LARCH_SOP_POP_32_U_10_12",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_10_12",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_10_16",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_5_20",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2",
+  "BFD_RELOC_LARCH_SOP_POP_32_U",
+  "BFD_RELOC_LARCH_ADD8",
+  "BFD_RELOC_LARCH_ADD16",
+  "BFD_RELOC_LARCH_ADD24",
+  "BFD_RELOC_LARCH_ADD32",
+  "BFD_RELOC_LARCH_ADD64",
+  "BFD_RELOC_LARCH_SUB8",
+  "BFD_RELOC_LARCH_SUB16",
+  "BFD_RELOC_LARCH_SUB24",
+  "BFD_RELOC_LARCH_SUB32",
+  "BFD_RELOC_LARCH_SUB64",
  "@@overflow: BFD_RELOC_UNUSED@@",
 };
 #endif
diff --git a/bfd/reloc.c b/bfd/reloc.c
index 4f4b95a0b7f..7a65227bafe 100644
--- a/bfd/reloc.c
+++ b/bfd/reloc.c
@@ -8167,6 +8167,95 @@ ENUM
 ENUMDOC
   S12Z relocations.
 
+ENUM
+  BFD_RELOC_LARCH_TLS_DTPMOD32
+ENUMX
+  BFD_RELOC_LARCH_TLS_DTPREL32
+ENUMX
+  BFD_RELOC_LARCH_TLS_DTPMOD64
+ENUMX
+  BFD_RELOC_LARCH_TLS_DTPREL64
+ENUMX
+  BFD_RELOC_LARCH_TLS_TPREL32
+ENUMX
+  BFD_RELOC_LARCH_TLS_TPREL64
+ENUMX
+  BFD_RELOC_LARCH_MARK_LA
+ENUMX
+  BFD_RELOC_LARCH_MARK_PCREL
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_PCREL
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_DUP
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_GPREL
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_TLS_TPREL
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_TLS_GOT
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_TLS_GD
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_PLT_PCREL
+ENUMX
+  BFD_RELOC_LARCH_SOP_ASSERT
+ENUMX
+  BFD_RELOC_LARCH_SOP_NOT
+ENUMX
+  BFD_RELOC_LARCH_SOP_SUB
+ENUMX
+  BFD_RELOC_LARCH_SOP_SL
+ENUMX
+  BFD_RELOC_LARCH_SOP_SR
+ENUMX
+  BFD_RELOC_LARCH_SOP_ADD
+ENUMX
+  BFD_RELOC_LARCH_SOP_AND
+ENUMX
+  BFD_RELOC_LARCH_SOP_IF_ELSE
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_5
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_U_10_12
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_12
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_16
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_5_20
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_U
+ENUMX
+  BFD_RELOC_LARCH_ADD8
+ENUMX
+  BFD_RELOC_LARCH_ADD16
+ENUMX
+  BFD_RELOC_LARCH_ADD24
+ENUMX
+  BFD_RELOC_LARCH_ADD32
+ENUMX
+  BFD_RELOC_LARCH_ADD64
+ENUMX
+  BFD_RELOC_LARCH_SUB8
+ENUMX
+  BFD_RELOC_LARCH_SUB16
+ENUMX
+  BFD_RELOC_LARCH_SUB24
+ENUMX
+  BFD_RELOC_LARCH_SUB32
+ENUMX
+  BFD_RELOC_LARCH_SUB64
+ENUMDOC
+  LoongISA relocations.
+
 ENDSENUM
   BFD_RELOC_UNUSED
 CODE_FRAGMENT
diff --git a/bfd/targets.c b/bfd/targets.c
index 076441b3a21..3c6fc95f08e 100644
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -946,6 +946,8 @@ extern const bfd_target xtensa_elf32_le_vec;
 extern const bfd_target z80_coff_vec;
 extern const bfd_target z80_elf32_vec;
 extern const bfd_target z8k_coff_vec;
+extern const bfd_target loongarch_elf64_vec;
+extern const bfd_target loongarch_elf32_vec;
 
 /* These are always included.  */
 extern const bfd_target srec_vec;
@@ -1366,6 +1368,12 @@ static const bfd_target * const _bfd_target_vector[] =
 	&z80_elf32_vec,
 
 	&z8k_coff_vec,
+
+#ifdef BFD64
+	&loongarch_elf32_vec,
+	&loongarch_elf64_vec,
+#endif
+
 #endif /* not SELECT_VECS */
 
 /* Always support S-records, for convenience.  */
diff --git a/binutils/readelf.c b/binutils/readelf.c
index ad16b4571c9..66b24769cfb 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -164,6 +164,7 @@
 #include "elf/xstormy16.h"
 #include "elf/xtensa.h"
 #include "elf/z80.h"
+#include "elf/loongarch.h"
 
 #include "getopt.h"
 #include "libiberty.h"
@@ -929,6 +930,7 @@ guess_is_rela (unsigned int e_machine)
     case EM_MICROBLAZE:
     case EM_MICROBLAZE_OLD:
     case EM_WEBASSEMBLY:
+    case EM_LOONGARCH:
       return TRUE;
 
     case EM_68HC05:
@@ -1634,6 +1636,10 @@ dump_relocations (Filedata *          filedata,
 	case EM_Z80:
 	  rtype = elf_z80_reloc_type (type);
 	  break;
+
+	case EM_LOONGARCH:
+	  rtype = elf_loongarch_reloc_type (type);
+	  break;
 	}
 
       if (rtype == NULL)
@@ -3834,6 +3840,15 @@ get_machine_flags (Filedata * filedata, unsigned e_flags, unsigned e_machine)
 	      strcat (buf, _(", unknown")); break;
 	    }
 	  break;
+
+	case EM_LOONGARCH:
+	  switch (e_flags & EF_LARCH_ABI)
+	    {
+	    case EF_LARCH_ABI_LP64:	strcat (buf, ", LP64"); break;
+	    case EF_LARCH_ABI_XLP32:	strcat (buf, ", XLP32"); break;
+	    case EF_LARCH_ABI_LP32:	strcat (buf, ", LP32"); break;
+	    }
+	  break;
 	}
     }
 
@@ -13840,6 +13855,7 @@ is_none_reloc (Filedata * filedata, unsigned int reloc_type)
     case EM_XC16X:
     case EM_Z80:     /* R_Z80_NONE. */
     case EM_WEBASSEMBLY: /* R_WASM32_NONE.  */
+    case EM_LOONGARCH: /* R_LARCH_NONE */
       return reloc_type == 0;
 
     case EM_AARCH64:
@@ -18372,6 +18388,14 @@ get_note_type (Filedata * filedata, unsigned e_type)
 	return _("NT_ARM_HW_WATCH (AArch hardware watchpoint registers)");
       case NT_ARC_V2:
 	return _("NT_ARC_V2 (ARC HS accumulator/extra registers)");
+      case NT_LARCH_CPUCFG:
+	return _("NT_LARCH_CPUCFG (Loongarch CPU config registers)");
+      case NT_LARCH_LBT:
+	return _("NT_LARCH_LBT (Loongarch Loongson Binary Translation registers)");
+      case NT_LARCH_LSX:
+	return _("NT_LARCH_LSX (Loongarch Loongson SIMD Extension registers)");
+      case NT_LARCH_LASX:
+	return _("NT_LARCH_LASX (Loongarch Loongson Advanced SIMD Extension registers)");
       case NT_PSTATUS:
 	return _("NT_PSTATUS (pstatus structure)");
       case NT_FPREGS:
diff --git a/gas/Makefile.am b/gas/Makefile.am
index bf167b372d4..c0c82e5eb08 100644
--- a/gas/Makefile.am
+++ b/gas/Makefile.am
@@ -153,6 +153,7 @@ TARGET_CPU_CFILES = \
 	config/tc-ip2k.c \
 	config/tc-iq2000.c \
 	config/tc-lm32.c \
+	config/tc-loongarch.c \
 	config/tc-m32c.c \
 	config/tc-m32r.c \
 	config/tc-m68hc11.c \
@@ -371,7 +372,8 @@ EXTRA_SCRIPTS = .gdbinit
 EXTRA_DIST = m68k-parse.c itbl-parse.c itbl-parse.h itbl-lex.c \
 	bfin-parse.c bfin-parse.h bfin-lex.c \
 	rl78-parse.c rl78-parse.h \
-	rx-parse.c rx-parse.h
+	rx-parse.c rx-parse.h \
+	loongarch-parse.c loongarch-parse.h loongarch-lex.c
 
 diststuff: $(EXTRA_DIST) info
 
@@ -516,6 +518,27 @@ rx-parse.h: rx-parse.c
 rx-defs.h: ; @true
 $(srcdir)/config/rx-defs.h: ; @true
 
+EXTRA_as_new_SOURCES += config/loongarch-parse.y
+loongarch-parse.c: $(srcdir)/config/loongarch-parse.y
+	$(SHELL) $(YLWRAP) $(srcdir)/config/loongarch-parse.y y.tab.c loongarch-parse.c y.tab.h loongarch-parse.h -- $(YACCCOMPILE) -d ;
+loongarch-parse.h: loongarch-parse.c
+loongarch-parse.h: ; @true
+$(srcdir)/config/loongarch-parse.h: ; @true
+
+loongarch-lex.c: $(srcdir)/config/loongarch-lex.l
+	$(SHELL) $(YLWRAP) $(srcdir)/config/loongarch-lex.l lex.yy.c loongarch-lex.c -- $(LEXCOMPILE)
+loongarch-lex-wrapper.@OBJEXT@: $(srcdir)/config/loongarch-lex-wrapper.c loongarch-lex.c loongarch-parse.h
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $(srcdir)/config/loongarch-lex-wrapper.c $(NO_WERROR)
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='loongarch-lex-wrapper.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c $(srcdir)/config/loongarch-lex-wrapper.c $(NO_WERROR)
+endif
+
 # The instruction table specification lexical analyzer and parser.
 
 # Disable -Werror, if it has been enabled, since old versions of bison/
diff --git a/gas/config/loongarch-lex-wrapper.c b/gas/config/loongarch-lex-wrapper.c
new file mode 100644
index 00000000000..8ddf1dd2330
--- /dev/null
+++ b/gas/config/loongarch-lex-wrapper.c
@@ -0,0 +1,25 @@
+/* Copyright (C) 2012-2018 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+/* The C source file generated by flex includes stdio.h before any of
+   the C code in bfin-lex.l.  Make sure we include sysdep.h first, so
+   that config.h can set the correct values for various things.  */
+
+#include "sysdep.h"
+#include "loongarch-lex.c"
diff --git a/gas/config/loongarch-lex.l b/gas/config/loongarch-lex.l
new file mode 100644
index 00000000000..1d553e6ebf8
--- /dev/null
+++ b/gas/config/loongarch-lex.l
@@ -0,0 +1,37 @@
+%option noyywrap
+%{
+#include "as.h"
+#include "loongarch-parse.h"
+%}
+
+D	[0-9]
+L	[a-zA-Z_\.\$]
+H	[0-9A-Fa-f]
+
+hex	0[xX]{H}+
+oct	0[0-7]+
+bin	0[bB][01]+
+dec	([1-9]{D}*)|0
+id	({D}+[fb])|({L}({D}|{L})*)|(:{dec}[bf])
+ws	[ \t\v\f]+
+
+%%
+
+{dec}	{ yylval.imm = strtoull (yytext, 0, 0); return INTEGER; }
+{hex}	{ yylval.imm = strtoull (yytext + 2, 0, 16); return INTEGER; }
+{bin}	{ yylval.imm = strtoull (yytext + 2, 0, 2); return INTEGER; }
+{oct}	{ yylval.imm = strtoull (yytext + 1, 0, 8); return INTEGER; }
+{id}	{ yylval.c_str = strdup (yytext);return IDENTIFIER; }
+{ws}	{ }
+
+">>"	{ return RIGHT_OP; }
+"<<"	{ return LEFT_OP; }
+"&&"	{ return AND_OP; }
+"||"	{ return OR_OP; }
+"<="	{ return LE_OP; }
+">="	{ return GE_OP; }
+"=="	{ return EQ_OP; }
+"!="	{ return NE_OP; }
+.	{ return yytext[0];}
+
+%%
diff --git a/gas/config/loongarch-parse.y b/gas/config/loongarch-parse.y
new file mode 100644
index 00000000000..aa7e51f5dc4
--- /dev/null
+++ b/gas/config/loongarch-parse.y
@@ -0,0 +1,420 @@
+%{
+#include "as.h"
+#include "loongarch-parse.h"
+void yyerror(const char *s) {}
+extern int yylex (void);
+extern void yy_scan_string (const char *);
+extern void
+get_internal_label (expressionS *label_expr,
+		    unsigned long label,
+		    int augend);
+
+
+static struct reloc_info *top, *end;
+
+static expressionS const_0 =
+{
+  .X_op = O_constant,
+  .X_add_number = 0
+};
+
+static int
+is_const (struct reloc_info *info)
+{
+  return info->type == BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE
+	 && info->value.X_op == O_constant;
+}
+
+int
+loongarch_parse_expr (const char *expr,
+		      struct reloc_info *reloc_stack_top,
+		      size_t max_reloc_num,
+		      size_t *reloc_num,
+		      offsetT *imm)
+{
+  int ret;
+  top = reloc_stack_top;
+  end = top + max_reloc_num;
+  yy_scan_string (expr);
+  ret = yyparse ();
+  if (ret == 0)
+    {
+      if (is_const (top - 1))
+	*imm = (--top)->value.X_add_number;
+      else
+	*imm = 0;
+      *reloc_num = top - reloc_stack_top;
+    }
+  return ret;
+}
+
+static void
+emit_const (offsetT imm)
+{
+  if (end <= top)
+    as_fatal (_("expr too huge"));
+  top->type = BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE;
+  top->value.X_op = O_constant;
+  top->value.X_add_number = imm;
+  top++;
+}
+
+static const char *
+my_getExpression (expressionS *ep, const char *str)
+{
+  char *save_in, *ret;
+  if (*str == ':')
+    {
+      unsigned long j;
+      char *str_1 = (char *) str;
+      str_1++;
+      j = strtol (str_1, &str_1, 10);
+      get_internal_label (ep, j, *str_1 == 'f');
+      return NULL;
+    }
+  save_in = input_line_pointer;
+  input_line_pointer = (char *)str;
+  expression (ep);
+  ret = input_line_pointer;
+  input_line_pointer = save_in;
+  return ret;
+}
+
+static void
+reloc (const char *op_c_str, const char *id_c_str, offsetT addend)
+{
+  expressionS id_sym_expr;
+
+  if (end <= top)
+    as_fatal (_("expr too huge"));
+
+  if (id_c_str)
+    {
+      my_getExpression (&id_sym_expr, id_c_str);
+      id_sym_expr.X_add_number += addend;
+    }
+  else
+    {
+      id_sym_expr.X_op = O_constant;
+      id_sym_expr.X_add_number = addend;
+    }
+
+  if (strcmp (op_c_str, "abs") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE;
+      top++;
+    }
+  else if (strcmp (op_c_str, "pcrel") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_PCREL;
+      top++;
+    }
+  else if (strcmp (op_c_str, "gprel") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_GPREL;
+      top++;
+    }
+  else if (strcmp (op_c_str, "tprel") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_TLS_TPREL;
+      top++;
+    }
+  else if (strcmp (op_c_str, "tlsgot") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_TLS_GOT;
+      top++;
+    }
+  else if (strcmp (op_c_str, "tlsgd") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_TLS_GD;
+      top++;
+    }
+  else if (strcmp (op_c_str, "plt") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_PLT_PCREL;
+      top++;
+    }
+  else
+    as_fatal (_("unknown reloc hint: %s"), op_c_str);
+}
+
+static void
+emit_unary (char op)
+{
+  struct reloc_info *s_top = top - 1;
+  if (is_const (s_top))
+    {
+      offsetT opr = s_top->value.X_add_number;
+      switch (op)
+	{
+	case '+':
+	  break;
+	case '-':
+	  opr = -opr;
+	  break;
+	case '~':
+	  opr = ~opr;
+	  break;
+	case '!':
+	  opr = !opr;
+	  break;
+	default:
+	  abort ();
+	}
+      s_top->value.X_add_number = opr;
+    }
+  else
+    {
+      if (end <= top)
+	as_fatal (_("expr too huge"));
+      switch (op)
+	{
+	case '!':
+	  top->type = BFD_RELOC_LARCH_SOP_NOT;
+	default:
+	  abort ();
+	}
+      top->value = const_0;
+      top++;
+    }
+}
+
+static void
+emit_bin (int op)
+{
+  struct reloc_info *last_1st = top - 1, *last_2nd = top - 2;
+  if (is_const (last_1st) && is_const (last_2nd))
+    {
+      offsetT opr1 = last_2nd->value.X_add_number;
+      offsetT opr2 = last_1st->value.X_add_number;
+      switch (op)
+	{
+	case '*':
+	  opr1 = opr1 * opr2;
+	  break;
+	case '/':
+	  opr1 = opr1 / opr2;
+	  break;
+	case '%':
+	  opr1 = opr1 % opr2;
+	  break;
+	case '+':
+	  opr1 = opr1 + opr2;
+	  break;
+	case '-':
+	  opr1 = opr1 - opr2;
+	  break;
+	case LEFT_OP:
+	  opr1 = opr1 << opr2;
+	  break;
+	case RIGHT_OP:
+	  /* Algorithm right shift  */
+	  opr1 = (offsetT)opr1 >> (offsetT)opr2;
+	  break;
+	case '<':
+	  opr1 = opr1 < opr2;
+	  break;
+	case '>':
+	  opr1 = opr1 > opr2;
+	  break;
+	case LE_OP:
+	  opr1 = opr1 <= opr2;
+	  break;
+	case GE_OP:
+	  opr1 = opr1 >= opr2;
+	  break;
+	case EQ_OP:
+	  opr1 = opr1 == opr2;
+	  break;
+	case NE_OP:
+	  opr1 = opr1 != opr2;
+	  break;
+	case '&':
+	  opr1 = opr1 & opr2;
+	  break;
+	case '^':
+	  opr1 = opr1 ^ opr2;
+	  break;
+	case '|':
+	  opr1 = opr1 | opr2;
+	  break;
+	case AND_OP:
+	  opr1 = opr1 && opr2;
+	  break;
+	case OR_OP:
+	  opr1 = opr1 || opr2;
+	  break;
+	default:
+	  abort ();
+	}
+      last_2nd->value.X_add_number = opr1;
+      last_1st->type = 0;
+      top--;
+    }
+  else
+    {
+      if (end <= top)
+	as_fatal (_("expr too huge"));
+      switch (op)
+	{
+	case '+':
+	  top->type = BFD_RELOC_LARCH_SOP_ADD;
+	  break;
+	case '-':
+	  top->type = BFD_RELOC_LARCH_SOP_SUB;
+	  break;
+	case LEFT_OP:
+	  top->type = BFD_RELOC_LARCH_SOP_SL;
+	  break;
+	case RIGHT_OP:
+	  top->type = BFD_RELOC_LARCH_SOP_SR;
+	  break;
+	case '&':
+	  top->type = BFD_RELOC_LARCH_SOP_AND;
+	  break;
+	default:
+	  abort ();
+	}
+      top->value = const_0;
+      top++;
+    }
+}
+
+static void
+emit_if_else (void)
+{
+  struct reloc_info *last_1st = top - 1;
+  struct reloc_info *last_2nd = top - 2;
+  struct reloc_info *last_3rd = top - 3;
+  if (is_const (last_1st) && is_const (last_2nd) && is_const (last_3rd))
+    {
+      offsetT opr1 = last_3rd->value.X_add_number;
+      offsetT opr2 = last_2nd->value.X_add_number;
+      offsetT opr3 = last_1st->value.X_add_number;
+      opr1 = opr1 ? opr2 : opr3;
+      last_3rd->value.X_add_number = opr1;
+      last_2nd->type = 0;
+      last_1st->type = 0;
+      top -= 2;
+    }
+  else
+    {
+      if (end <= top)
+	as_fatal (_("expr too huge"));
+      top->type = BFD_RELOC_LARCH_SOP_IF_ELSE;
+      top->value = const_0;
+      top++;
+    }
+}
+
+%}
+
+%union {
+char *c_str;
+offsetT imm;
+}
+
+%token <imm> INTEGER
+%token <c_str> IDENTIFIER
+%type <imm> addend
+
+%token LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP AND_OP OR_OP
+%start expression
+%%
+
+primary_expression
+	: INTEGER {emit_const ($1);}
+	| '(' expression ')'
+	| '%' IDENTIFIER '(' IDENTIFIER addend ')' {reloc ($2, $4, $5); free ($2); free ($4);}
+	| '%' IDENTIFIER '(' INTEGER addend ')' {reloc ($2, NULL, $4 + $5); free ($2);}
+	;
+
+addend
+	: addend '-' INTEGER {$$ -= $3;}
+	| addend '+' INTEGER {$$ += $3;}
+	| {$$ = 0;}
+	;
+
+unary_expression
+	: primary_expression
+	| '+' unary_expression {emit_unary ('+');}
+	| '-' unary_expression {emit_unary ('-');}
+	| '~' unary_expression {emit_unary ('~');}
+	| '!' unary_expression {emit_unary ('!');}
+	;
+
+multiplicative_expression
+	: unary_expression
+	| multiplicative_expression '*' unary_expression {emit_bin ('*');}
+	| multiplicative_expression '/' unary_expression {emit_bin ('/');}
+	| multiplicative_expression '%' unary_expression {emit_bin ('%');}
+	;
+
+additive_expression
+	: multiplicative_expression
+	| additive_expression '+' multiplicative_expression {emit_bin ('+');}
+	| additive_expression '-' multiplicative_expression {emit_bin ('-');}
+	;
+
+shift_expression
+	: additive_expression
+	| shift_expression LEFT_OP additive_expression {emit_bin (LEFT_OP);}
+	| shift_expression RIGHT_OP additive_expression {emit_bin (RIGHT_OP);}
+	;
+
+relational_expression
+	: shift_expression
+	| relational_expression '<' shift_expression {emit_bin ('<');}
+	| relational_expression '>' shift_expression {emit_bin ('>');}
+	| relational_expression LE_OP shift_expression {emit_bin (LE_OP);}
+	| relational_expression GE_OP shift_expression {emit_bin (GE_OP);}
+	;
+
+equality_expression
+	: relational_expression
+	| equality_expression EQ_OP relational_expression {emit_bin (EQ_OP);}
+	| equality_expression NE_OP relational_expression {emit_bin (NE_OP);}
+	;
+
+and_expression
+	: equality_expression
+	| and_expression '&' equality_expression {emit_bin ('&');}
+	;
+
+exclusive_or_expression
+	: and_expression
+	| exclusive_or_expression '^' and_expression {emit_bin ('^');}
+	;
+
+inclusive_or_expression
+	: exclusive_or_expression
+	| inclusive_or_expression '|' exclusive_or_expression {emit_bin ('|');}
+	;
+
+logical_and_expression
+	: inclusive_or_expression
+	| logical_and_expression AND_OP inclusive_or_expression {emit_bin (AND_OP);}
+	;
+
+logical_or_expression
+	: logical_and_expression
+	| logical_or_expression OR_OP logical_and_expression {emit_bin (OR_OP);}
+	;
+
+conditional_expression
+	: logical_or_expression
+	| logical_or_expression '?' expression ':' conditional_expression {emit_if_else ();}
+	;
+
+expression
+	: conditional_expression
+	;
+%%
+
diff --git a/gas/config/tc-loongarch-mips.c b/gas/config/tc-loongarch-mips.c
new file mode 100644
index 00000000000..c66127c594f
--- /dev/null
+++ b/gas/config/tc-loongarch-mips.c
@@ -0,0 +1,2555 @@
+#include "as.h"
+#include "opcode/loongarch.h"
+
+/* pinfo of MIPS insns */
+#define MIPS_HAS_DELAYSLOT 0x1l
+#define MIPS_IS_LIKELY_BRANCH 0x2l
+
+static const char * const mips_r_direct_map[32] =
+{
+  "$0", "$1", "$2", "$3", "$4", "$5", "$6", "$7",
+  "$8", "$9", "$10", "$11", "$12", "$13", "$14", "$15",
+  "$16", "$17", "$18", "$19", "$20", "$21", "$22", "$23",
+  "$24", "$25", "$26", "$27", "$28", "$29", "$30", "$31",
+};
+
+static const char * const mips_r_n64_to_lp64_map[32] =
+{
+  "$0", "$31", "$28", "$29", "$4", "$5", "$6", "$7",
+  "$8", "$9", "$10", "$11", "$12", "$13", "$14", "$15",
+  "$25", "$2", "$3", "", "$24", "", "$30", "$16",
+  "$17", "$18", "$19", "$20", "$21", "$22", "$23", "$28",
+};
+
+static const char * const mips_r_n64_to_lp64_map1[32] =
+{
+  "$zero", "$ra", "$gp", "$sp", "$a0", "$a1", "$a2", "$a3",
+  "$a4", "$a5", "$a6", "$a7", "$t0", "$t1", "$t2", "$t3",
+  "$t9", "$v0", "$v1", "", "$t8", "", "$s8", "$s0",
+  "$s1", "$s2", "$s3", "$s4", "$s5", "$s6", "$s7", "$gp",
+};
+
+static const char * const mips_r_n64_to_lp64_map2[32] =
+{
+  "", "", "", "", "", "", "", "",
+  "", "", "", "", "", "", "", "",
+  "", "", "", "", "", "", "$fp", "",
+  "", "", "", "", "", "", "", "",
+};
+
+/* FIXME!!!!!!!! FOR BIOS ASKING!!!!!!!!! */
+static const char * const mips_r_n64_to_lp64_map3[32] =
+{
+  "", "", "", "", "", "", "", "",
+  "", "", "", "", "", "", "", "",
+  "", "$r17", "$r18", "", "", "$r21", "$r22", "",
+  "", "", "", "", "", "", "", "",
+};
+
+static const char * const mips_f_direct_map[32] =
+{
+  "$f0", "$f1", "$f2", "$f3", "$f4", "$f5", "$f6", "$f7",
+  "$f8", "$f9", "$f10", "$f11", "$f12", "$f13", "$f14", "$f15",
+  "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23",
+  "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31",
+};
+
+static const char * const mips_f_n64_to_lp64_map[32] =
+{
+  "$f12", "$f13", "$f14", "$f15", "$f16", "$f17", "$f18", "$f19",
+  "$f1", "$f3", "$f4", "$f5", "$f6", "$f7", "$f8", "$f9",
+  "$f10", "$f11", "$f20", "$f21", "$f22", "$f23", "$f0", "$f2",
+  "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31",
+};
+
+static const char * const mips_c_direct_map[8] =
+{
+  "$fcc0", "$fcc1", "$fcc2", "$fcc3", "$fcc4", "$fcc5", "$fcc6", "$fcc7",
+};
+
+static const char * const loongarch_r_mips_o32_name[32] =
+{
+  "$zero", "$at", "$v0", "$v1", "$a0", "$a1", "$a2", "$a3",
+  "$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7",
+  "$t8", "$t9", "$s0", "$s1", "$s2", "$s3", "$s4", "$s5",
+  "$s6", "$s7", "$k0", "$k1", "$gp", "$sp", "$fp", "$ra",
+};
+
+static const char * const loongarch_r_mips_n32_n64_name[32] =
+{
+  "$zero", "$at", "$v0", "$v1", "$a0", "$a1", "$a2", "$a3",
+  "$a4", "$a5", "$a6", "$a7", "$t4", "$t5", "$t6", "$t7",
+  "$s0", "$s1", "$s2", "$s3", "$s4", "$s5", "$s6", "$s7",
+  "$t8", "$t9", "$kt0", "$kt1", "$gp", "$sp", "$fp", "$ra",
+};
+
+static const char * const loongarch_r_mips_o32_n32_n64_name1[32] =
+{
+  "", "", "", "", "", "", "", "",
+  "", "", "", "", "", "", "", "",
+  "", "", "", "", "", "", "", "",
+  "", "", "", "", "", "", "$s8", "",
+};
+
+static const char * const mips_v_direct_map[32] =
+{
+  "$w0", "$w1", "$w2", "$w3", "$w4", "$w5", "$w6", "$w7",
+  "$w8", "$w9", "$w10", "$w11", "$w12", "$w13", "$w14", "$w15",
+  "$w16", "$w17", "$w18", "$w19", "$w20", "$w21", "$w22", "$w23",
+  "$w24", "$w25", "$w26", "$w27", "$w28", "$w29", "$w30", "$w31",
+};
+
+static const char * const mips_x_direct_map[32] =
+{
+  "$x0", "$x1", "$x2", "$x3", "$x4", "$x5", "$x6", "$x7",
+  "$x8", "$x9", "$x10", "$x11", "$x12", "$x13", "$x14", "$x15",
+  "$x16", "$x17", "$x18", "$x19", "$x20", "$x21", "$x22", "$x23",
+  "$x24", "$x25", "$x26", "$x27", "$x28", "$x29", "$x30", "$x31",
+};
+
+static struct htab *mips_r_map_htab = NULL;
+static struct htab *mips_f_map_htab = NULL;
+static struct htab *mips_c_map_htab = NULL;
+static struct htab *mips_v_map_htab = NULL;
+static struct htab *mips_x_map_htab = NULL;
+
+struct mips_converter_opts {
+  struct mips_converter_opts *next;
+  int mips_branch_has_delay_slot;
+};
+static struct mips_converter_opts *MIPS_opts = NULL;
+
+static struct loongarch_ase loongarch_mips_ASEs[];
+
+static void
+init_MIPS_opts (struct mips_converter_opts *opts)
+{
+  opts->next = NULL;
+  opts->mips_branch_has_delay_slot = 0;
+}
+
+static void
+s_loongarch_mips_set (int x ATTRIBUTE_UNUSED)
+{
+  char *name = input_line_pointer, ch;
+
+  while (!is_end_of_line[(unsigned char) *input_line_pointer])
+    ++input_line_pointer;
+  ch = *input_line_pointer;
+  *input_line_pointer = '\0';
+
+  if (strchr (name, ','))
+    {
+      /* Generic ".set" directive; use the generic handler.  */
+      *input_line_pointer = ch;
+      input_line_pointer = name;
+      s_set (0);
+      return;
+    }
+
+  if (strcmp (name, "reorder") == 0)
+    MIPS_opts->mips_branch_has_delay_slot = 0;
+  else if (strcmp (name, "noreorder") == 0)
+    MIPS_opts->mips_branch_has_delay_slot = 1;
+  else if (strcmp (name, "push") == 0)
+    {
+      struct mips_converter_opts *s = XNEW (struct mips_converter_opts);
+      init_MIPS_opts (s);
+      s->next = MIPS_opts;
+      MIPS_opts = s;
+    }
+  else if (strcmp (name, "pop") == 0)
+    {
+      struct mips_converter_opts *s = MIPS_opts->next;
+      if (s == NULL)
+	as_fatal (_(".set pop with no .set push"));
+      else
+	{
+	  free (MIPS_opts);
+	  MIPS_opts = s;
+	}
+    }
+
+  *input_line_pointer = ch;
+  demand_empty_rest_of_line ();
+}
+
+static void
+s_loongarch_mips_abicalls (int x ATTRIBUTE_UNUSED)
+{
+  as_fatal ("\n"
+"LoongISA-MIPS translation not support abicalls and explicit relocs.\n"
+"Re-compile src with '-mno-abicalls -mno-explicit-relocs'.");
+}
+
+static void
+s_loongarch_mips_nan (int x ATTRIBUTE_UNUSED)
+{
+  char *name = input_line_pointer, ch;
+
+  while (!is_end_of_line[(unsigned char) *input_line_pointer])
+    ++input_line_pointer;
+  ch = *input_line_pointer;
+  *input_line_pointer = '\0';
+
+  if (strcmp (name, "2008") != 0)
+    as_fatal ("\n"
+"LoongISA support IEEE 754-2008 only, legacy IEEE 754 MIPS procedure will\n"
+"result to fail. Re-compile src with '-mnan=2008 -mabs=2008'.");
+
+  *input_line_pointer = ch;
+  demand_empty_rest_of_line ();
+}
+
+static void
+s_loongarch_mips_change_sec (int sec)
+{
+  segT seg;
+
+#ifdef OBJ_ELF
+  /* The ELF backend needs to know that we are changing sections, so
+     that .previous works correctly.  We could do something like check
+     for an obj_section_change_hook macro, but that might be confusing
+     as it would not be appropriate to use it in the section changing
+     functions in read.c, since obj-elf.c intercepts those.  FIXME:
+     This should be cleaner, somehow.  */
+  obj_elf_section_change_hook ();
+#endif
+  switch (sec)
+    {
+    case 'r':
+      seg = subseg_new (".rodata", (subsegT) get_absolute_expression ());
+      bfd_set_section_flags (seg, (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_RELOC | SEC_DATA));
+      if (strcmp (TARGET_OS, "elf") != 0)
+	record_alignment (seg, 4);
+      demand_empty_rest_of_line ();
+      break;
+    case 's':
+      seg = subseg_new (".sdata", (subsegT) get_absolute_expression ());
+      bfd_set_section_flags (seg, SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA);
+      if (strcmp (TARGET_OS, "elf") != 0)
+	record_alignment (seg, 4);
+      demand_empty_rest_of_line ();
+      break;
+    }
+}
+
+static const pseudo_typeS loongarch_mips_pseudo_table[] =
+{
+  {"align", s_loongarch_align, -4},
+  {"rdata", s_loongarch_mips_change_sec, 'r'},
+  {"ent", s_ignore, 0},
+  {"end", s_ignore, 0},
+  {"set", s_loongarch_mips_set, 0},
+  {"frame", s_ignore, 0},
+  {"mask", s_ignore, 0},
+  {"fmask", s_ignore, 0},
+  {"insn", s_ignore, 0},
+  {"cpload", s_ignore, 0},
+  {"cpsetup", s_ignore, 0},
+  {"cprestore", s_ignore, 0},
+  {"cpreturn", s_ignore, 0},
+  {"cplocal", s_ignore, 0},
+  {"abicalls", s_loongarch_mips_abicalls, 0},
+  {"nan", s_loongarch_mips_nan, 0},
+  {"module", s_ignore, 0},
+  {"dword", cons, 8},
+  {"word", cons, 4},
+  {"half", cons, 2},
+  {"dtprelword", s_dtprel, 4},
+  {"dtpreldword", s_dtprel, 8},
+  {"asciiz", stringer, 8 + 1},
+  { NULL, NULL, 0 },
+};
+
+static void
+loongarch_mips_converter_init (void)
+{
+  if (LARCH_opts.ase_test)
+    {
+      const struct loongarch_opcode *it;
+      struct loongarch_ase *ase;
+      for (ase = loongarch_mips_ASEs; ase->enabled; ase++)
+	for (it = ase->opcodes; it->name; it++)
+	  {
+	    if (loongarch_check_format (it->format) != 0)
+	      as_fatal (_("MIPS insn name: %s\tformat: %s\tsyntax error"),
+			it->name, it->format);
+	    if (it->macro == 0)
+	      as_fatal (_("insn name: %s\nformat: %s\n"
+			  "We want all MIPS insns are macro insn\n"
+			  "Make sure 'mask' is 0 and 'macro' is not NULL"),
+			it->name, it->format);
+	    if (it->macro && loongarch_check_macro (it->format, it->macro) != 0)
+	      as_fatal (_("MIPS insn name: %s\nformat: %s\n"
+			  "macro: %s\tsyntax error"),
+			it->name, it->format, it->macro);
+	  }
+    }
+
+  size_t i;
+
+  MIPS_opts = XNEW (struct mips_converter_opts);
+  init_MIPS_opts (MIPS_opts);
+
+  ASM_opts.mips_ase_fix = 1;
+  ASM_opts.mips_ase_float = 1;
+  ASM_opts.mips_ase_msa = 1;
+  ASM_opts.mips_ase_lasx = 1;
+
+  if (ASM_opts.mips_abi_is_n64 == 0)
+    {
+      as_warn (_("We just support for MIPS n64 map to LoongISA lp64"));
+      ASM_opts.mips_abi_is_n64 = 1;
+    }
+
+  if (!mips_r_map_htab)
+    {
+      mips_r_map_htab = str_htab_create ();
+      str_hash_insert (mips_r_map_htab, "", 0, 0);
+    }
+  if (!mips_f_map_htab)
+    {
+      mips_f_map_htab = str_htab_create ();
+      str_hash_insert (mips_f_map_htab, "", 0, 0);
+    }
+  if (!mips_c_map_htab)
+    {
+      mips_c_map_htab = str_htab_create ();
+      str_hash_insert (mips_c_map_htab, "", 0, 0);
+    }
+  if (!mips_v_map_htab)
+    {
+      mips_v_map_htab = str_htab_create ();
+      str_hash_insert (mips_v_map_htab, "", 0, 0);
+    }
+  if (!mips_x_map_htab)
+    {
+      mips_x_map_htab = str_htab_create ();
+      str_hash_insert (mips_x_map_htab, "", 0, 0);
+    }
+
+  if (LARCH_opts.abi_is_lp64 && ASM_opts.mips_abi_is_n64)
+    {
+      for (i = 0; i < ARRAY_SIZE (mips_r_n64_to_lp64_map); i++)
+	str_hash_insert
+	  (mips_r_map_htab, mips_r_n64_to_lp64_map[i], (void *) (i + 1), 0);
+      for (i = 0; i < ARRAY_SIZE (mips_r_n64_to_lp64_map1); i++)
+	str_hash_insert
+	  (mips_r_map_htab, mips_r_n64_to_lp64_map1[i], (void *) (i + 1), 0);
+      for (i = 0; i < ARRAY_SIZE (mips_r_n64_to_lp64_map2); i++)
+	str_hash_insert
+	  (mips_r_map_htab, mips_r_n64_to_lp64_map2[i], (void *) (i + 1), 0);
+      for (i = 0; i < ARRAY_SIZE (mips_r_n64_to_lp64_map3); i++)
+	str_hash_insert
+	  (mips_r_map_htab, mips_r_n64_to_lp64_map3[i], (void *) (i + 1), 0);
+      for (i = 0; i < ARRAY_SIZE (mips_f_n64_to_lp64_map); i++)
+	str_hash_insert
+	  (mips_f_map_htab, mips_f_n64_to_lp64_map[i], (void *) (i + 1), 0);
+      str_hash_insert (r_htab, "$at", (void *) 20, 0); // for those MIPS insn need 'at' to expand
+    }
+  else if (ASM_opts.mips_abi_is_n64)
+    as_fatal (_("MIPS n64 can only map to LoongISA lp64"));
+  else if (ASM_opts.mips_abi_is_n32)
+    as_fatal (_("not support n32"));
+  else if (ASM_opts.mips_abi_is_o32)
+    as_fatal (_("not support o32"));
+  else
+    {
+      for (i = 0; i < ARRAY_SIZE (mips_r_direct_map); i++)
+        str_hash_insert (mips_r_map_htab, mips_r_direct_map[i], (void *) (i + 1), 0);
+      for (i = 0; i < ARRAY_SIZE (mips_f_direct_map); i++)
+        str_hash_insert (mips_f_map_htab, mips_f_direct_map[i], (void *) (i + 1), 0);
+    }
+
+  for (i = 0; i < ARRAY_SIZE (mips_c_direct_map); i++)
+    str_hash_insert (mips_c_map_htab, mips_c_direct_map[i], (void *) (i + 1), 0);
+  for (i = 0; i < ARRAY_SIZE (mips_v_direct_map); i++)
+    str_hash_insert (mips_v_map_htab, mips_v_direct_map[i], (void *) (i + 1), 0);
+  for (i = 0; i < ARRAY_SIZE (mips_x_direct_map); i++)
+    str_hash_insert (mips_x_map_htab, mips_x_direct_map[i], (void *) (i + 1), 0);
+}
+
+static int
+tc_loongarch_mips_dw2regnum_mapping (int regnum)
+{
+  if (0 <= regnum && regnum < 32)
+    regnum =
+      (offsetT) str_hash_find (mips_r_map_htab, mips_r_direct_map[regnum]) - 1;
+  return regnum;
+}
+
+struct match_helper
+{
+  int match_now;
+  int all_match;
+};
+
+static int32_t
+loongarch_mips_args_parser_can_match_arg_helper (char esc_ch1,
+					   char esc_ch2,
+					   const char *bit_field,
+					   const char *arg,
+					   void *context)
+{
+  struct match_helper *match = context;
+  int ret = 0;
+  int64_t imm;
+  expressionS const_expr;
+
+  if (!match->match_now)
+    return 0;
+
+  switch (esc_ch1)
+    {
+    case 'l':
+      switch (esc_ch2)
+	{
+	default:
+	  match->match_now = is_label (arg);
+	  if (!match->match_now && is_label_with_addend (arg))
+	    as_fatal (_("This label shouldn't be with addend."));
+	  break;
+	case 'a':
+	  match->match_now = is_label_with_addend (arg);
+	  break;
+	}
+      break;
+    case 's':
+      my_getExpression (&const_expr, arg);
+      match->match_now = const_expr.X_op == O_constant;
+      break;
+    case 'u':
+      my_getExpression (&const_expr, arg);
+      match->match_now = const_expr.X_op == O_constant
+		       && const_expr.X_unsigned == 1;
+      break;
+    case 'r':
+      if (esc_ch2 == 'z')
+	{
+	  match->match_now = (strcmp (arg, "$0") == 0
+			      || (LARCH_opts.abi_is_lp64
+				  && strcmp (arg, "$zero") == 0));
+	  break;
+	}
+      else if (esc_ch2 == 'a' && LARCH_opts.abi_is_lp64)
+        {
+	  match->match_now = strcmp (arg, "$31") == 0
+			   || strcmp (arg, "$ra") == 0;
+	  break;
+	}
+      imm = (offsetT) str_hash_find (mips_r_map_htab, arg);
+      match->match_now = 0 < imm;
+      break;
+    case 'f':
+      imm = (offsetT) str_hash_find (mips_f_map_htab, arg);
+      match->match_now = 0 < imm;
+      break;
+    case 'c':
+      imm = (offsetT) str_hash_find (mips_c_map_htab, arg);
+      match->match_now = 0 < imm;
+      break;
+    case 'v':
+      imm = (offsetT) str_hash_find (mips_v_map_htab, arg);
+      match->match_now = 0 < imm;
+      break;
+    case 'x':
+      imm = (offsetT) str_hash_find (mips_x_map_htab, arg);
+      match->match_now = 0 < imm;
+      break;
+    case '\0':
+      match->all_match = match->match_now? 1 : 0;
+    }
+  switch (esc_ch1)
+    {
+    case 's':
+    case 'u':
+      if (match->match_now)
+	{
+	  int bit_width, bits_needed_s, bits_needed_u;
+	  char *bit_field_1 = (char *) bit_field;
+	  imm = const_expr.X_add_number;
+
+	  bit_width = loongarch_get_bit_field_width (bit_field_1, &bit_field_1);
+
+	  if (bit_width == -1)
+	    // no specify
+	    break;
+
+	  // 在这里求出实际填入的二进制数。这部分内容和loongarch_encode_imm
+	  // 有重合。但是需要在这里加入一些判断内容，比如分支指令立即数
+	  // 右移两位，要保证立即数低两位为0
+	  if (bit_field_1[0] == '<' && bit_field_1[1] == '<')
+	    {
+	      int i = strtol (bit_field_1 += 2, &bit_field_1, 10), j;
+	      for (j = i; 0 < j; j--, imm >>= 1)
+	        if (imm & 1)
+		  match->match_now = 0;
+	    }
+	  else if (*bit_field_1 == '+')
+	    imm -= strtol (bit_field_1, &bit_field_1, 10);
+
+	  bits_needed_u = loongarch_bits_imm_needed (imm, 0);
+	  bits_needed_s = loongarch_bits_imm_needed (imm, 1);
+	  // 在这里判断立即数是否溢出。关于有符号立即数我有两种理解
+	  // 一是代数意义上的溢出，如果传入的值超出定义域，那么报错。
+	  // 二是程序员可能希望指定位域表示，那么在有符号立即数数中可能指定一个很大的正数。
+	  // MIPS的情况两种都有，这里按照第一种来判断，如果真的溢出了则认为匹配失败，而不报错。
+	  // 因此留下了余地，对于那种特殊情况，比如当立即数为0或者是某个位宽时展开特殊指令。
+	  if ((esc_ch1 == 's' && bit_width < bits_needed_s)
+	      || (esc_ch1 == 'u'&& bit_width < bits_needed_u))
+	    match->match_now = 0;
+	}
+    }
+  return ret;
+}
+
+static const struct loongarch_opcode *
+get_loongarch_mips_opcode_by_name (const char *name, const char *arg_strs[])
+{
+  const struct loongarch_opcode *it;
+  struct loongarch_ase *ase;
+  for (ase = loongarch_mips_ASEs; ase->enabled; ase++)
+    {
+      if (!*ase->enabled
+          || (ase->include && !*ase->include)
+	  || (ase->exclude && *ase->exclude))
+	continue;
+
+      if (!ase->name_hash_entry)
+	{
+	  ase->name_hash_entry = str_htab_create ();
+	  for (it = ase->opcodes; it->name; it++)
+	    str_hash_insert (ase->name_hash_entry, it->name, (void *) it, 0);
+	}
+
+      if ((it = str_hash_find (ase->name_hash_entry, name)) == NULL)
+	continue;
+
+      do
+	{
+	  struct match_helper match_helper = {
+	    .match_now = 1,
+	    .all_match = 0
+	  };
+	  loongarch_foreach_args (it->format, arg_strs,
+	    loongarch_mips_args_parser_can_match_arg_helper, &match_helper);
+	  if (match_helper.all_match
+	      && !(it->include && !*it->include)
+	      && !(it->exclude && *it->exclude))
+	    return it;
+	  it++;
+	}
+      while (it->name && strcasecmp (it->name, name) == 0);
+    }
+  return NULL;
+}
+
+static const char *
+loongarch_mips_macro_expand_arg_map (char esc_ch1, char esc_ch2, const char *arg)
+{
+  const char *ret;
+  int i;
+  switch (esc_ch1)
+    {
+    case 'r':
+      i = (int64_t) str_hash_find (mips_r_map_htab, arg);
+      if (i == 0)
+	as_fatal (_("MIPS converter\nformat:%c%c\nnot found arg: %s"),
+		  esc_ch1, esc_ch2, arg);
+      ret = loongarch_r_normal_name[i - 1];
+      break;
+    case 'f':
+      i = (int64_t) str_hash_find (mips_f_map_htab, arg);
+      if (i == 0)
+	as_fatal (_("MIPS converter\nformat:%c%c\nnot found arg: %s"),
+		  esc_ch1, esc_ch2, arg);
+      ret = loongarch_f_normal_name[i - 1];
+      break;
+    case 'c':
+      i = (int64_t) str_hash_find (mips_c_map_htab, arg);
+      if (i == 0)
+	as_fatal (_("MIPS converter\nformat:%c%c\nnot found arg: %s"),
+		    esc_ch1, esc_ch2, arg);
+      ret = loongarch_c_normal_name[i - 1];
+      break;
+    case 'v':
+      i = (int64_t) str_hash_find (mips_v_map_htab, arg);
+      if (i == 0)
+	as_fatal (_("MIPS converter\nformat:%c%c\nnot found arg: %s"),
+		  esc_ch1, esc_ch2, arg);
+      ret = loongarch_v_normal_name[i - 1];
+      break;
+    case 'x':
+      i = (int64_t) str_hash_find (mips_x_map_htab, arg);
+      if (i == 0)
+	as_fatal (_("MIPS converter\nformat:%c%c\nnot found arg: %s"),
+		  esc_ch1, esc_ch2, arg);
+      ret = loongarch_x_normal_name[i - 1];
+      break;
+    default:
+      ret = arg;
+    }
+  return ret;
+}
+
+static char *
+loongarch_mips_macro_helper (const char * const args[], void *context_ptr)
+{
+  struct loongarch_opcode *insn = context_ptr;
+  char *ret = NULL;
+  if (strcmp (insn->name, "rdhwr") == 0)
+    {
+      const char * const t_args[2] = {args[0], NULL};
+      if (strcmp (args[1], "$0") == 0)
+	ret = loongarch_expand_macro_with_format_map ("r", "rdtime.d $r0,%1",
+		t_args, loongarch_mips_macro_expand_arg_map, NULL, NULL);
+      else if (strcmp (args[1], "$2") == 0)
+	ret = loongarch_expand_macro_with_format_map ("r", "rdtime.d %1,$r0",
+		t_args, loongarch_mips_macro_expand_arg_map, NULL, NULL);
+      else
+	as_fatal ("rdhwr not support HWR[%s]", args[1]);
+    }
+  return ret;
+}
+
+static int contrary_branch_cond_check = 0;
+
+static char *
+loongarch_converte_one_mips (char *str)
+{
+  static const struct loongarch_opcode *b;
+  static char *b_duped_args_buf;
+  static const char *b_arg_strs[MAX_ARG_NUM_PLUS_2];
+  static int this_is_likely_branch = 0;
+  static int not_seen_delay_slot_yet = 0;
+  int this_insn_is_in_delay_slot = not_seen_delay_slot_yet;
+  not_seen_delay_slot_yet = 0;
+
+  const char *name;
+  const char *arg_strs[MAX_ARG_NUM_PLUS_2];
+  name = str;
+  for (; *str && *str != ' '; str++);
+  if (*str == ' ')
+    *str++ = '\0';
+  str = strdup (str);
+
+  do
+    {
+      /* 然后把诸如sd $ra, 8($sp)最后一个实参，结尾括号里的寄存器单独拿出来
+	 此外，对于ld $3,($4)这种写法，转化为ld $3,0($4) */
+      int implicit_last_2nd_zero = 0;
+      char *t1, *t2;
+      for (t1 = str; *t1; t1++);
+      if (*--t1 == ')')
+	{
+	  t2 = t1;
+	  for (; str + 1 < t1 && *t1 != '('; t1--);
+	  if (t1[-1] == ',' && t1[0] == '(' && t1[1] == '$')
+	    implicit_last_2nd_zero = 1;
+	  if (t1[0] != '(' || t1[1] != '$')
+	    t1 = NULL;
+	}
+      else
+	t1 = NULL;
+
+      size_t num = loongarch_split_args_by_comma (str, arg_strs);
+      if (!t1)
+	break;
+      *t2 = '\0';
+      *t1 = '\0';
+      arg_strs[num] = t1 + 1;
+      arg_strs[num + 1] = NULL;
+      if (implicit_last_2nd_zero)
+	arg_strs[num - 1] = "0";
+    }
+  while (0);
+
+  const struct loongarch_opcode *insn;
+
+  if ((insn = get_loongarch_mips_opcode_by_name (name, arg_strs)) == NULL)
+    as_fatal (_("no match MIPS insn: %s\t%s"),
+	      name, loongarch_cat_splited_strs (arg_strs));
+
+  char *expanded_insn =
+    loongarch_expand_macro_with_format_map (insn->format, insn->macro,
+      arg_strs, loongarch_mips_macro_expand_arg_map,
+      loongarch_mips_macro_helper, (void *) insn);
+
+  if (insn->pinfo & MIPS_HAS_DELAYSLOT
+      && MIPS_opts->mips_branch_has_delay_slot)
+    {
+      if (this_insn_is_in_delay_slot)
+	as_fatal (_("a MIPS insn with delay-slot:\n%s %s\n"
+		    "followed another MIPS insn with delay-slot:\n%s %s"),
+		  b->name, loongarch_cat_splited_strs (b_arg_strs),
+		  name, loongarch_cat_splited_strs (arg_strs));
+      b = insn;
+      b_duped_args_buf = str;
+      memcpy (b_arg_strs, arg_strs, sizeof (b_arg_strs));
+
+      this_is_likely_branch = (insn->pinfo & MIPS_IS_LIKELY_BRANCH) != 0;
+      not_seen_delay_slot_yet = 1;
+
+      free (expanded_insn);
+      return strdup ("");
+    }
+  else if (this_insn_is_in_delay_slot)
+    {
+      /* 我们关注几类分支指令和延迟槽指令存在WAR相关的情况：
+	 第一种是条件判断时的WAR相关，such as
+	    bne $x, $y, sym
+	    ori $x, $z, imm */
+      int exist_cond_check_WAR_hazards = 0;
+
+      /* 第二种是跳转目标寄存器有WAR相关， such as
+	    j $x
+	    ori $x, $y, imm */
+      int exist_target_reg_WAR_hazards = 0;
+
+      /* 第三种，很奇怪的情况是子程序调用指令的返回寄存器有WAW相关， such as
+	    jalr $x, $y
+	    ori $x, $z, imm */
+      int exist_link_reg_WAW_hazards = 0;
+
+      char tgt_esc1 = '\0', tgt_esc2 ATTRIBUTE_UNUSED;
+      const char *tgt = NULL;
+      int64_t tgt_value;
+
+      char link_esc1, link_esc2 ATTRIBUTE_UNUSED;
+      const char *link = NULL;
+      int64_t link_value = 0;
+
+      char branch_stub_buf[8096];
+      branch_stub_buf[0] = '\0';
+
+      {
+	char dupped_b_format[strlen (b->format) + 1];
+	const char *b_format_strs[MAX_ARG_NUM_PLUS_2];
+	int64_t b_arg_value[MAX_ARG_NUM_PLUS_2];
+	size_t i, j;
+	char clobber_esc1 = '\0', clobber_esc2;
+	int64_t clobber_value = 0;
+
+	strcpy (dupped_b_format, b->format);
+	loongarch_split_args_by_comma (dupped_b_format, b_format_strs);
+
+	do
+	  {
+	    /* To find out the clobber register of delay-slot insn */
+
+	    if (arg_strs[0])
+	      {
+		/* Usually, the first arg is clobber register */
+		clobber_esc1 = insn->format[0];
+		clobber_esc2 = insn->format[1];
+		if (clobber_esc1 == 'r' && clobber_esc2 == 'c')
+		  clobber_value =
+		    (int64_t) str_hash_find (mips_r_map_htab, arg_strs[0]) - 1;
+		else if (clobber_esc1 == 'c')
+		  clobber_value =
+		    (int64_t) str_hash_find (mips_c_map_htab, arg_strs[0]) - 1;
+		else
+		  clobber_esc1 = clobber_esc2 = '\0';
+	      }
+
+	    if (clobber_esc1 != '\0')
+	      break;
+
+	    if (strncmp (name, "c.", 2) == 0
+		&& strcmp (insn->format, "f,f") == 0)
+	      /* for float cond insn */
+	      clobber_esc1 = 'c'
+		, clobber_value =
+		    (int64_t) str_hash_find (mips_c_map_htab, "$fcc0") - 1;
+	  }
+	while (0);
+
+	i = 0;
+
+	/* To find out link-register of subrounting call insn */
+	if (strcmp (b->name, "jalr") == 0 && strcmp (b->format, "r,r") == 0)
+	  /* The first arg of 'jalr r,r' is link-register */
+	  i = 1
+	    , link_esc1 = 'r', link = b_arg_strs[0]
+	    , link_value = (int64_t) str_hash_find
+				       (mips_r_map_htab, link) - 1;
+	else if (strcmp (b->name, "jalr") == 0
+		 || strcmp (b->name, "jal") == 0
+		 || strcmp (b->name, "bal") == 0)
+	  /* jalr r
+	     jal r
+	     jal l
+	     bal l */
+	  link_esc1 = 'r', link = "$31"
+	    , link_value = (int64_t) str_hash_find
+				       (mips_r_map_htab, link) - 1;
+	else
+	  link_esc1 = '\0';
+
+	j = i;
+
+	for (; b_format_strs[i]; i++)
+	  switch (b_format_strs[i][0])
+	    {
+	    case 'r':
+	      b_arg_value[i] =
+		(int64_t) str_hash_find (mips_r_map_htab, b_arg_strs[i]) - 1;
+	      break;
+	    case 'c':
+	      b_arg_value[i] =
+		(int64_t) str_hash_find (mips_c_map_htab, b_arg_strs[i]) - 1;
+	      break;
+	    case 's':
+	    case 'l':
+	      break;
+	    default:
+	      as_fatal ("unknown branch arg");
+	    }
+
+	/* branch insn must have actual arg. */
+	gas_assert (0 < i);
+
+	for (; j < i - 1; j++)
+	  if (clobber_esc1 == b_format_strs[j][0]
+	      && clobber_value == b_arg_value[j])
+	    exist_cond_check_WAR_hazards = 1;
+
+	if ((strcmp (b->name, "bc1t") == 0 || strcmp (b->name, "bc1f") == 0)
+	    && strcmp (b->format, "l") == 0 && clobber_esc1 == 'c'
+	    && clobber_value ==
+		 (int64_t) str_hash_find (mips_c_map_htab, "$fcc0") - 1)
+	  exist_cond_check_WAR_hazards = 1;
+
+	/* The last arg of branch insn is target */
+	tgt_esc1 = b_format_strs[j][0];
+	tgt_esc2 = b_format_strs[j][1];
+	tgt = b_arg_strs[j];
+	tgt_value = b_arg_value[j];
+
+	gas_assert (tgt);
+
+	if (clobber_esc1 == 'r'
+	    && clobber_esc1 == tgt_esc1 && clobber_value == tgt_value)
+	  exist_target_reg_WAR_hazards = 1;
+      }
+
+      /* 刚才的三种数据相关情况理论上来说是可以叠加出现的。但实际上MIPS没有
+	 条件调用子程序的指令，因此 */
+      gas_assert
+	(exist_cond_check_WAR_hazards + exist_link_reg_WAW_hazards < 2);
+
+      if (exist_target_reg_WAR_hazards)
+	/* 这种情况需要先把目标寄存器存在其他地方，不太可能是$at，因为延迟槽
+	   指令会用。这样说的话必须是一个专用的周转寄存器来暂存跳转目标。不过
+	   这种情况极少，为这种情况单独分配一个周转寄存器显得代价太大了。
+	   因此我们先不支持这种情况。 */
+	as_fatal (_("Subrouting call dest reg has WAR hazards.\n"
+		    "branch:     %s\t%s\n"
+		    "delay-slot: %s\t%s"),
+		  b->name, loongarch_cat_splited_strs (b_arg_strs),
+		  name, loongarch_cat_splited_strs (arg_strs));
+
+      if (exist_link_reg_WAW_hazards)
+	/* 这种情况等效于不进行子程序调用
+	    With delay-slot         Without delay-slot
+	    jalr $x, $y       ==>    ori $x, $z, imm
+	    ori $x, $z, imm          j $y
+	*/
+	link_esc1 = '\0';
+
+      if (exist_cond_check_WAR_hazards || this_is_likely_branch)
+	{
+/* 这种情况我们首先检查条件，根据条件真假前往两个基本块，基本块中有延迟槽
+   指令，基本块出口是跳转目标。对likely分支的处理和这种情况类似。
+non likely branch:
+    With delay-slot         Without delay-slot       Without delay-slot
+    bne $x, $y, sym    ==>    bne $x, $y, 1f    ==>    beq $x, $y, 1f
+    ori $x, $z, imm           ori $x, $z, imm          ori $x, $z, imm
+                              b 2f                     b sym
+                            1:ori $x, $z, imm        1:ori $x, $z, imm
+                              b sym
+                            2:
+
+likely branch:
+    With delay-slot         Without delay-slot       Without delay-slot
+    bnel $x, $y, sym   ==>    bne $x, $y, 1f    ==>    beq $x, $y, 1f
+    ori $x, $z, imm           b 2f                     ori $x, $z, imm
+                            1:ori $x, $z, imm          b sym
+                              b sym                  1:
+                            2:
+*/
+	  char *contrary_check_cond, *branch_tgt;
+	  const char *branch_tgt_args[3] = {NULL, NULL, NULL};
+	  const struct loongarch_opcode *c_b;
+
+	  contrary_branch_cond_check = 1;
+	  c_b = get_loongarch_mips_opcode_by_name (b->name, b_arg_strs);
+	  if (c_b == NULL)
+	    as_fatal (_("No contrary branch cond check insn?\n"
+			"branch:     %s\t%s"),
+		      b->name, loongarch_cat_splited_strs (b_arg_strs));
+	  contrary_check_cond =
+	    loongarch_expand_macro_with_format_map (c_b->format, c_b->macro,
+	      b_arg_strs, loongarch_mips_macro_expand_arg_map, NULL, NULL);
+	  contrary_branch_cond_check = 0;
+
+	  if (link_esc1 == '\0')
+	    link_esc1 = 'r', link = "$0"
+	      , link_value = (int64_t) str_hash_find (mips_r_map_htab, link) - 1;
+
+	  if (link_esc1 == 'r')
+	    branch_tgt_args[0] = loongarch_r_normal_name[link_value];
+	  else
+	    abort ();
+
+	  if (tgt_esc1 == 'r')
+	    branch_tgt_args[1] = loongarch_r_normal_name[tgt_value];
+	  else if (tgt_esc1 == 'l')
+	    branch_tgt_args[1] = tgt;
+	  else
+	    abort ();
+
+	  if (LARCH_opts.abi_is_lp64
+	      && link_esc1 == 'r' && link_value == 0
+	      && tgt_esc1 == 'r' && tgt_value == 1)
+	    branch_tgt = strdup ("or $v0,$t5,$r0;or $v1,$t6,$r0;"
+				 "fmov.d $fv0,$ft14;fmov.d $fv1,$ft15;"
+				 "jirl $r0,$r1;");
+	  else if (LARCH_opts.abi_is_lp64
+		   && link_esc1 == 'r' && link_value == 1
+		   && tgt_esc1 == 'r')
+	    branch_tgt = loongarch_expand_macro
+			   ("jirl $r1,%2;"
+			    "or $t5,$v0,$r0;or $t6,$v1,$r0;"
+			    "fmov.d $ft14,$fv0;fmov.d $ft15,$fv1;",
+			    branch_tgt_args, NULL, NULL);
+	  else if (LARCH_opts.abi_is_lp64
+		   && link_esc1 == 'r' && link_value == 1
+		   && tgt_esc1 == 'l')
+	    branch_tgt = loongarch_expand_macro
+			   ("bl %2;"
+			    "or $t5,$v0,$r0;or $t6,$v1,$r0;"
+			    "fmov.d $ft14,$fv0;fmov.d $ft15,$fv1;",
+			    branch_tgt_args, NULL, NULL);
+	  else if (LARCH_opts.abi_is_lp64
+		   && link_esc1 == 'r' && link_value != 0 && link_value != 1)
+	    as_fatal (_("MIPS n64 to LARCH lp64 not support jalr r,r"));
+	  else if (link_esc1 == 'r' && link_value == 0 && tgt_esc1 == 'l')
+	    branch_tgt = loongarch_expand_macro
+			   ("b %2;", branch_tgt_args, NULL, NULL);
+	  else if (link_esc1 == 'r' && link_value != 0 && tgt_esc1 == 'l')
+	    branch_tgt = loongarch_expand_macro
+			   ("la %1,%2;jirl %1,%1;", branch_tgt_args, NULL, NULL);
+	  else if (link_esc1 == 'r' && tgt_esc1 == 'r')
+	    branch_tgt = loongarch_expand_macro
+			   ("jirl %1,%2;", branch_tgt_args, NULL, NULL);
+	  else
+	    abort ();
+
+	  strcat (branch_stub_buf, contrary_check_cond);
+	  strcat (branch_stub_buf, ";");
+	  strcat (branch_stub_buf, expanded_insn);
+	  strcat (branch_stub_buf, ";");
+	  strcat (branch_stub_buf, branch_tgt);
+	  strcat (branch_stub_buf, ";:0:;");
+	  if (!this_is_likely_branch)
+	    strcat (branch_stub_buf, expanded_insn);
+	  free (b_duped_args_buf);
+	  free (expanded_insn);
+	  free (contrary_check_cond);
+	  free (branch_tgt);
+	}
+      else
+	{
+	  /* Without WAR hazards and it's not likely branch, we reverse
+	     the branch insn and the insn in delay-slot.
+	       With delay-slot		Without delay-slot
+	       bne $x, $y, sym    ==>    ori $m, $n, imm
+	       ori $m, $n, imm           bne $x, $y, sym  */
+	  char *expanded_b =
+	    loongarch_expand_macro_with_format_map (b->format, b->macro,
+	      b_arg_strs, loongarch_mips_macro_expand_arg_map, NULL, NULL);
+	  strcat (branch_stub_buf, expanded_insn);
+	  strcat (branch_stub_buf, ";");
+	  strcat (branch_stub_buf, expanded_b);
+	  free (b_duped_args_buf);
+	  free (expanded_insn);
+	  free (expanded_b);
+	}
+      return strdup (branch_stub_buf);
+    }
+  else
+    {
+      free (str);
+      return expanded_insn;
+    }
+}
+
+static struct loongarch_opcode loongarch_MIPS_branch[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+{0, 0, "b", "l", "b %1", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bal", "l",
+"bl %1;"
+"or $t5,$v0,$r0;or $t6,$v1,$r0;"
+"fmov.d $ft14,$fv0;fmov.d $ft15,$fv1;"
+, &LARCH_opts.abi_is_lp64, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bal", "l", "la $r31,%1;jirl $r31,$r31,0", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "beq", "r,r,l", "beq %1,%2,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "beq", "r,s,l", "dli $at,%2;beq %1,$at,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "beql", "r,r,l", "beq %1,%2,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "beql", "r,s,l", "dli $at,%2;beq %1,$at,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bne", "r,r,l", "bne %1,%2,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bne", "r,s,l", "dli $at,%2;bne %1,$at,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bnel", "r,r,l", "bne %1,%2,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bnel", "r,s,l", "dli $at,%2;bne %1,$at,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "ble", "r,r,l", "bge %2,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "ble", "r,s,l", "dli $at,%2;bge $at,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "blel", "r,r,l", "bge %2,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "blel", "r,s,l", "dli $at,%2;bge $at,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bleu", "r,r,l", "bgeu %2,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bleu", "r,s,l", "dli $at,%2;bgeu $at,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bleul", "r,r,l", "bgeu %2,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bleul", "r,s,l", "dli $at,%2;bgeu $at,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bge", "r,r,l", "bge %1,%2,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bge", "r,s,l", "dli $at,%2;bge %1,$at,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bgel", "r,r,l", "bge %1,%2,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bgel", "r,s,l", "dli $at,%2;bge %1,$at,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bgeu", "r,r,l", "bgeu %1,%2,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bgeu", "r,s,l", "dli $at,%2;bgeu %1,$at,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bgeul", "r,r,l", "bgeu %1,%2,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bgeul", "r,s,l", "dli $at,%2;bgeu %1,$at,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "blt", "r,r,l", "blt %1,%2,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "blt", "r,s,l", "dli $at,%2;blt %1,$at,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bltl", "r,r,l", "blt %1,%2,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bltl", "r,s,l", "dli $at,%2;blt %1,$at,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bltu", "r,r,l", "bltu %1,%2,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bltu", "r,s,l", "dli $at,%2;bltu %1,$at,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bltul", "r,r,l", "bltu %1,%2,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bltul", "r,s,l", "dli $at,%2;bltu %1,$at,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bgt", "r,r,l", "blt %2,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bgt", "r,s,l", "dli $at,%2;blt $at,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bgtl", "r,r,l", "blt %2,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bgtl", "r,s,l", "dli $at,%2;blt $at,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bgtu", "r,r,l", "bltu %2,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bgtu", "r,s,l", "dli $at,%2;bltu $at,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bgtul", "r,r,l", "bltu %2,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bgtul", "r,s,l", "dli $at,%2;bltu $at,%1,%3", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "beqz", "r,l", "beqz %1,%2", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "beqzl", "r,l", "beqz %1,%2", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bnez", "r,l", "bnez %1,%2", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bnezl", "r,l", "bnez %1,%2", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "blez", "r,l", "bge $r0,%1,%2", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "blezl", "r,l", "bge $r0,%1,%2", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bgez", "r,l", "bge %1,$r0,%2", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bgezl", "r,l", "bge %1,$r0,%2", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bltz", "r,l", "blt %1,$r0,%2", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bltzl", "r,l", "blt %1,$r0,%2", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bgtz", "r,l", "blt $r0,%1,%2", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bgtzl", "r,l", "blt $r0,%1,%2", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "j", "ra",
+"or $v0,$t5,$r0;or $v1,$t6,$r0;"
+"fmov.d $fv0,$ft14;fmov.d $fv1,$ft15;"
+"jirl $r0,$ra,0"
+, &LARCH_opts.abi_is_lp64, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "j", "r", "jirl $r0,%1,0", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "j", "l", "b %1", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "jr", "ra",
+"or $v0,$t5,$r0;or $v1,$t6,$r0;"
+"fmov.d $fv0,$ft14;fmov.d $fv1,$ft15;"
+"jirl $r0,$ra,0"
+, &LARCH_opts.abi_is_lp64, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "jr", "r", "jirl $r0,%1,0", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "jal", "r",
+"jirl $ra,%1,0;"
+"or $t5,$v0,$r0;or $t6,$v1,$r0;"
+"fmov.d $ft14,$fv0;fmov.d $ft15,$fv1;"
+, &LARCH_opts.abi_is_lp64, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "jal", "r", "jirl $r31,%1,0", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "jal", "l",
+"bl %1;"
+"or $t5,$v0,$r0;or $t6,$v1,$r0;"
+"fmov.d $ft14,$fv0;fmov.d $ft15,$fv1;"
+, &LARCH_opts.abi_is_lp64, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "jal", "l", "la $r31,%1;jirl $r31,$r31,0", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "jalr", "r,r", "jirl %1,%2,0", 0, &LARCH_opts.abi_is_lp64, MIPS_HAS_DELAYSLOT},
+{0, 0, "jalr", "r",
+"jirl $ra,%1,0;"
+"or $t5,$v0,$r0;or $t6,$v1,$r0;"
+"fmov.d $ft14,$fv0;fmov.d $ft15,$fv1;"
+, &LARCH_opts.abi_is_lp64, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "jalr", "r", "jirl $r31,%1,0", 0, 0, MIPS_HAS_DELAYSLOT},
+{0} /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_MIPS_branch_contrary[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+{0, 0, "b", "l", "", 0, 0, 0},
+{0, 0, "bal", "l", "", 0, 0, 0},
+{0, 0, "beq", "r,r,l", "bne %1,%2,:0f", 0, 0, 0},
+{0, 0, "beq", "r,s,l", "dli $at,%2;bne %1,$at,:0f", 0, 0, 0},
+{0, 0, "beql", "r,r,l", "bne %1,%2,:0f", 0, 0, 0},
+{0, 0, "beql", "r,s,l", "dli $at,%2;bne %1,$at,:0f", 0, 0, 0},
+{0, 0, "bne", "r,r,l", "beq %1,%2,:0f", 0, 0, 0},
+{0, 0, "bne", "r,s,l", "dli $at,%2;beq %1,$at,:0f", 0, 0, 0},
+{0, 0, "bnel", "r,r,l", "beq %1,%2,:0f", 0, 0, 0},
+{0, 0, "bnel", "r,s,l", "dli $at,%2;beq %1,$at,:0f", 0, 0, 0},
+{0, 0, "ble", "r,r,l", "blt %2,%1,:0f", 0, 0, 0},
+{0, 0, "ble", "r,s,l", "dli $at,%2;blt $at,%1,:0f", 0, 0, 0},
+{0, 0, "blel", "r,r,l", "blt %2,%1,:0f", 0, 0, 0},
+{0, 0, "blel", "r,s,l", "dli $at,%2;blt $at,%1,:0f", 0, 0, 0},
+{0, 0, "bleu", "r,r,l", "bltu %2,%1,:0f", 0, 0, 0},
+{0, 0, "bleu", "r,s,l", "dli $at,%2;bltu $at,%1,:0f", 0, 0, 0},
+{0, 0, "bleul", "r,r,l", "bltu %2,%1,:0f", 0, 0, 0},
+{0, 0, "bleul", "r,s,l", "dli $at,%2;bltu $at,%1,:0f", 0, 0, 0},
+{0, 0, "bge", "r,r,l", "blt %1,%2,:0f", 0, 0, 0},
+{0, 0, "bge", "r,s,l", "dli $at,%2;blt %1,$at,:0f", 0, 0, 0},
+{0, 0, "bgel", "r,r,l", "blt %1,%2,:0f", 0, 0, 0},
+{0, 0, "bgel", "r,s,l", "dli $at,%2;blt %1,$at,:0f", 0, 0, 0},
+{0, 0, "bgeu", "r,r,l", "bltu %1,%2,:0f", 0, 0, 0},
+{0, 0, "bgeu", "r,s,l", "dli $at,%2;bltu %1,$at,:0f", 0, 0, 0},
+{0, 0, "bgeul", "r,r,l", "bltu %1,%2,:0f", 0, 0, 0},
+{0, 0, "bgeul", "r,s,l", "dli $at,%2;bltu %1,$at,:0f", 0, 0, 0},
+{0, 0, "blt", "r,r,l", "bge %1,%2,:0f", 0, 0, 0},
+{0, 0, "blt", "r,s,l", "dli $at,%2;bge %1,$at,:0f", 0, 0, 0},
+{0, 0, "bltl", "r,r,l", "bge %1,%2,:0f", 0, 0, 0},
+{0, 0, "bltl", "r,s,l", "dli $at,%2;bge %1,$at,:0f", 0, 0, 0},
+{0, 0, "bltu", "r,r,l", "bgeu %1,%2,:0f", 0, 0, 0},
+{0, 0, "bltu", "r,s,l", "dli $at,%2;bgeu %1,$at,:0f", 0, 0, 0},
+{0, 0, "bltul", "r,r,l", "bgeu %1,%2,:0f", 0, 0, 0},
+{0, 0, "bltul", "r,s,l", "dli $at,%2;bgeu %1,$at,:0f", 0, 0, 0},
+{0, 0, "bgt", "r,r,l", "bge %2,%1,:0f", 0, 0, 0},
+{0, 0, "bgt", "r,s,l", "dli $at,%2;bge $at,%1,:0f", 0, 0, 0},
+{0, 0, "bgtl", "r,r,l", "bge %2,%1,:0f", 0, 0, 0},
+{0, 0, "bgtl", "r,s,l", "dli $at,%2;bge $at,%1,:0f", 0, 0, 0},
+{0, 0, "bgtu", "r,r,l", "bgeu %2,%1,:0f", 0, 0, 0},
+{0, 0, "bgtu", "r,s,l", "dli $at,%2;bgeu $at,%1,:0f", 0, 0, 0},
+{0, 0, "bgtul", "r,r,l", "bgeu %2,%1,:0f", 0, 0, 0},
+{0, 0, "bgtul", "r,s,l", "dli $at,%2;bgeu $at,%1,:0f", 0, 0, 0},
+{0, 0, "beqz", "r,l", "bnez %1,:0f", 0, 0, 0},
+{0, 0, "beqzl", "r,l", "bnez %1,:0f", 0, 0, 0},
+{0, 0, "bnez", "r,l", "beqz %1,:0f", 0, 0, 0},
+{0, 0, "bnezl", "r,l", "beqz %1,:0f", 0, 0, 0},
+{0, 0, "blez", "r,l", "blt $r0,%1,:0f", 0, 0, 0},
+{0, 0, "blezl", "r,l", "blt $r0,%1,:0f", 0, 0, 0},
+{0, 0, "bgez", "r,l", "blt %1,$r0,:0f", 0, 0, 0},
+{0, 0, "bgezl", "r,l", "blt %1,$r0,:0f", 0, 0, 0},
+{0, 0, "bltz", "r,l", "bge %1,$r0,:0f", 0, 0, 0},
+{0, 0, "bltzl", "r,l", "bge %1,$r0,:0f", 0, 0, 0},
+{0, 0, "bgtz", "r,l", "bge $r0,%1,:0f", 0, 0, 0},
+{0, 0, "bgtzl", "r,l", "bge $r0,%1,:0f", 0, 0, 0},
+{0, 0, "j", "r", "", 0, 0, 0},
+{0, 0, "j", "l", "", 0, 0, 0},
+{0, 0, "jr", "r", "", 0, 0, 0},
+{0, 0, "jal", "r", "", 0, 0, 0},
+{0, 0, "jal", "l", "", 0, 0, 0},
+{0, 0, "jalr", "r,r", "", 0, &LARCH_opts.abi_is_lp64, 0},
+{0, 0, "jalr", "r", "", 0, 0, 0},
+{0} /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_MIPS_fix_opcodes[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+
+{0, 0, "la", "rc,la", "la %1,%2", 0, 0, 0},
+{0, 0, "dla", "rc,la", "la %1,%2", 0, 0, 0},
+{0, 0, "li", "rc,s", "li %1,%2;", 0, 0, 0},
+{0, 0, "dli", "rc,s", "dli %1,%2", 0, 0, 0},
+
+{0, 0, "lui", "rc,u", "li %1,(%2)<<16;", 0, 0, 0},
+{0, 0, "move", "rc,r", "or %1,%2,$r0", 0, 0, 0},
+{0, 0, "movz", "rc,r,r", "bnez %3,:1f;or %1,%2,$r0;:1:;", 0, 0, 0},
+{0, 0, "movn", "rc,r,r", "beqz %3,:1f;or %1,%2,$r0;:1:;", 0, 0, 0},
+
+{0, 0, "rdhwr", "rc,r", "%f", 0, 0, 0},
+{0, 0, "sync", "", "dbar 0", 0, 0, 0},
+{0, 0, "break", "", "break 0", 0, 0, 0},
+{0, 0, "break", "u0:10", "break %1", 0, 0, 0},
+{0, 0, "sdbbp", "u", "dbgcall %1", 0, 0, 0},
+{0, 0, "syscall", "", "syscall 0", 0, 0, 0},
+{0, 0, "pref", "u,s,r", "", 0, 0, 0},
+{0, 0, "tlt", "r,r", "bge %1,%2,:1f;break 7;:1:;", 0, 0, 0},
+{0, 0, "tlt", "r,s", "dli $at,%2;bge %1,$at,:1f;break 7;:1:;", 0, 0, 0},
+{0, 0, "teq", "r,r", "bne %1,%2,:1f;break 7;:1:;", 0, 0, 0},
+{0, 0, "teq", "r,s", "dli $at,%2;bne %1,$at,:1f;break 7;:1:;", 0, 0, 0},
+{0, 0, "teq", "r,r,u", "bne %1,%2,:1f;break %3;:1:;", 0, 0, 0},
+{0, 0, "tne", "r,r", "beq %1,%2,:1f;break 7;:1:;", 0, 0, 0},
+{0, 0, "tne", "r,s", "dli $at,%2;beq %1,$at,:1f;break 7;:1:;", 0, 0, 0},
+
+{0, 0, "nop", "", "nop", 0, 0, 0},
+
+{0, 0, "lb", "rc,s0:12,r", "ld.b %1,%3,%2", 0, 0, 0},
+{0, 0, "lb", "rc,s,r", "dli $at,%2;add.d $at,$at,%3;ld.b %1,$at,0", 0, 0, 0},
+{0, 0, "lb", "rc,la", "la $at,%2;ld.b %1,$at,0", 0, 0, 0},
+{0, 0, "lh", "rc,s0:12,r", "ld.h %1,%3,%2", 0, 0, 0},
+{0, 0, "lh", "rc,s,r", "dli $at,%2;add.d $at,$at,%3;ld.h %1,$at,0", 0, 0, 0},
+{0, 0, "lh", "rc,la", "la $at,%2;ld.h %1,$at,0", 0, 0, 0},
+{0, 0, "lw", "rc,s0:12,r", "ld.w %1,%3,%2", 0, 0, 0},
+{0, 0, "lw", "rc,s,r", "dli $at,%2;add.d $at,$at,%3;ld.w %1,$at,0", 0, 0, 0},
+{0, 0, "lw", "rc,la", "la $at,%2;ld.w %1,$at,0", 0, 0, 0},
+{0, 0, "ld", "rc,s0:12,r", "ld.d %1,%3,%2", 0, 0, 0},
+{0, 0, "ld", "rc,s,r", "dli $at,%2;add.d $at,$at,%3;ld.d %1,$at,0", 0, 0, 0},
+{0, 0, "ld", "rc,la", "la $at,%2;ld.d %1,$at,0", 0, 0, 0},
+{0, 0, "sb", "r,s0:12,r", "st.b %1,%3,%2", 0, 0, 0},
+{0, 0, "sb", "r,s,r", "dli $at,%2;add.d $at,$at,%3;st.b %1,$at,0", 0, 0, 0},
+{0, 0, "sb", "r,la", "la $at,%2;st.b %1,$at,0", 0, 0, 0},
+{0, 0, "sh", "r,s0:12,r", "st.h %1,%3,%2", 0, 0, 0},
+{0, 0, "sh", "r,s,r", "dli $at,%2;add.d $at,$at,%3;st.h %1,$at,0", 0, 0, 0},
+{0, 0, "sh", "r,la", "la $at,%2;st.h %1,$at,0", 0, 0, 0},
+{0, 0, "sw", "r,s0:12,r", "st.w %1,%3,%2", 0, 0, 0},
+{0, 0, "sw", "r,s,r", "dli $at,%2;add.d $at,$at,%3;st.w %1,$at,0", 0, 0, 0},
+{0, 0, "sw", "r,la", "la $at,%2;st.w %1,$at,0", 0, 0, 0},
+{0, 0, "sd", "r,s0:12,r", "st.d %1,%3,%2", 0, 0, 0},
+{0, 0, "sd", "r,s,r", "dli $at,%2;add.d $at,$at,%3;st.d %1,$at,0", 0, 0, 0},
+{0, 0, "sd", "r,la", "la $at,%2;st.d %1,$at,0", 0, 0, 0},
+{0, 0, "lbu", "rc,s0:12,r", "ld.bu %1,%3,%2", 0, 0, 0},
+{0, 0, "lbu", "rc,s,r", "dli $at,%2;add.d $at,$at,%3;ld.bu %1,$at,0", 0, 0, 0},
+{0, 0, "lbu", "rc,la", "la $at,%2;ld.bu %1,$at,0", 0, 0, 0},
+{0, 0, "lhu", "rc,s0:12,r", "ld.hu %1,%3,%2", 0, 0, 0},
+{0, 0, "lhu", "rc,s,r", "dli $at,%2;add.d $at,$at,%3;ld.hu %1,$at,0", 0, 0, 0},
+{0, 0, "lhu", "rc,la", "la $at,%2;ld.hu %1,$at,0", 0, 0, 0},
+{0, 0, "lwu", "rc,s0:12,r", "ld.wu %1,%3,%2", 0, 0, 0},
+{0, 0, "lwu", "rc,s,r", "dli $at,%2;add.d $at,$at,%3;ld.wu %1,$at,0", 0, 0, 0},
+{0, 0, "lwu", "rc,la", "la $at,%2;ld.wu %1,$at,0", 0, 0, 0},
+{0, 0, "lwl", "rc,s0:12,r", "ldl.w %1,%3,%2", 0, 0, 0},
+{0, 0, "lwl", "rc,s,r", "dli $at,%2;add.d $at,$at,%3;ldl.w %1,$at,0", 0, 0, 0},
+{0, 0, "lwl", "rc,la", "la $at,%2;ldl.w %1,$at,0", 0, 0, 0},
+{0, 0, "lwr", "rc,s0:12,r", "ldr.w %1,%3,%2", 0, 0, 0},
+{0, 0, "lwr", "rc,s,r", "dli $at,%2;add.d $at,$at,%3;ldr.w %1,$at,0", 0, 0, 0},
+{0, 0, "lwr", "rc,la", "la $at,%2;ldr.w %1,$at,0", 0, 0, 0},
+{0, 0, "ldl", "rc,s0:12,r", "ldl.d %1,%3,%2", 0, 0, 0},
+{0, 0, "ldl", "rc,s,r", "dli $at,%2;add.d $at,$at,%3;ldl.d %1,$at,0", 0, 0, 0},
+{0, 0, "ldl", "rc,la", "la $at,%2;ldl.d %1,$at,0", 0, 0, 0},
+{0, 0, "ldr", "rc,s0:12,r", "ldr.d %1,%3,%2", 0, 0, 0},
+{0, 0, "ldr", "rc,s,r", "dli $at,%2;add.d $at,$at,%3;ldr.d %1,$at,0", 0, 0, 0},
+{0, 0, "ldr", "rc,la", "la $at,%2;ldr.d %1,$at,0", 0, 0, 0},
+{0, 0, "swl", "r,s0:12,r", "stl.w %1,%3,%2", 0, 0, 0},
+{0, 0, "swl", "r,s,r", "dli $at,%2;add.d $at,$at,%3;stl.w %1,$at,0", 0, 0, 0},
+{0, 0, "swl", "r,la", "la $at,%2;stl.w %1,$at,0", 0, 0, 0},
+{0, 0, "swr", "r,s0:12,r", "str.w %1,%3,%2", 0, 0, 0},
+{0, 0, "swr", "r,s,r", "dli $at,%2;add.d $at,$at,%3;str.w %1,$at,0", 0, 0, 0},
+{0, 0, "swr", "r,la", "la $at,%2;str.w %1,$at,0", 0, 0, 0},
+{0, 0, "sdl", "r,s0:12,r", "stl.d %1,%3,%2", 0, 0, 0},
+{0, 0, "sdl", "r,s,r", "dli $at,%2;add.d $at,$at,%3;stl.d %1,$at,0", 0, 0, 0},
+{0, 0, "sdl", "r,la", "la $at,%2;stl.d %1,$at,0", 0, 0, 0},
+{0, 0, "sdr", "r,s0:12,r", "str.d %1,%3,%2", 0, 0, 0},
+{0, 0, "sdr", "r,s,r", "dli $at,%2;add.d $at,$at,%3;str.d %1,$at,0", 0, 0, 0},
+{0, 0, "sdr", "r,la", "la $at,%2;str.d %1,$at,0", 0, 0, 0},
+
+{0, 0, "ll", "r,s0:14<<2,r", "ll.w %1,%3,%2", 0, 0, 0},
+{0, 0, "ll", "r,s,r", "dli $at,%2;add.d $at,$at,%3;ll.w %1,$at,0", 0, 0, 0},
+{0, 0, "ll", "r,la", "la $at,%2;ll.w %1,$at,0", 0, 0, 0},
+{0, 0, "sc", "r,s0:14<<2,r", "sc.w %1,%3,%2", 0, 0, 0},
+{0, 0, "sc", "r,s,r", "dli $at,%2;add.d $at,$at,%3;sc.w %1,$at,0", 0, 0, 0},
+{0, 0, "sc", "r,la", "la $at,%2;sc.w %1,$at,0", 0, 0, 0},
+{0, 0, "lld", "r,s0:14<<2,r", "ll.d %1,%3,%2", 0, 0, 0},
+{0, 0, "lld", "r,s,r", "dli $at,%2;add.d $at,$at,%3;ll.d %1,$at,0", 0, 0, 0},
+{0, 0, "lld", "r,la", "la $at,%2;ll.d %1,$at,0", 0, 0, 0},
+{0, 0, "scd", "r,s0:14<<2,r", "sc.d %1,%3,%2", 0, 0, 0},
+{0, 0, "scd", "r,s,r", "dli $at,%2;add.d $at,$at,%3;sc.d %1,$at,0", 0, 0, 0},
+{0, 0, "scd", "r,la", "la $at,%2;sc.d %1,$at,0", 0, 0, 0},
+
+{0, 0, "and", "rc,r,r", "and %1,%2,%3", 0, 0, 0},
+{0, 0, "and", "rc,r,u0:12", "andi %1,%2,%3", 0, 0, 0},
+{0, 0, "and", "rc,r,s", "dli $at,%3;and %1,%2,$at", 0, 0, 0},
+{0, 0, "and", "rc,r", "and %1,%1,%2", 0, 0, 0},
+{0, 0, "and", "rc,u0:12", "andi %1,%1,%2", 0, 0, 0},
+{0, 0, "and", "rc,s", "dli $at,%2;and %1,%1,$at", 0, 0, 0},
+{0, 0, "andi", "rc,r,u0:12", "andi %1,%2,%3", 0, 0, 0},
+{0, 0, "andi", "rc,r,u0:16", "dli $at,%3;and %1,%2,$at", 0, 0, 0},
+{0, 0, "andi", "rc,r,u", "throw_error overflow_%3", 0, 0, 0},
+{0, 0, "andi", "rc,u0:12", "andi %1,%1,%2", 0, 0, 0},
+{0, 0, "andi", "rc,u0:16", "dli $at,%2;and %1,%1,$at", 0, 0, 0},
+{0, 0, "andi", "rc,u", "throw_error overflow_%2", 0, 0, 0},
+{0, 0, "or", "rc,r,r", "or %1,%2,%3", 0, 0, 0},
+{0, 0, "or", "rc,r,u0:12", "ori %1,%2,%3", 0, 0, 0},
+{0, 0, "or", "rc,r,u", "dli $at,%3;or %1,%2,$at", 0, 0, 0},
+{0, 0, "or", "rc,r", "or %1,%1,%2", 0, 0, 0},
+{0, 0, "or", "rc,u0:12", "ori %1,%1,%2", 0, 0, 0},
+{0, 0, "or", "rc,u", "dli $at,%2;or %1,%1,$at", 0, 0, 0},
+{0, 0, "ori", "rc,r,u0:12", "ori %1,%2,%3", 0, 0, 0},
+{0, 0, "ori", "rc,r,u0:16", "dli $at,%3;or %1,%2,$at", 0, 0, 0},
+{0, 0, "ori", "rc,r,u", "throw_error overflow_%3", 0, 0, 0},
+{0, 0, "ori", "rc,u0:12", "ori %1,%1,%2", 0, 0, 0},
+{0, 0, "ori", "rc,u0:16", "dli $at,%2;or %1,%1,$at", 0, 0, 0},
+{0, 0, "ori", "rc,u", "throw_error overflow_%2", 0, 0, 0},
+{0, 0, "xor", "rc,r,r", "xor %1,%2,%3", 0, 0, 0},
+{0, 0, "xor", "rc,r,u0:12", "xori %1,%2,%3", 0, 0, 0},
+{0, 0, "xor", "rc,r,u", "dli $at,%3;xor %1,%2,$at", 0, 0, 0},
+{0, 0, "xor", "rc,r", "xor %1,%1,%2", 0, 0, 0},
+{0, 0, "xor", "rc,u0:12", "xori %1,%1,%2", 0, 0, 0},
+{0, 0, "xor", "rc,u", "dli $at,%2;xor %1,%1,$at", 0, 0, 0},
+{0, 0, "xori", "rc,r,u0:12", "xori %1,%2,%3", 0, 0, 0},
+{0, 0, "xori", "rc,r,u0:16", "dli $at,%3;xor %1,%2,$at", 0, 0, 0},
+{0, 0, "xori", "rc,r,u", "xori %1,%2,%3", 0, 0, 0},
+{0, 0, "xori", "rc,u0:12", "xori %1,%1,%2", 0, 0, 0},
+{0, 0, "xori", "rc,u0:16", "dli $at,%2;xor %1,%1,$at", 0, 0, 0},
+{0, 0, "xori", "rc,u", "xori %1,%1,%2", 0, 0, 0},
+{0, 0, "not", "rc,r", "nor %1,%2,$r0", 0, 0, 0},
+{0, 0, "not", "rc", "nor %1,%1,$r0", 0, 0, 0},
+{0, 0, "nor", "rc,r,r", "nor %1,%2,%3", 0, 0, 0},
+
+{0, 0, "clo", "rc,r", "clo.w %1,%2", 0, 0, 0},
+{0, 0, "clz", "rc,r", "clz.w %1,%2", 0, 0, 0},
+{0, 0, "cto", "rc,r", "cto.w %1,%2", 0, 0, 0},
+{0, 0, "ctz", "rc,r", "ctz.w %1,%2", 0, 0, 0},
+{0, 0, "dclo", "rc,r", "clo.d %1,%2", 0, 0, 0},
+{0, 0, "dclz", "rc,r", "clz.d %1,%2", 0, 0, 0},
+{0, 0, "dcto", "rc,r", "cto.d %1,%2", 0, 0, 0},
+{0, 0, "dctz", "rc,r", "ctz.d %1,%2", 0, 0, 0},
+{0, 0, "wsbh", "rc,r", "revb.2h %1,%2", 0, 0, 0},
+{0, 0, "dsbh", "rc,r", "revb.4h %1,%2", 0, 0, 0},
+{0, 0, "dshd", "rc,r", "revh.d %1,%2", 0, 0, 0},
+{0, 0, "bitswap", "rc,r", "bitrev.4b %1,%2", 0, 0, 0},
+{0, 0, "dbitdwap", "rc,r", "bitrev.8b %1,%2", 0, 0, 0},
+{0, 0, "seh", "rc,r", "ext.w.h %1,%2", 0, 0, 0},
+{0, 0, "seb", "rc,r", "ext.w.b %1,%2", 0, 0, 0},
+
+{0, 0, "slt", "rc,r,r", "slt %1,%2,%3", 0, 0, 0},
+{0, 0, "slt", "rc,r,s0:12", "slti %1,%2,%3", 0, 0, 0},
+{0, 0, "slt", "rc,r,s", "dli $at,%3;slt %1,%2,$at", 0, 0, 0},
+{0, 0, "slti", "rc,r,s0:12", "slti %1,%2,%3", 0, 0, 0},
+{0, 0, "slti", "rc,r,s0:16", "dli $at,%3;slt %1,%2,$at", 0, 0, 0},
+{0, 0, "slti", "rc,r,u0:16", "li $at,(%3)-0x10000;slt %1,%2,$at", 0, 0, 0},
+{0, 0, "slti", "rc,r,s", "throw_error 3rd_arg_overflow", 0, 0, 0},
+{0, 0, "sltu", "rc,r,r", "sltu %1,%2,%3", 0, 0, 0},
+{0, 0, "sltu", "rc,r,s0:12", "sltui %1,%2,%3", 0, 0, 0},
+{0, 0, "sltu", "rc,r,s", "dli $at,%3;sltu %1,%2,$at", 0, 0, 0},
+{0, 0, "sltiu", "rc,r,s0:12", "sltui %1,%2,%3", 0, 0, 0},
+{0, 0, "sltiu", "rc,r,s0:16", "dli $at,%3;sltu %1,%2,$at", 0, 0, 0},
+{0, 0, "sltiu", "rc,r,u0:16", "li $at,(%3)-0x10000;sltu %1,%2,$at", 0, 0, 0},
+{0, 0, "sltiu", "rc,r,s", "throw_error 3rd_arg_overflow", 0, 0, 0},
+{0, 0, "sgt", "rc,r,r", "slt %1,%3,%2", 0, 0, 0},
+{0, 0, "sgt", "rc,r,s", "dli $at,%3;slt %1,$at,%2", 0, 0, 0},
+{0, 0, "sgtu", "rc,r,r", "sltu %1,%3,%2", 0, 0, 0},
+{0, 0, "sgtu", "rc,r,s", "dli $at,%3;sltu %1,$at,%2", 0, 0, 0},
+{0, 0, "sle", "rc,r,r", "slt %1,%3,%2;xori %1,%1,1", 0, 0, 0},
+{0, 0, "sle", "rc,r,s", "dli $at,%3;slt %1,$at,%2;xori %1,%1,1", 0, 0, 0},
+{0, 0, "sleu", "rc,r,r", "sltu %1,%3,%2;xori %1,%1,1", 0, 0, 0},
+{0, 0, "sleu", "rc,r,s", "dli $at,%3;sltu %1,$at,%2;xori %1,%1,1", 0, 0, 0},
+{0, 0, "sge", "rc,r,r", "slt %1,%2,%3;xori %1,%1,1", 0, 0, 0},
+{0, 0, "sge", "rc,r,s0:12", "slti %1,%2,%3;xori %1,%1,1", 0, 0, 0},
+{0, 0, "sge", "rc,r,s", "dli $at,%3;slt %1,%2,$at;xori %1,%1,1", 0, 0, 0},
+{0, 0, "sgeu", "rc,r,r", "sltu %1,%2,%3;xori %1,%1,1", 0, 0, 0},
+{0, 0, "sgeu", "rc,r,s0:12", "sltui %1,%2,%3;xori %1,%1,1", 0, 0, 0},
+{0, 0, "sgeu", "rc,r,s", "dli $at,%3;sltu %1,%2,$at;xori %1,%1,1", 0, 0, 0},
+{0, 0, "sne", "rc,r,r", "xor %1,%2,%3;sltu %1,$r0,%1", 0, 0, 0},
+{0, 0, "sne", "rc,r,s", "dli $at,%3;xor %1,%2,$at;sltu %1,$r0,%1", 0, 0, 0},
+{0, 0, "seq", "rc,r,r", "xor %1,%2,%3;sltui %1,%1,1", 0, 0, 0},
+{0, 0, "seq", "rc,r,s", "dli $at,%3;xor %1,%2,$at;sltui %1,%1,1", 0, 0, 0},
+
+{0, 0, "add", "rc,r,r",
+"add.w $at,%2,%3;"
+"bge %3,$r0,:1f;"
+"bge %2,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":1:;"
+"blt %2,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "add", "rc,r,u",
+"li $at,%3;"
+"add.w $at,%2,$at;"
+"blt %2,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "add", "rc,r,s",
+"li $at,%3;"
+"add.w $at,%2,$at;"
+"bge %2,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "add", "rc,r",
+"add.w $at,%1,%2;"
+"bge %2,$r0,:1f;"
+"bge %1,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":1:;"
+"blt %1,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "addi", "rc,r,u0:15",
+"li $at,%3;"
+"add.w $at,%2,$at;"
+"blt %2,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "addi", "rc,r,u0:16",
+"li $at,(%3)-0x10000;"
+"add.w $at,%2,$at;"
+"bge %2,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "addi", "rc,r,s0:16",
+"li $at,%3;"
+"add.w $at,%2,$at;"
+"bge %2,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "addi", "rc,r,s", "throw_error 3rd_arg_overflow", 0, 0, 0},
+
+{0, 0, "addi", "rc,u0:15",
+"li $at,%2;"
+"add.w $at,%1,$at;"
+"blt %1,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "addi", "rc,u0:16",
+"li $at,(%2)-0x10000;"
+"add.w $at,%1,$at;"
+"bge %1,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "addi", "rc,s0:16",
+"li $at,%2;"
+"add.w $at,%1,$at;"
+"bge %1,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "addi", "rc,s", "throw_error 2nd_arg_overflow", 0, 0, 0},
+
+{0, 0, "addu", "rc,r,r", "add.w %1,%2,%3", 0, 0, 0},
+{0, 0, "addu", "rc,r,s0:12", "addi.w %1,%2,%3", 0, 0, 0},
+{0, 0, "addu", "rc,r,s", "li $at,%3;add.w %1,%2,$at", 0, 0, 0},
+{0, 0, "addu", "rc,r", "add.w %1,%1,%2", 0, 0, 0},
+{0, 0, "addu", "rc,s0:12", "addi.w %1,%1,%2", 0, 0, 0},
+{0, 0, "addu", "rc,s", "li $at,%2;add.w %1,%1,$at", 0, 0, 0},
+{0, 0, "addiu", "rc,r,s0:12", "addi.w %1,%2,%3", 0, 0, 0},
+{0, 0, "addiu", "rc,r,s0:16", "li $at,%3;add.w %1,%2,$at", 0, 0, 0},
+{0, 0, "addiu", "rc,r,u0:16", "li $at,(%3)-0x10000;add.w %1,%2,$at", 0, 0, 0},
+{0, 0, "addiu", "rc,r,s", "throw_error 3rd_arg_overflow", 0, 0, 0},
+{0, 0, "addiu", "rc,s0:12", "addi.w %1,%1,%2", 0, 0, 0},
+{0, 0, "addiu", "rc,s0:16", "li $at,%2;add.w %1,%1,$at", 0, 0, 0},
+{0, 0, "addiu", "rc,u0:16", "li $at,(%2)-0x10000;add.w %1,%1,$at", 0, 0, 0},
+{0, 0, "addiu", "rc,s", "throw_error 2nd_arg_overflow", 0, 0, 0},
+
+{0, 0, "dadd", "rc,r,r",
+"add.d $at,%2,%3;"
+"bge %3,$r0,:1f;"
+"bge %2,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":1:;"
+"blt %2,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, &LARCH_opts.rlen_is_64, 0, 0},
+
+{0, 0, "dadd", "rc,r,u",
+"dli $at,%3;"
+"add.d $at,%2,$at;"
+"blt %2,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, &LARCH_opts.rlen_is_64, 0, 0},
+
+{0, 0, "dadd", "rc,r,s",
+"dli $at,%3;"
+"add.d $at,%2,$at;"
+"bge %2,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, &LARCH_opts.rlen_is_64, 0, 0},
+
+{0, 0, "dadd", "rc,r",
+"add.d $at,%1,%2;"
+"bge %2,$r0,:1f;"
+"bge %1,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":1:;"
+"blt %1,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, &LARCH_opts.rlen_is_64, 0, 0},
+
+{0, 0, "daddi", "rc,r,u0:15",
+"dli $at,%3;"
+"add.d $at,%2,$at;"
+"blt %2,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, &LARCH_opts.rlen_is_64, 0, 0},
+
+{0, 0, "daddi", "rc,r,u0:16",
+"dli $at,(%3)-0x10000;"
+"add.d $at,%2,$at;"
+"bge %2,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, &LARCH_opts.rlen_is_64, 0, 0},
+
+{0, 0, "daddi", "rc,r,s0:16",
+"dli $at,%3;"
+"add.d $at,%2,$at;"
+"bge %2,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, &LARCH_opts.rlen_is_64, 0, 0},
+
+{0, 0, "daddi", "rc,r,s", "throw_error 3rd_arg_overflow", &LARCH_opts.rlen_is_64, 0, 0},
+
+{0, 0, "daddi", "rc,u0:15",
+"dli $at,%2;"
+"add.d $at,%1,$at;"
+"blt %1,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "daddi", "rc,u0:16",
+"dli $at,(%2)-0x10000;"
+"add.d $at,%1,$at;"
+"bge %1,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "daddi", "rc,s0:16",
+"dli $at,%2;"
+"add.d $at,%1,$at;"
+"bge %1,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "daddi", "rc,s", "throw_error 2nd_arg_overflow", 0, 0, 0},
+
+{0, 0, "daddu", "rc,r,r", "add.d %1,%2,%3", 0, 0, 0},
+{0, 0, "daddu", "rc,r,s0:12", "addi.d %1,%2,%3", 0, 0, 0},
+{0, 0, "daddu", "rc,r,s", "li $at,%3;add.d %1,%2,$at", 0, 0, 0},
+{0, 0, "daddu", "rc,r", "add.d %1,%1,%2", 0, 0, 0},
+{0, 0, "daddu", "rc,s0:12", "addi.d %1,%1,%2", 0, 0, 0},
+{0, 0, "daddu", "rc,s", "li $at,%2;add.d %1,%1,$at", 0, 0, 0},
+{0, 0, "daddiu", "rc,r,s0:12", "addi.d %1,%2,%3", 0, 0, 0},
+{0, 0, "daddiu", "rc,r,s0:16", "li $at,%3;add.d %1,%2,$at", 0, 0, 0},
+{0, 0, "daddiu", "rc,r,u0:16", "li $at,(%3)-0x10000;add.d %1,%2,$at", 0, 0, 0},
+{0, 0, "daddiu", "rc,r,s", "throw_error 3rd_arg_overflow", 0, 0, 0},
+{0, 0, "daddiu", "rc,s0:12", "addi.d %1,%1,%2", 0, 0, 0},
+{0, 0, "daddiu", "rc,s0:16", "li $at,%2;add.d %1,%1,$at", 0, 0, 0},
+{0, 0, "daddiu", "rc,u0:16", "li $at,(%2)-0x10000;add.d %1,%1,$at", 0, 0, 0},
+{0, 0, "daddiu", "rc,s", "throw_error 2nd_arg_overflow", 0, 0, 0},
+
+{0, 0, "sub", "rc,r,r",
+"sub.w $at,%2,%3;"
+"blt %3,$r0,:1f;"
+"bge %2,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":1:;"
+"blt %2,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "sub", "rc,r,u",
+"li $at,%3;"
+"sub.w $at,%2,$at;"
+"bge %2,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "sub", "rc,r,s",
+"li $at,%3;"
+"sub.w $at,%2,$at;"
+"blt %2,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "sub", "rc,r",
+"sub.w $at,%1,%2;"
+"blt %2,$r0,:1f;"
+"bge %1,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":1:;"
+"blt %1,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "subu", "rc,r,r", "sub.w %1,%2,%3", 0, 0, 0},
+{0, 0, "subu", "rc,r,s", "li $at,%3;sub.w %1,%2,$at", 0, 0, 0},
+{0, 0, "subu", "rc,r", "sub.w %1,%1,%2", 0, 0, 0},
+{0, 0, "subu", "rc,s", "li $at,%2;sub.w %1,%1,$at", 0, 0, 0},
+
+{0, 0, "neg", "rc,r",
+"li $at,0x80000000;"
+"bne $at,%2,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"sub.w %1,$r0,%2;"
+":3:;"
+, 0, 0, 0},
+{0, 0, "negu", "rc,r", "sub.w %1,$r0,%2", 0, 0, 0},
+
+{0, 0, "dsub", "rc,r,r",
+"sub.d $at,%2,%3;"
+"blt %3,$r0,:1f;"
+"bge %2,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":1:;"
+"blt %2,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "dsub", "rc,r,u",
+"dli $at,%3;"
+"sub.d $at,%2,$at;"
+"bge %2,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "dsub", "rc,r,s",
+"dli $at,%3;"
+"sub.d $at,%2,$at;"
+"blt %2,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "dsub", "rc,r",
+"sub.d $at,%1,%2;"
+"blt %2,$r0,:1f;"
+"bge %1,$r0,:2f;"
+"blt $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":1:;"
+"blt %1,$r0,:2f;"
+"bge $at,$r0,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"or %1,$at,$r0;"
+":3:;"
+, 0, 0, 0},
+
+{0, 0, "dsubu", "rc,r,r", "sub.d %1,%2,%3", 0, 0, 0},
+{0, 0, "dsubu", "rc,r,s", "dli $at,%3;sub.d %1,%2,$at", 0, 0, 0},
+{0, 0, "dsubu", "rc,r", "sub.d %1,%1,%2", 0, 0, 0},
+{0, 0, "dsubu", "rc,s", "dli $at,%2;sub.d %1,%1,$at", 0, 0, 0},
+
+{0, 0, "dneg", "rc,r",
+"dli $at,0x8000000000000000;"
+"bne $at,%2,:2f;"
+"break 6;"
+"b :3f;"
+":2:;"
+"sub.d %1,$r0,%2;"
+":3:;"
+, 0, 0, 0},
+{0, 0, "dnegu", "rc,r", "sub.d %1,$r0,%2", 0, 0, 0},
+
+{0, 0, "mthi", "r", "gr2scr $scr2,%1", 0, 0, 0},
+{0, 0, "mtlo", "r", "gr2scr $scr3,%1", 0, 0, 0},
+{0, 0, "mfhi", "rc", "scr2gr %1,$scr2", 0, 0, 0},
+{0, 0, "mflo", "rc", "scr2gr %1,$scr3", 0, 0, 0},
+
+{0, 0, "madd", "rz,r", "", 0, 0, 0},
+{0, 0, "madd", "r,rz", "", 0, 0, 0},
+{0, 0, "madd", "r,r",
+"gr2scr $scr0,%1;"
+"scr2gr $at,$scr3;"
+"scr2gr %1,$scr2;"
+"bstrins.d $at,%1,63,32;"
+"scr2gr %1,$scr0;"
+"mul.d %1,%1,%2;"
+"add.d $at,$at,%1;"
+"bstrins.d %1,$at,63,32;"
+"srai.d %1,%1,32;"
+"srai.d $at,$at,32;"
+"gr2scr $scr3,%1;"
+"gr2scr $scr2,$at;"
+"scr2gr %1,$scr0;"
+, 0, 0, 0},
+{0, 0, "msub", "rz,r", "", 0, 0, 0},
+{0, 0, "msub", "r,rz", "", 0, 0, 0},
+{0, 0, "msub", "r,r",
+"gr2scr $scr0,%1;"
+"scr2gr $at,$scr3;"
+"scr2gr %1,$scr2;"
+"bstrins.d $at,%1,63,32;"
+"scr2gr %1,$scr0;"
+"mul.d %1,%1,%2;"
+"sub.d $at,$at,%1;"
+"bstrins.d %1,$at,63,32;"
+"srai.d %1,%1,32;"
+"srai.d $at,$at,32;"
+"gr2scr $scr3,%1;"
+"gr2scr $scr2,$at;"
+"scr2gr %1,$scr0;"
+, 0, 0, 0},
+{0, 0, "maddu", "rz,r", "", 0, 0, 0},
+{0, 0, "maddu", "r,rz", "", 0, 0, 0},
+{0, 0, "maddu", "r,r",
+"gr2scr $scr0,%1;"
+"scr2gr $at,$scr3;"
+"scr2gr %1,$scr2;"
+"bstrins.d $at,%1,63,32;"
+"scr2gr %1,$scr0;"
+"gr2scr $scr2,%2;"
+"bstrpick.d %1,%1,31,0;"
+"bstrpick.d %2,%2,31,0;"
+"mul.d %1,%1,%2;"
+"add.d $at,$at,%1;"
+"scr2gr %2,$scr2;"
+"bstrins.d %1,$at,63,32;"
+"srai.d %1,%1,32;"
+"srai.d $at,$at,32;"
+"gr2scr $scr3,%1;"
+"gr2scr $scr2,$at;"
+"scr2gr %1,$scr0;"
+, 0, 0, 0},
+{0, 0, "msubu", "rz,r", "", 0, 0, 0},
+{0, 0, "msubu", "r,rz", "", 0, 0, 0},
+{0, 0, "msubu", "r,r",
+"gr2scr $scr0,%1;"
+"scr2gr $at,$scr3;"
+"scr2gr %1,$scr2;"
+"bstrins.d $at,%1,63,32;"
+"scr2gr %1,$scr0;"
+"gr2scr $scr2,%2;"
+"bstrpick.d %1,%1,31,0;"
+"bstrpick.d %2,%2,31,0;"
+"mul.d %1,%1,%2;"
+"sub.d $at,$at,%1;"
+"scr2gr %2,$scr2;"
+"bstrins.d %1,$at,63,32;"
+"srai.d %1,%1,32;"
+"srai.d $at,$at,32;"
+"gr2scr $scr3,%1;"
+"gr2scr $scr2,$at;"
+"scr2gr %1,$scr0;"
+, 0, 0, 0},
+
+{0, 0, "mul", "rc,r,r", "mul.w %1,%2,%3;", 0, 0, 0},
+{0, 0, "mul", "rc,r,s",
+"li $at,%3;mulh.w $at,%2,$at;gr2scr $scr2,$at;"
+"li $at,%3;mul.w $at,%2,$at;gr2scr $scr3,$at;"
+"or %1,$at,$r0;"
+, 0, 0, 0},
+{0, 0, "mul", "rc,s",
+"li $at,%2;mulh.w $at,%1,$at;gr2scr $scr2,$at;"
+"li $at,%2;mul.w $at,%1,$at;gr2scr $scr3,$at;"
+"or %1,$at,$r0;"
+, 0, 0, 0},
+{0, 0, "mulo", "rc,r,r",
+"mulh.w $at,%2,%3;"
+"gr2scr $scr2,$at;"
+"beqz $at,:2f;"
+"addi.w $at,$at,1;"
+"beqz $at,:3f;"
+":1:break 6;"
+"b :5f;"
+":2:;"
+"mul.w $at,%2,%3;"
+"gr2scr $scr3,$at;"
+"blt $at,$r0,:1b;"
+"b :4f;"
+":3:;"
+"mul.w $at,%2,%3;"
+"gr2scr $scr3,$at;"
+"bge $at,$r0,:1b;"
+":4:scr2gr %1,$scr3;"
+":5:;"
+, 0, 0, 0},
+{0, 0, "mulo", "rc,r,s",
+"li $at,%3;"
+"mulh.w $at,%2,$at;"
+"gr2scr $scr2,$at;"
+"beqz $at,:2f;"
+"addi.w $at,$at,1;"
+"beqz $at,:3f;"
+":1:break 6;"
+"b :5f;"
+":2:;"
+"li $at,%3;"
+"mul.w $at,%2,$at;"
+"gr2scr $scr3,$at;"
+"blt $at,$r0,:1b;"
+"b :4f;"
+":3:;"
+"li $at,%3;"
+"mul.w $at,%2,$at;"
+"gr2scr $scr3,$at;"
+"bge $at,$r0,:1b;"
+":4:scr2gr %1,$scr3;"
+":5:;"
+, 0, 0, 0},
+{0, 0, "mulou", "rc,r,r",
+"mulh.wu $at,%2,%3;gr2scr $scr2,$at;"
+"beqz $at,:1f;break 6;b :2f;"
+":1:mul.w $at,%2,%3;gr2scr $scr3,$at;"
+"or %1,$at,$r0;"
+":2:;"
+, 0, 0, 0},
+{0, 0, "mulou", "rc,r,s",
+"li $at,%3;mulh.wu $at,%2,$at;gr2scr $scr2,$at;"
+"beqz $at,:1f;break 6;b :2f;"
+":1:li $at,%3;mul.w $at,%2,$at;gr2scr $scr3,$at;"
+"or %1,$at,$r0;"
+":2:;"
+, 0, 0, 0},
+{0, 0, "mult", "rc,r",
+"mulh.w $at,%1,%2;gr2scr $scr2,$at;"
+"mul.w $at,%1,%2;gr2scr $scr3,$at;"
+, 0, 0, 0},
+{0, 0, "multu", "rc,r",
+"mulh.wu $at,%1,%2;gr2scr $scr2,$at;"
+"mul.w $at,%1,%2;gr2scr $scr3,$at;"
+, 0, 0, 0},
+
+{0, 0, "dmul", "rc,r,r",
+"mulh.du $at,%2,%3;gr2scr $scr2,$at;"
+"mul.d $at,%2,%3;gr2scr $scr3,$at;"
+"or %1,$at,$r0;"
+, 0, 0, 0},
+{0, 0, "dmul", "rc,r,s",
+"dli $at,%3;mulh.d $at,%2,$at;gr2scr $scr2,$at;"
+"dli $at,%3;mul.d $at,%2,$at;gr2scr $scr3,$at;"
+"or %1,$at,$r0;"
+, 0, 0, 0},
+{0, 0, "dmul", "rc,s",
+"dli $at,%2;mulh.d $at,%1,$at;gr2scr $scr2,$at;"
+"dli $at,%2;mul.d $at,%1,$at;gr2scr $scr3,$at;"
+"or %1,$at,$r0;"
+, 0, 0, 0},
+
+{0, 0, "dmulo", "rc,r,r",
+"mulh.d $at,%2,%3;"
+"gr2scr $scr2,$at;"
+"beqz $at,:2f;"
+"addi.d $at,$at,1;"
+"beqz $at,:3f;"
+":1:break 6;"
+"b :5f;"
+":2:;"
+"mul.d $at,%2,%3;"
+"gr2scr $scr3,$at;"
+"blt $at,$r0,:1b;"
+"b :4f;"
+":3:;"
+"mul.d $at,%2,%3;"
+"gr2scr $scr3,$at;"
+"bge $at,$r0,:1b;"
+":4:scr2gr %1,$scr3;"
+":5:;"
+, 0, 0, 0},
+{0, 0, "dmulo", "rc,r,s",
+"dli $at,%3;"
+"mulh.d $at,%2,$at;"
+"gr2scr $scr2,$at;"
+"beqz $at,:2f;"
+"addi.d $at,$at,1;"
+"beqz $at,:3f;"
+":1:break 6;"
+"b :5f;"
+":2:;"
+"dli $at,%3;"
+"mul.d $at,%2,$at;"
+"gr2scr $scr3,$at;"
+"blt $at,$r0,:1b;"
+"b :4f;"
+":3:;"
+"dli $at,%3;"
+"mul.d $at,%2,$at;"
+"gr2scr $scr3,$at;"
+"bge $at,$r0,:1b;"
+":4:scr2gr %1,$scr3;"
+":5:;"
+, 0, 0, 0},
+{0, 0, "dmulou", "rc,r,r",
+"mulh.du $at,%2,%3;gr2scr $scr2,$at;"
+"beqz $at,:1f;break 6;b :2f;"
+":1:mul.d $at,%2,%3;gr2scr $scr3,$at;"
+"or %1,$at,$r0;"
+":2:;"
+, 0, 0, 0},
+{0, 0, "dmulou", "rc,r,s",
+"dli $at,%3;mulh.du $at,%2,$at;gr2scr $scr2,$at;"
+"beqz $at,:1f;break 6;b :2f;"
+":1:dli $at,%3;mul.d $at,%2,$at;gr2scr $scr3,$at;"
+"or %1,$at,$r0;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "dmult", "rc,r",
+"mulh.d $at,%1,%2;gr2scr $scr2,$at;"
+"mul.d $at,%1,%2;gr2scr $scr3,$at;"
+, 0, 0, 0},
+{0, 0, "dmultu", "rc,r",
+"mulh.du $at,%1,%2;gr2scr $scr2,$at;"
+"mul.d $at,%1,%2;gr2scr $scr3,$at;"
+, 0, 0, 0},
+
+{0, 0, "div", "rz,r,r",
+"mod.w $at,%2,%3;gr2scr $scr2,$at;"
+"div.w $at,%2,%3;gr2scr $scr3,$at;"
+, 0, 0, 0},
+
+{0, 0, "div", "rc,r,r",
+"bnez %3,:1f;break 7;b :2f;"
+":1:;"
+"addi.w $at,%3,1;"
+"bnez $at,:1f;"
+"bge %2,$r0,:1f;"
+"addi.w $at,%2,-1;"
+"blt $at,$r0,:1f;"
+"break 6;b :2f;"
+":1:;"
+"mod.w $at,%2,%3;gr2scr $scr2,$at;"
+"div.w %1,%2,%3;gr2scr $scr3,%1;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "div", "rc,r,u0:0", "break 7;", 0, 0, 0},
+{0, 0, "div", "rc,r,u0:1", "or %1,%2,$r0;", 0, 0, 0},
+{0, 0, "div", "rc,r,s0:1",
+"bge %2,$r0,:1f;"
+"addi.w $at,%2,-1;"
+"blt $at,$r0,:1f;"
+"break 6;"
+"b :2f;"
+":1:;"
+"sub.w %1,$r0,%2;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "div", "rz,r,s",
+"li $at,%3;mod.w $at,%2,$at;gr2scr $scr2,$at;"
+"li $at,%3;div.w $at,%2,$at;gr2scr $scr3,$at;"
+, 0, 0, 0},
+
+{0, 0, "div", "rc,r,s",
+"li $at,%3;"
+"bnez $at,:1f;break 7;b :2f;"
+":1:;"
+"addi.w $at,$at,1;"
+"bnez $at,:1f;"
+"bge %2,$r0,:1f;"
+"addi.w $at,%2,-1;"
+"blt $at,$r0,:1f;"
+"break 6;b :2f;"
+":1:;"
+"li $at,%3;mod.w $at,%2,$at;gr2scr $scr2,$at;"
+"li $at,%3;div.w %1,%2,$at;gr2scr $scr3,%1;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "div", "rc,r",
+"bnez %2,:1f;break 7;b :2f;"
+":1:;"
+"addi.w $at,%2,1;"
+"bnez $at,:1f;"
+"bge %1,$r0,:1f;"
+"addi.w $at,%1,-1;"
+"blt $at,$r0,:1f;"
+"break 6;b :2f;"
+":1:;"
+"mod.w $at,%1,%2;gr2scr $scr2,$at;"
+"div.w %1,%1,%2;gr2scr $scr3,%1;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "div", "rc,u0:0", "break 7;", 0, 0, 0},
+{0, 0, "div", "rc,u0:1", "", 0, 0, 0},
+{0, 0, "div", "rc,s0:1",
+"bge %1,$r0,:1f;"
+"addi.w $at,%1,-1;"
+"blt $at,$r0,:1f;"
+"break 6;"
+"b :2f;"
+":1:;"
+"sub.w %1,$r0,%1;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "div", "rc,s",
+"li $at,%2;mod.w $at,%1,$at;gr2scr $scr2,$at;"
+"li $at,%2;div.w %1,%1,$at;gr2scr $scr3,%1;"
+, 0, 0, 0},
+
+{0, 0, "divu", "rz,r,r",
+"mod.wu $at,%2,%3;gr2scr $scr2,$at;"
+"div.wu $at,%2,%3;gr2scr $scr3,$at;"
+, 0, 0, 0},
+{0, 0, "divu", "rc,r,r",
+"bnez %3,:1f;break 7;b :2f;"
+":1:;mod.wu $at,%2,%3;gr2scr $scr2,$at;"
+"div.wu %1,%2,%3;gr2scr $scr3,%1;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "divu", "rc,r,u0:0", "break 7;", 0, 0, 0},
+{0, 0, "divu", "rc,r,u0:1", "or %1,%2,$r0;", 0, 0, 0},
+{0, 0, "divu", "rz,r,s",
+"li $at,%3;mod.wu $at,%2,$at;gr2scr $scr2,$at;"
+"li $at,%3;div.wu $at,%2,$at;gr2scr $scr3,$at;"
+, 0, 0, 0},
+{0, 0, "divu", "rc,r,s",
+"li $at,%3;mod.wu $at,%2,$at;gr2scr $scr2,$at;"
+"li $at,%3;div.wu %1,%2,$at;gr2scr $scr3,%1;"
+, 0, 0, 0},
+{0, 0, "divu", "rc,r",
+"bnez %2,:1f;break 7;b :2f;"
+":1:;mod.wu $at,%1,%2;gr2scr $scr2,$at;"
+"div.wu %1,%1,%2;gr2scr $scr3,%1;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "divu", "rc,u0:0", "break 7;", 0, 0, 0},
+{0, 0, "divu", "rc,u0:1", "", 0, 0, 0},
+{0, 0, "divu", "rc,s",
+"li $at,%2;mod.wu $at,%1,$at;gr2scr $scr2,$at;"
+"li $at,%2;div.wu %1,%1,$at;gr2scr $scr3,%1;"
+, 0, 0, 0},
+
+{0, 0, "ddiv", "rz,r,r",
+"mod.d $at,%2,%3;gr2scr $scr2,$at;"
+"div.d $at,%2,%3;gr2scr $scr3,$at;"
+, 0, 0, 0},
+{0, 0, "ddiv", "rc,r,r",
+"bnez %3,:1f;break 7;b :2f;"
+":1:;"
+"addi.d $at,%3,1;"
+"bnez $at,:1f;"
+"bge %2,$r0,:1f;"
+"addi.d $at,%2,-1;"
+"blt $at,$r0,:1f;"
+"break 6;b :2f;"
+":1:;"
+"mod.d $at,%2,%3;gr2scr $scr2,$at;"
+"div.d %1,%2,%3;gr2scr $scr3,%1;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "ddiv", "rc,r,u0:0", "break 7;", 0, 0, 0},
+{0, 0, "ddiv", "rc,r,u0:1", "or %1,%2,$r0;", 0, 0, 0},
+{0, 0, "ddiv", "rc,r,s0:1",
+"bge %2,$r0,:1f;"
+"addi.d $at,%2,-1;"
+"blt $at,$r0,:1f;"
+"break 6;"
+"b :2f;"
+":1:;"
+"sub.d %1,$r0,%2;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "ddiv", "rz,r,s",
+"dli $at,%3;mod.d $at,%2,$at;gr2scr $scr2,$at;"
+"dli $at,%3;div.d $at,%2,$at;gr2scr $scr3,$at;"
+, 0, 0, 0},
+
+{0, 0, "ddiv", "rc,r,s",
+"dli $at,%3;"
+"bnez $at,:1f;break 7;b :2f;"
+":1:;"
+"addi.d $at,$at,1;"
+"bnez $at,:1f;"
+"bge %2,$r0,:1f;"
+"addi.d $at,%2,-1;"
+"blt $at,$r0,:1f;"
+"break 6;b :2f;"
+":1:;"
+"dli $at,%3;mod.d $at,%2,$at;gr2scr $scr2,$at;"
+"dli $at,%3;div.d %1,%2,$at;gr2scr $scr3,%1;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "ddiv", "rc,r",
+"bnez %2,:1f;break 7;b :2f;"
+":1:;"
+"addi.d $at,%2,1;"
+"bnez $at,:1f;"
+"bge %1,$r0,:1f;"
+"addi.d $at,%1,-1;"
+"blt $at,$r0,:1f;"
+"break 6;b :2f;"
+":1:;"
+"mod.d $at,%1,%2;gr2scr $scr2,$at;"
+"div.d %1,%1,%2;gr2scr $scr3,%1;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "ddiv", "rc,u0:0", "break 7;", 0, 0, 0},
+{0, 0, "ddiv", "rc,u0:1", "", 0, 0, 0},
+{0, 0, "ddiv", "rc,s0:1",
+"bge %1,$r0,:1f;"
+"addi.d $at,%1,-1;"
+"blt $at,$r0,:1f;"
+"break 6;"
+"b :2f;"
+":1:;"
+"sub.d %1,$r0,%1;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "ddiv", "rc,s",
+"dli $at,%2;mod.d $at,%1,$at;gr2scr $scr2,$at;"
+"dli $at,%2;div.d %1,%1,$at;gr2scr $scr3,%1;"
+, 0, 0, 0},
+
+{0, 0, "ddivu", "rz,r,r",
+"mod.du $at,%2,%3;gr2scr $scr2,$at;"
+"div.du $at,%2,%3;gr2scr $scr3,$at;"
+, 0, 0, 0},
+{0, 0, "ddivu", "rc,r,r",
+"bnez %3,:1f;break 7;b :2f;"
+":1:;mod.du $at,%2,%3;gr2scr $scr2,$at;"
+"div.du %1,%2,%3;gr2scr $scr3,%1;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "ddivu", "rc,r,u0:0", "break 7;", 0, 0, 0},
+{0, 0, "ddivu", "rc,r,u0:1", "or %1,%2,$r0;", 0, 0, 0},
+{0, 0, "ddivu", "rz,r,s",
+"dli $at,%3;mod.du $at,%2,$at;gr2scr $scr2,$at;"
+"dli $at,%3;div.du $at,%2,$at;gr2scr $scr3,$at;"
+, 0, 0, 0},
+{0, 0, "ddivu", "rc,r,s",
+"dli $at,%3;mod.du $at,%2,$at;gr2scr $scr2,$at;"
+"dli $at,%3;div.du %1,%2,$at;gr2scr $scr3,%1;"
+, 0, 0, 0},
+
+{0, 0, "ddivu", "rc,r",
+"bnez %2,:1f;break 7;b :2f;"
+":1:;mod.du $at,%1,%2;gr2scr $scr2,$at;"
+"div.du %1,%1,%2;gr2scr $scr3,%1;"
+":2:;"
+, 0, 0, 0},
+
+{0, 0, "ddivu", "rc,u0:0", "break 7;", 0, 0, 0},
+{0, 0, "ddivu", "rc,u0:1", "", 0, 0, 0},
+{0, 0, "ddivu", "rc,s",
+"dli $at,%2;mod.du $at,%1,$at;gr2scr $scr2,$at;"
+"dli $at,%2;div.du %1,%1,$at;gr2scr $scr3,%1;"
+, 0, 0, 0},
+
+{0, 0, "sll", "rc,r,r", "sll.w %1,%2,%3", 0, 0, 0},
+{0, 0, "sll", "rc,r", "sll.w %1,%1,%2", 0, 0, 0},
+{0, 0, "sll", "rc,r,u", "slli.w %1,%2,%3", 0, 0, 0},
+{0, 0, "sll", "rc,u", "slli.w %1,%1,%2", 0, 0, 0},
+{0, 0, "sllv", "rc,r,r", "sll.w %1,%2,%3", 0, 0, 0},
+{0, 0, "dsll", "rc,r,r", "sll.d %1,%2,%3", 0, 0, 0},
+{0, 0, "dsll", "rc,r,u", "slli.d %1,%2,%3", 0, 0, 0},
+{0, 0, "dsll", "rc,r", "sll.d %1,%1,%2", 0, 0, 0},
+{0, 0, "dsll", "rc,u", "slli.d %1,%1,%2", 0, 0, 0},
+{0, 0, "srl", "rc,r,r", "srl.w %1,%2,%3", 0, 0, 0},
+{0, 0, "srl", "rc,r", "srl.w %1,%1,%2", 0, 0, 0},
+{0, 0, "srl", "rc,r,u", "srli.w %1,%2,%3", 0, 0, 0},
+{0, 0, "srl", "rc,u", "srli.w %1,%1,%2", 0, 0, 0},
+{0, 0, "dsrl", "rc,r,r", "srl.d %1,%2,%3", 0, 0, 0},
+{0, 0, "dsrl", "rc,r,u", "srli.d %1,%2,%3", 0, 0, 0},
+{0, 0, "dsrl", "rc,r", "srl.d %1,%1,%2", 0, 0, 0},
+{0, 0, "dsrl", "rc,u", "srli.d %1,%1,%2", 0, 0, 0},
+{0, 0, "sra", "rc,r,r", "sra.w %1,%2,%3", 0, 0, 0},
+{0, 0, "sra", "rc,r,u", "srai.w %1,%2,%3", 0, 0, 0},
+{0, 0, "dsra", "rc,r,r", "sra.d %1,%2,%3", 0, 0, 0},
+{0, 0, "dsra", "rc,r,u", "srai.d %1,%2,%3", 0, 0, 0},
+
+{0, 0, "rol", "rc,r,s", "rotri.w %1,%2,-(%3)%%32<0?-(%3)%%32+32:-(%3)%%32", 0, 0, 0},
+{0, 0, "rol", "rc,r,r", "li $at,32;sub.w $at,$at,%3;rotr.w %1,%2,$at;", 0, 0, 0},
+{0, 0, "ror", "rc,r,s", "rotri.w %1,%2,(%3)%%32<0?(%3)%%32+32:(%3)%%32", 0, 0, 0},
+{0, 0, "ror", "rc,r,r", "rotr.w %1,%2,%3", 0, 0, 0},
+{0, 0, "rotr", "rc,r,s", "rotri.w %1,%2,(%3)%%32<0?(%3)%%32+32:(%3)%%32", 0, 0, 0},
+{0, 0, "rotrv", "rc,r,r", "rotr.w %1,%2,%3", 0, 0, 0},
+{0, 0, "drotr32", "rc,r,u", "rotri.d %1,%2,(%3)+32;", 0, 0, 0},
+{0, 0, "dror", "rc,r,s", "rotri.d %1,%2,(%3)%%64<0?(%3)%%64+64:(%3)%%64", 0, 0, 0},
+{0, 0, "dror", "rc,r,r", "rotr.d %1,%2,%3", 0, 0, 0},
+{0, 0, "drotr", "rc,r,s", "rotri.d %1,%2,(%3)%%64<0?(%3)%%64+64:(%3)%%64", 0, 0, 0},
+{0, 0, "drotrv", "rc,r,r", "rotr.d %1,%2,%3", 0, 0, 0},
+
+{0, 0, "ext", "rc,r,u0:5,u0:5+1", "bstrpick.w %1,%2,(%3)+(%4)-1,(%3)", 0, 0, 0},
+{0, 0, "ext", "rc,r,u,u", "throw_error overflow_%3_%4", 0, 0, 0},
+{0, 0, "dext", "rc,r,u,u0:6+1", "bstrpick.d %1,%2,(%3)+(%4)-1,(%3)", 0, 0, 0},
+{0, 0, "dext", "rc,r,u,u", "throw_error overflow_%3_%4", 0, 0, 0},
+{0, 0, "dextu", "rc,r,u0:5+32,u0:5+1", "bstrpick.d %1,%2,(%3)+(%4)-1,(%3)", 0, 0, 0},
+{0, 0, "dextu", "rc,r,u,u", "throw_error overflow_%3_%4", 0, 0, 0},
+{0, 0, "dextm", "rc,r,u0:5,u0:5+33", "bstrpick.d %1,%2,(%3)+(%4)-1,(%3)", 0, 0, 0},
+{0, 0, "dextm", "rc,r,u,u", "throw_error overflow_%3_%4", 0, 0, 0},
+{0, 0, "ins", "rc,r,u,u", "bstrins.w %1,%2,(%3)+(%4)-1,(%3)", 0, 0, 0},
+{0, 0, "dins", "rc,r,u,u", "bstrins.d %1,%2,(%3)+(%4)-1,(%3)", 0, 0, 0},
+{0, 0, "dinsu", "rc,r,u0:5+32,u0:5+1", "bstrins.d %1,%2,(%3)+(%4)-1,(%3)", 0, 0, 0},
+{0, 0, "dinsu", "rc,r,u,u", "throw_error overflow_%3_%4", 0, 0, 0},
+{0, 0, "dinsm", "rc,r,u0:5,u0:6+2", "bstrins.d %1,%2,(%3)+(%4)-1,(%3)", 0, 0, 0},
+{0, 0, "dinsm", "rc,r,u,u", "throw_error overflow_%3_%4", 0, 0, 0},
+
+{0} /* Terminate the list.  */
+
+};
+
+static struct loongarch_opcode loongarch_MIPS_float_branch[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+{0, 0, "bc1t", "l", "bcnez $fcc0,%1", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bc1t", "c,l", "bcnez %1,%2", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bc1tl", "l", "bcnez $fcc0,%1", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bc1tl", "c,l", "bcnez %1,%2", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bc1f", "l", "bceqz $fcc0,%1", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bc1f", "c,l", "bceqz %1,%2", 0, 0, MIPS_HAS_DELAYSLOT},
+{0, 0, "bc1fl", "l", "bceqz $fcc0,%1", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0, 0, "bc1fl", "c,l", "bceqz %1,%2", 0, 0, MIPS_HAS_DELAYSLOT | MIPS_IS_LIKELY_BRANCH},
+{0} /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_MIPS_float_branch_contrary[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+{0, 0, "bc1t", "l", "bceqz $fcc0,:0f", 0, 0, 0},
+{0, 0, "bc1t", "c,l", "bceqz %1,:0f", 0, 0, 0},
+{0, 0, "bc1tl", "l", "bceqz $fcc0,:0f", 0, 0, 0},
+{0, 0, "bc1tl", "c,l", "bceqz %1,:0f", 0, 0, 0},
+{0, 0, "bc1f", "l", "bcnez $fcc0,:0f", 0, 0, 0},
+{0, 0, "bc1f", "c,l", "bcnez %1,:0f", 0, 0, 0},
+{0, 0, "bc1fl", "l", "bcnez $fcc0,:0f", 0, 0, 0},
+{0, 0, "bc1fl", "c,l", "bcnez %1,:0f", 0, 0, 0},
+{0} /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_MIPS_float_opcodes[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+
+
+{0, 0, "add.s", "f,f,f", "fadd.s %1,%2,%3", 0, 0, 0},
+{0, 0, "add.d", "f,f,f", "fadd.d %1,%2,%3", 0, 0, 0},
+{0, 0, "sub.s", "f,f,f", "fsub.s %1,%2,%3", 0, 0, 0},
+{0, 0, "sub.d", "f,f,f", "fsub.d %1,%2,%3", 0, 0, 0},
+{0, 0, "mul.s", "f,f,f", "fmul.s %1,%2,%3", 0, 0, 0},
+{0, 0, "mul.d", "f,f,f", "fmul.d %1,%2,%3", 0, 0, 0},
+{0, 0, "div.s", "f,f,f", "fdiv.s %1,%2,%3", 0, 0, 0},
+{0, 0, "div.d", "f,f,f", "fdiv.d %1,%2,%3", 0, 0, 0},
+{0, 0, "max.s", "f,f,f", "fmax.s %1,%2,%3", 0, 0, 0},
+{0, 0, "max.d", "f,f,f", "fmax.d %1,%2,%3", 0, 0, 0},
+{0, 0, "min.s", "f,f,f", "fmin.s %1,%2,%3", 0, 0, 0},
+{0, 0, "min.d", "f,f,f", "fmin.d %1,%2,%3", 0, 0, 0},
+{0, 0, "maxa.s", "f,f,f", "fmaxa.s %1,%2,%3", 0, 0, 0},
+{0, 0, "maxa.d", "f,f,f", "fmaxa.d %1,%2,%3", 0, 0, 0},
+{0, 0, "mina.s", "f,f,f", "fmina.s %1,%2,%3", 0, 0, 0},
+{0, 0, "mina.d", "f,f,f", "fmina.d %1,%2,%3", 0, 0, 0},
+{0, 0, "abs.s", "f,f", "fabs.s %1,%2", 0, 0, 0},
+{0, 0, "abs.d", "f,f", "fabs.d %1,%2", 0, 0, 0},
+{0, 0, "neg.s", "f,f", "fneg.s %1,%2", 0, 0, 0},
+{0, 0, "neg.d", "f,f", "fneg.d %1,%2", 0, 0, 0},
+{0, 0, "class.s", "f,f", "fclass.s %1,%2", 0, 0, 0},
+{0, 0, "class.d", "f,f", "fclass.d %1,%2", 0, 0, 0},
+{0, 0, "sqrt.s", "f,f", "fsqrt.s %1,%2", 0, 0, 0},
+{0, 0, "sqrt.d", "f,f", "fsqrt.d %1,%2", 0, 0, 0},
+{0, 0, "recip.s", "f,f", "frecip.s %1,%2", 0, 0, 0},
+{0, 0, "recip.d", "f,f", "frecip.d %1,%2", 0, 0, 0},
+{0, 0, "rsqrt.s", "f,f", "frsqrt.s %1,%2", 0, 0, 0},
+{0, 0, "rsqrt.d", "f,f", "frsqrt.d %1,%2", 0, 0, 0},
+{0, 0, "mov.s", "f,f", "fmov.s %1,%2", 0, 0, 0},
+{0, 0, "mov.d", "f,f", "fmov.d %1,%2", 0, 0, 0},
+{0, 0, "movf", "r,r,c", "bcnez %3,:1f;or %1,%2,$r0;:1:;", 0, 0, 0},
+{0, 0, "movf.s", "f,f,c", "bcnez %3,:1f;fmov.s %1,%2;:1:;", 0, 0, 0},
+{0, 0, "movf.d", "f,f,c", "bcnez %3,:1f;fmov.d %1,%2;:1:;", 0, 0, 0},
+{0, 0, "movn.s", "f,f,r", "beqz %3,:1f;fmov.s %1,%2;:1:;", 0, 0, 0},
+{0, 0, "movn.d", "f,f,r", "beqz %3,:1f;fmov.d %1,%2;:1:;", 0, 0, 0},
+{0, 0, "movt", "r,r,c", "bceqz %3,:1f;or %1,%2,$r0;:1:;", 0, 0, 0},
+{0, 0, "movt.s", "f,f,c", "bceqz %3,:1f;fmov.s %1,%2;:1:;", 0, 0, 0},
+{0, 0, "movt.d", "f,f,c", "bceqz %3,:1f;fmov.d %1,%2;:1:;", 0, 0, 0},
+{0, 0, "movz.s", "f,f,r", "bnez %3,:1f;fmov.s %1,%2;:1:;", 0, 0, 0},
+{0, 0, "movz.d", "f,f,r", "bnez %3,:1f;fmov.d %1,%2;:1:;", 0, 0, 0},
+
+{0, 0, "madd.s", "f,f,f,f", "fmadd.s %1,%3,%4,%2", 0, 0, 0},
+{0, 0, "madd.d", "f,f,f,f", "fmadd.d %1,%3,%4,%2", 0, 0, 0},
+{0, 0, "msub.s", "f,f,f,f", "fmsub.s %1,%3,%4,%2", 0, 0, 0},
+{0, 0, "msub.d", "f,f,f,f", "fmsub.d %1,%3,%4,%2", 0, 0, 0},
+{0, 0, "nmadd.s", "f,f,f,f", "fnmadd.s %1,%3,%4,%2", 0, 0, 0},
+{0, 0, "nmadd.d", "f,f,f,f", "fnmadd.d %1,%3,%4,%2", 0, 0, 0},
+{0, 0, "nmsub.s", "f,f,f,f", "fnmsub.s %1,%3,%4,%2", 0, 0, 0},
+{0, 0, "nmsub.d", "f,f,f,f", "fnmsub.d %1,%3,%4,%2", 0, 0, 0},
+
+{0, 0, "mtc1", "r,f", "movgr2fr.w %2,%1", 0, 0, 0},
+{0, 0, "dmtc1", "r,f", "movgr2fr.d %2,%1", 0, 0, 0},
+{0, 0, "mthc1", "r,f", "movgr2frh.w %2,%1", 0, 0, 0},
+{0, 0, "mfc1", "r,f", "movfr2gr.s %1,%2", 0, 0, 0},
+{0, 0, "dmfc1", "r,f", "movfr2gr.d %1,%2", 0, 0, 0},
+{0, 0, "mfhc1", "r,f", "movfrh2gr.s %1,%2", 0, 0, 0},
+{0, 0, "cvt.ld.d", "f,f", "fcvt.ld.d %1,%2", 0, 0, 0},
+{0, 0, "cvt.ud.d", "f,f", "fcvt.ud.d %1,%2", 0, 0, 0},
+{0, 0, "cvt.d.ld", "f,f,f", "fcvt.d.ld %1,%2,%3", 0, 0, 0},
+{0, 0, "cvt.s.d", "f,f", "fcvt.s.d %1,%2", 0, 0, 0},
+{0, 0, "cvt.d.s", "f,f", "fcvt.d.s %1,%2", 0, 0, 0},
+{0, 0, "floor.w.s", "f,f", "ftintrm.w.s %1,%2", 0, 0, 0},
+{0, 0, "floor.w.d", "f,f", "ftintrm.w.d %1,%2", 0, 0, 0},
+{0, 0, "floor.l.s", "f,f", "ftintrm.l.s %1,%2", 0, 0, 0},
+{0, 0, "floor.l.d", "f,f", "ftintrm.l.d %1,%2", 0, 0, 0},
+{0, 0, "ceil.w.s", "f,f", "ftintrp.w.s %1,%2", 0, 0, 0},
+{0, 0, "ceil.w.d", "f,f", "ftintrp.w.d %1,%2", 0, 0, 0},
+{0, 0, "ceil.l.s", "f,f", "ftintrp.l.s %1,%2", 0, 0, 0},
+{0, 0, "ceil.l.d", "f,f", "ftintrp.l.d %1,%2", 0, 0, 0},
+{0, 0, "trunc.w.s", "f,f", "ftintrz.w.s %1,%2", 0, 0, 0},
+{0, 0, "trunc.w.d", "f,f", "ftintrz.w.d %1,%2", 0, 0, 0},
+{0, 0, "trunc.l.s", "f,f", "ftintrz.l.s %1,%2", 0, 0, 0},
+{0, 0, "trunc.l.d", "f,f", "ftintrz.l.d %1,%2", 0, 0, 0},
+{0, 0, "round.w.s", "f,f", "ftintrne.w.s %1,%2", 0, 0, 0},
+{0, 0, "round.w.d", "f,f", "ftintrne.w.d %1,%2", 0, 0, 0},
+{0, 0, "round.l.s", "f,f", "ftintrne.l.s %1,%2", 0, 0, 0},
+{0, 0, "round.l.d", "f,f", "ftintrne.l.d %1,%2", 0, 0, 0},
+{0, 0, "cvt.w.s", "f,f", "ftint.w.s %1,%2", 0, 0, 0},
+{0, 0, "cvt.w.d", "f,f", "ftint.w.d %1,%2", 0, 0, 0},
+{0, 0, "cvt.l.s", "f,f", "ftint.l.s %1,%2", 0, 0, 0},
+{0, 0, "cvt.l.d", "f,f", "ftint.l.d %1,%2", 0, 0, 0},
+{0, 0, "cvt.s.w", "f,f", "ffint.s.w %1,%2", 0, 0, 0},
+{0, 0, "cvt.s.l", "f,f", "ffint.s.l %1,%2", 0, 0, 0},
+{0, 0, "cvt.d.w", "f,f", "ffint.d.w %1,%2", 0, 0, 0},
+{0, 0, "cvt.d.l", "f,f", "ffint.d.l %1,%2", 0, 0, 0},
+
+{0, 0, "lwc1", "f,s0:11,r", "fld.s %1,%3,%2", 0, 0, 0},
+{0, 0, "lwc1", "f,s,r", "dli $at,%2;add.d $at,$at,%3;fld.s %1,$at,0", 0, 0, 0},
+{0, 0, "lwc1", "f,la", "la $at,%2;fld.s %1,$at,0", 0, 0, 0},
+{0, 0, "l.s", "f,s0:11,r", "fld.s %1,%3,%2", 0, 0, 0},
+{0, 0, "l.s", "f,s,r", "dli $at,%2;add.d $at,$at,%3;fld.s %1,$at,0", 0, 0, 0},
+{0, 0, "l.s", "f,la", "la $at,%2;fld.s %1,$at,0", 0, 0, 0},
+{0, 0, "lwxc1", "f,r,r", "fldx.s %1,%3,%2", 0, 0, 0},
+{0, 0, "swc1", "f,s0:11,r", "fst.s %1,%3,%2", 0, 0, 0},
+{0, 0, "swc1", "f,s,r", "dli $at,%2;add.d $at,$at,%3;fst.s %1,$at,0", 0, 0, 0},
+{0, 0, "swc1", "f,la", "la $at,%2;fst.s %1,$at,0", 0, 0, 0},
+{0, 0, "s.s", "f,s0:11,r", "fst.s %1,%3,%2", 0, 0, 0},
+{0, 0, "s.s", "f,s,r", "dli $at,%2;add.d $at,$at,%3;fst.s %1,$at,0", 0, 0, 0},
+{0, 0, "s.s", "f,la", "la $at,%2;fst.s %1,$at,0", 0, 0, 0},
+{0, 0, "swxc1", "f,r,r", "fstx.s %1,%3,%2", 0, 0, 0},
+{0, 0, "ldc1", "f,s0:11,r", "fld.d %1,%3,%2", 0, 0, 0},
+{0, 0, "ldc1", "f,s,r", "dli $at,%2;add.d $at,$at,%3;fld.d %1,$at,0", 0, 0, 0},
+{0, 0, "ldc1", "f,la", "la $at,%2;fld.d %1,$at,0", 0, 0, 0},
+{0, 0, "l.d", "f,s0:11,r", "fld.d %1,%3,%2", 0, 0, 0},
+{0, 0, "l.d", "f,s,r", "dli $at,%2;add.d $at,$at,%3;fld.d %1,$at,0", 0, 0, 0},
+{0, 0, "l.d", "f,la", "la $at,%2;fld.d %1,$at,0", 0, 0, 0},
+{0, 0, "ldxc1", "f,r,r", "fldx.d %1,%3,%2", 0, 0, 0},
+{0, 0, "sdc1", "f,s0:11,r", "fst.d %1,%3,%2", 0, 0, 0},
+{0, 0, "sdc1", "f,s,r", "dli $at,%2;add.d $at,$at,%3;fst.d %1,$at,0", 0, 0, 0},
+{0, 0, "sdc1", "f,la", "la $at,%2;fst.d %1,$at,0", 0, 0, 0},
+{0, 0, "s.d", "f,s0:11,r", "fst.d %1,%3,%2", 0, 0, 0},
+{0, 0, "s.d", "f,s,r", "dli $at,%2;add.d $at,$at,%3;fst.d %1,$at,0", 0, 0, 0},
+{0, 0, "s.d", "f,la", "la $at,%2;fst.d %1,$at,0", 0, 0, 0},
+{0, 0, "sdxc1", "f,r,r", "fstx.d %1,%3,%2", 0, 0, 0},
+{0, 0, "trunc.w.s", "f,f", "ftintrz.w.s %1,%2", 0, 0, 0},
+{0, 0, "trunc.w.d", "f,f", "ftintrz.w.d %1,%2", 0, 0, 0},
+{0, 0, "trunc.l.s", "f,f", "ftintrz.l.s %1,%2", 0, 0, 0},
+{0, 0, "trunc.l.d", "f,f", "ftintrz.l.d %1,%2", 0, 0, 0},
+
+{0, 0, "c.f.d", "f,f", "fcmp.caf.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.f.d", "c,f,f", "fcmp.caf.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.un.d", "f,f", "fcmp.cun.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.un.d", "c,f,f", "fcmp.cun.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.eq.d", "f,f", "fcmp.ceq.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.eq.d", "c,f,f", "fcmp.ceq.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ueq.d", "f,f", "fcmp.cueq.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ueq.d", "c,f,f", "fcmp.cueq.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.olt.d", "f,f", "fcmp.clt.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.olt.d", "c,f,f", "fcmp.clt.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ult.d", "f,f", "fcmp.cult.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ult.d", "c,f,f", "fcmp.cult.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ole.d", "f,f", "fcmp.cle.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ole.d", "c,f,f", "fcmp.cle.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ule.d", "f,f", "fcmp.cule.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ule.d", "c,f,f", "fcmp.cule.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.sf.d", "f,f", "fcmp.saf.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.sf.d", "c,f,f", "fcmp.saf.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ngle.d", "f,f", "fcmp.sun.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ngle.d", "c,f,f", "fcmp.sun.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.seq.d", "f,f", "fcmp.seq.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.seq.d", "c,f,f", "fcmp.seq.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ngl.d", "f,f", "fcmp.sueq.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ngl.d", "c,f,f", "fcmp.sueq.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.lt.d", "f,f", "fcmp.slt.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.lt.d", "c,f,f", "fcmp.slt.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.nge.d", "f,f", "fcmp.sult.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.nge.d", "c,f,f", "fcmp.sult.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.le.d", "f,f", "fcmp.sle.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.le.d", "c,f,f", "fcmp.sle.d %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ngt.d", "f,f", "fcmp.sule.d $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ngt.d", "c,f,f", "fcmp.sule.d %1,%2,%3;", 0, 0, 0},
+
+{0, 0, "c.f.s", "f,f", "fcmp.caf.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.f.s", "c,f,f", "fcmp.caf.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.un.s", "f,f", "fcmp.cun.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.un.s", "c,f,f", "fcmp.cun.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.eq.s", "f,f", "fcmp.ceq.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.eq.s", "c,f,f", "fcmp.ceq.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ueq.s", "f,f", "fcmp.cueq.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ueq.s", "c,f,f", "fcmp.cueq.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.olt.s", "f,f", "fcmp.clt.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.olt.s", "c,f,f", "fcmp.clt.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ult.s", "f,f", "fcmp.cult.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ult.s", "c,f,f", "fcmp.cult.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ole.s", "f,f", "fcmp.cle.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ole.s", "c,f,f", "fcmp.cle.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ule.s", "f,f", "fcmp.cule.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ule.s", "c,f,f", "fcmp.cule.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.sf.s", "f,f", "fcmp.saf.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.sf.s", "c,f,f", "fcmp.saf.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ngle.s", "f,f", "fcmp.sun.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ngle.s", "c,f,f", "fcmp.sun.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.seq.s", "f,f", "fcmp.seq.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.seq.s", "c,f,f", "fcmp.seq.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ngl.s", "f,f", "fcmp.sueq.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ngl.s", "c,f,f", "fcmp.sueq.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.lt.s", "f,f", "fcmp.slt.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.lt.s", "c,f,f", "fcmp.slt.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.nge.s", "f,f", "fcmp.sult.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.nge.s", "c,f,f", "fcmp.sult.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.le.s", "f,f", "fcmp.sle.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.le.s", "c,f,f", "fcmp.sle.s %1,%2,%3;", 0, 0, 0},
+{0, 0, "c.ngt.s", "f,f", "fcmp.sule.s $fcc0,%1,%2;", 0, 0, 0},
+{0, 0, "c.ngt.s", "c,f,f", "fcmp.sule.s %1,%2,%3;", 0, 0, 0},
+
+{0} /* Terminate the list.  */
+};
+
+static struct loongarch_ase loongarch_mips_ASEs[] = {
+
+{&ASM_opts.mips_ase_fix, loongarch_MIPS_branch, 0, &contrary_branch_cond_check, {0}, 0, 0},
+{&ASM_opts.mips_ase_fix, loongarch_MIPS_branch_contrary, &contrary_branch_cond_check, 0, {0}, 0, 0},
+
+{&ASM_opts.mips_ase_fix, loongarch_MIPS_fix_opcodes, &LARCH_opts.rlen_is_64, 0, {0}, 0, 0},
+{&ASM_opts.mips_ase_float, loongarch_MIPS_float_branch, 0, &contrary_branch_cond_check, {0}, 0, 0},
+{&ASM_opts.mips_ase_float, loongarch_MIPS_float_branch_contrary, &contrary_branch_cond_check, 0, {0}, 0, 0},
+{&ASM_opts.mips_ase_float, loongarch_MIPS_float_opcodes, &LARCH_opts.rlen_is_64, 0, {0}, 0, 0},
+
+{0},
+};
diff --git a/gas/config/tc-loongarch.c b/gas/config/tc-loongarch.c
new file mode 100644
index 00000000000..1451bdc44cc
--- /dev/null
+++ b/gas/config/tc-loongarch.c
@@ -0,0 +1,1313 @@
+#include "as.h"
+#include "dw2gencfi.h"
+#include "elf/loongarch.h"
+#include "opcode/loongarch.h"
+#include "obj-elf.h"
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <assert.h>
+
+/* All information about an instruction during assemble */
+struct loongarch_cl_insn
+{
+  /* First split string */
+  const char *name;
+  const char *arg_strs[MAX_ARG_NUM_PLUS_2];
+  size_t arg_num;
+
+  /* Second analyze name_str and each actual args string to match the insn
+     in 'loongarch-opc.c'. And actual args may need be relocated.
+     We get length of insn. If 'insn_length == 0 && insn_mo->macro != NULL',
+     it's a macro insntruction and we call 'md_assemble' recursively
+     after expanding it.  */
+  int match_now;
+  int all_match;
+
+  const struct loongarch_opcode *insn;
+  size_t insn_length;
+
+  offsetT args[MAX_ARG_NUM_PLUS_2];
+  struct reloc_info reloc_info[MAX_RELOC_NUMBER_A_INSN];
+  size_t reloc_num;
+
+  /* For relax reserved. We not support relax now.
+     'insn_length < relax_max_length' means need to relax.
+     And 'insn_length == relax_max_length' means no need to relax. */
+  size_t relax_max_length;
+  relax_substateT subtype;
+
+  /* Then we get the binary representation of insn
+     and write it in to section. */
+  insn_t insn_bin;
+
+  /* The frag that contains the instruction.  */
+  struct frag *frag;
+  /* The offset into FRAG of the first instruction byte.  */
+  long where;
+  /* The relocs associated with the instruction, if any.  */
+  fixS *fixp[MAX_RELOC_NUMBER_A_INSN];
+};
+
+/* This array holds the chars that always start a comment.  If the
+   pre-processor is disabled, these aren't very useful */
+const char comment_chars[] = "#";
+
+/* This array holds the chars that only start a comment at the beginning of
+   a line.  If the line seems to have the form '# 123 filename'
+   .line and .file directives will appear in the pre-processed output */
+/* Note that input_file.c hand checks for '#' at the beginning of the
+   first line of the input file.  This is because the compiler outputs
+#NO_APP at the beginning of its output.  */
+/* Also note that C style comments are always supported.  */
+const char line_comment_chars[] = "#";
+
+/* This array holds machine specific line separator characters.  */
+const char line_separator_chars[] = ";";
+
+/* Chars that can be used to separate mant from exp in floating point nums */
+const char EXP_CHARS[] = "eE";
+
+/* Chars that mean this number is a floating point constant */
+/* As in 0f12.456 */
+/* or    0d1.2345e12 */
+const char FLT_CHARS[] = "rRsSfFdDxXpP";
+
+static struct
+{
+  int mips_converter_enabled;
+  int mips_abi_is_o32;
+  int mips_abi_is_n32;
+  int mips_abi_is_n64;
+  int mips_ase_fix;
+  int mips_ase_float;
+  int mips_ase_msa;
+  int mips_ase_lasx;
+} ASM_opts =
+{
+  .mips_converter_enabled = 0,
+  .mips_abi_is_o32 = 0,
+  .mips_abi_is_n32 = 0,
+  .mips_abi_is_n64 = 0,
+  .mips_ase_fix = 0,
+  .mips_ase_float = 0,
+  .mips_ase_msa = 0,
+  .mips_ase_lasx = 0,
+};
+
+const char *md_shortopts = "O::g::G:";
+
+enum options
+{
+  OPTION_IGNORE = OPTION_MD_BASE,
+  OPTION_MIPS,
+  OPTION_MIPS_ABI,
+
+  OPTION_SOFT_FLOAT,
+  OPTION_HARD_FLOAT,
+  OPTION_ABI,
+
+  OPTION_LA_LOCAL_WITH_ABS,
+  OPTION_LA_GLOBAL_WITH_PCREL,
+  OPTION_LA_GLOBAL_WITH_ABS,
+
+  OPTION_END_OF_ENUM,
+};
+
+struct option md_longopts[] =
+{
+  {"mmips", no_argument, NULL, OPTION_MIPS},
+  {"mmips-abi", required_argument, NULL, OPTION_MIPS_ABI},
+
+  {"msoft-float", no_argument, NULL, OPTION_SOFT_FLOAT},
+  {"mhard-float", no_argument, NULL, OPTION_HARD_FLOAT},
+  {"mabi", required_argument, NULL, OPTION_ABI},
+
+  {"mla-local-with-abs", no_argument, NULL, OPTION_LA_LOCAL_WITH_ABS},
+  {"mla-global-with-pcrel", no_argument, NULL, OPTION_LA_GLOBAL_WITH_PCREL},
+  {"mla-global-with-abs", no_argument, NULL, OPTION_LA_GLOBAL_WITH_ABS},
+
+  {NULL, no_argument, NULL, 0}
+};
+
+size_t md_longopts_size = sizeof (md_longopts);
+
+int
+md_parse_option (int c, const char *arg)
+{
+  int ret = 1;
+  switch (c)
+    {
+    case OPTION_MIPS:
+      ASM_opts.mips_converter_enabled = 1;
+      break;
+    case OPTION_MIPS_ABI:
+      if (strcasecmp (arg, "32") == 0)
+	ASM_opts.mips_abi_is_o32 = 1;
+      else if (strcasecmp (arg, "n32") == 0)
+	ASM_opts.mips_abi_is_n32 = 1;
+      else if (strcasecmp (arg, "64") == 0)
+	ASM_opts.mips_abi_is_n64 = 1;
+      else
+	ret = 0;
+      break;
+
+    case OPTION_SOFT_FLOAT:
+      LARCH_opts.ase_float = 0;
+      break;
+    case OPTION_HARD_FLOAT:
+      LARCH_opts.ase_float = 1;
+      break;
+    case OPTION_ABI:
+      if (strcasecmp (arg, "lp64") == 0)
+	LARCH_opts.abi_is_lp64 = 1;
+      else if (strcasecmp (arg, "lp32") == 0)
+	LARCH_opts.abi_is_lp32 = 1;
+      else
+	ret = 0;
+      break;
+    case OPTION_LA_LOCAL_WITH_ABS:
+      LARCH_opts.la_local_with_abs = 1;
+      break;
+    case OPTION_LA_GLOBAL_WITH_PCREL:
+      LARCH_opts.la_global_with_pcrel = 1;
+      break;
+    case OPTION_LA_GLOBAL_WITH_ABS:
+      LARCH_opts.la_global_with_abs = 1;
+      break;
+    case OPTION_IGNORE:
+      break;
+    }
+  return ret;
+}
+
+static struct htab *r_htab = NULL;
+static struct htab *f_htab = NULL;
+static struct htab *c_htab = NULL;
+static struct htab *cr_htab = NULL;
+static struct htab *v_htab = NULL;
+static struct htab *x_htab = NULL;
+
+static void
+loongarch_mips_converter_init (void);
+
+void
+loongarch_after_parse_args ()
+{
+  size_t i;
+
+  LARCH_opts.ase_test = 1;
+  LARCH_opts.ase_fix = 1;
+  LARCH_opts.ase_float = 1;
+  LARCH_opts.ase_128vec = 1;
+  LARCH_opts.ase_256vec = 1;
+
+  if (!r_htab)
+    r_htab = str_htab_create (), str_hash_insert (r_htab, "", 0, 0);
+  if (!f_htab)
+    f_htab = str_htab_create (), str_hash_insert (f_htab, "", 0, 0);
+  if (!c_htab)
+    c_htab = str_htab_create (), str_hash_insert (c_htab, "", 0, 0);
+  if (!cr_htab)
+    cr_htab = str_htab_create (), str_hash_insert (cr_htab, "", 0, 0);
+  if (!v_htab)
+    v_htab = str_htab_create (), str_hash_insert (v_htab, "", 0, 0);
+  if (!x_htab)
+    x_htab = str_htab_create (), str_hash_insert (x_htab, "", 0, 0);
+
+  for (i = 0; i < ARRAY_SIZE (loongarch_r_normal_name); i++)
+    str_hash_insert (r_htab, loongarch_r_normal_name[i], (void *) (i + 1), 0);
+  for (i = 0; i < ARRAY_SIZE (loongarch_f_normal_name); i++)
+    str_hash_insert (f_htab, loongarch_f_normal_name[i], (void *) (i + 1), 0);
+  for (i = 0; i < ARRAY_SIZE (loongarch_c_normal_name); i++)
+    str_hash_insert (c_htab, loongarch_c_normal_name[i], (void *) (i + 1), 0);
+  for (i = 0; i < ARRAY_SIZE (loongarch_cr_normal_name); i++)
+    str_hash_insert (cr_htab, loongarch_cr_normal_name[i], (void *) (i + 1), 0);
+  for (i = 0; i < ARRAY_SIZE (loongarch_v_normal_name); i++)
+    str_hash_insert (v_htab, loongarch_v_normal_name[i], (void *) (i + 1), 0);
+  for (i = 0; i < ARRAY_SIZE (loongarch_x_normal_name); i++)
+    str_hash_insert (x_htab, loongarch_x_normal_name[i], (void *) (i + 1), 0);
+
+  if (LARCH_opts.abi_is_lp64
+      + LARCH_opts.abi_is_lp32
+      == 0)
+    {
+      // as_warn (_("default LoongISA ABI is lp64"));
+      LARCH_opts.abi_is_lp64 = 1;
+    }
+
+  if (1 < LARCH_opts.abi_is_lp64
+      + LARCH_opts.abi_is_lp32)
+    as_fatal (_("we can specify only ONE abi"));
+
+  if (LARCH_opts.abi_is_lp64)
+    {
+      LARCH_opts.addrwidth_is_64 = 1;
+      LARCH_opts.rlen_is_64 = 1;
+      for (i = 0; i < ARRAY_SIZE (loongarch_r_lp64_name); i++)
+	str_hash_insert (r_htab, loongarch_r_lp64_name[i], (void *) (i + 1), 0);
+      for (i = 0; i < ARRAY_SIZE (loongarch_r_lp64_name1); i++)
+	str_hash_insert (r_htab, loongarch_r_lp64_name1[i], (void *) (i + 1), 0);
+      for (i = 0; i < ARRAY_SIZE (loongarch_f_lp64_name); i++)
+	str_hash_insert (f_htab, loongarch_f_lp64_name[i], (void *) (i + 1), 0);
+      for (i = 0; i < ARRAY_SIZE (loongarch_f_lp64_name1); i++)
+	str_hash_insert (f_htab, loongarch_f_lp64_name1[i], (void *) (i + 1), 0);
+    }
+
+  if (LARCH_opts.abi_is_lp32)
+    {
+      LARCH_opts.addrwidth_is_32 = 1;
+      LARCH_opts.rlen_is_32 = 1;
+    }
+
+  if (ASM_opts.mips_converter_enabled)
+    loongarch_mips_converter_init ();
+}
+
+const char *
+loongarch_target_format ()
+{
+  return LARCH_opts.addrwidth_is_32? "elf32-loongarch" : "elf64-loongarch";
+}
+
+void
+md_begin ()
+{
+  if (LARCH_opts.ase_test)
+    {
+      const struct loongarch_opcode *it;
+      struct loongarch_ase *ase;
+      for (ase = loongarch_ASEs; ase->enabled; ase++)
+	for (it = ase->opcodes; it->name; it++)
+	  {
+	    if (loongarch_check_format (it->format) != 0)
+	      as_fatal (_("insn name: %s\tformat: %s\tsyntax error"),
+			it->name, it->format);
+	    if (it->mask == 0 && it->macro == 0)
+	      as_fatal (_("insn name: %s\nformat: %s\nwe want macro but macro is NULL"),
+			it->name, it->format);
+	    if (it->macro && loongarch_check_macro (it->format, it->macro) != 0)
+	      as_fatal (_("insn name: %s\nformat: %s\nmacro: %s\tsyntax error"),
+			it->name, it->format, it->macro);
+	  }
+    }
+
+  /* FIXME: expressionS use 'offsetT' as constant, we want this is 64-bit type */
+  assert (8 <= sizeof (offsetT));
+}
+
+void
+md_operand (expressionS *e)
+{
+  /* Because we use 'expression' to check if a actual arg is a expr at first.
+     If not, we want a returning. */
+  if (e->X_op == O_absent)
+    e->X_op = O_illegal;
+}
+
+static const expressionS const_0 = {.X_op = O_constant, .X_add_number = 0};
+
+static const char *
+my_getExpression (expressionS *ep, const char *str)
+{
+  char *save_in, *ret;
+  save_in = input_line_pointer;
+  input_line_pointer = (char *)str;
+  expression (ep);
+  ret = input_line_pointer;
+  input_line_pointer = save_in;
+  return ret;
+}
+
+
+/* for compitable with MIPS pesudo insn like '.set reorder'
+   but actually ignore them. */
+static void
+s_loongarch_set (int x ATTRIBUTE_UNUSED)
+{
+  char *name = input_line_pointer, ch;
+
+  while (!is_end_of_line[(unsigned char) *input_line_pointer])
+    ++input_line_pointer;
+  ch = *input_line_pointer;
+  *input_line_pointer = '\0';
+
+  if (strchr (name, ','))
+    {
+      /* Generic ".set" directive; use the generic handler.  */
+      *input_line_pointer = ch;
+      input_line_pointer = name;
+      s_set (0);
+      return;
+    }
+
+  *input_line_pointer = ch;
+  demand_empty_rest_of_line ();
+}
+
+static void
+s_loongarch_align (int arg)
+{
+  const char *t = input_line_pointer;
+  while (!is_end_of_line[(unsigned char) *t] && *t != ',')
+    ++t;
+  if (*t == ',')
+    s_align_ptwo (arg);
+  else
+    s_align_ptwo (0);
+}
+
+/* Handle the .dtprelword and .dtpreldword pseudo-ops.  They generate
+   a 32-bit or 64-bit DTP-relative relocation (BYTES says which) for
+   use in DWARF debug information.  */
+
+static void
+s_dtprel (int bytes)
+{
+  expressionS ex;
+  char *p;
+
+  expression (&ex);
+
+  if (ex.X_op != O_symbol)
+    {
+      as_bad (_("Unsupported use of %s"), (bytes == 8
+					   ? ".dtpreldword"
+					   : ".dtprelword"));
+      ignore_rest_of_line ();
+    }
+
+  p = frag_more (bytes);
+  md_number_to_chars (p, 0, bytes);
+  fix_new_exp (frag_now, p - frag_now->fr_literal, bytes, &ex, FALSE,
+	       (bytes == 8
+		? BFD_RELOC_LARCH_TLS_DTPREL64
+		: BFD_RELOC_LARCH_TLS_DTPREL32));
+
+  demand_empty_rest_of_line ();
+}
+
+#include "tc-loongarch-mips.c"
+
+static const pseudo_typeS loongarch_pseudo_table[] =
+{
+  {"align", s_loongarch_align, -4},
+  {"dword", cons, 8},
+  {"word", cons, 4},
+  {"half", cons, 2},
+  {"dtprelword", s_dtprel, 4},
+  {"dtpreldword", s_dtprel, 8},
+  { NULL, NULL, 0 },
+};
+
+void
+loongarch_pop_insert (void)
+{
+  if (ASM_opts.mips_converter_enabled)
+    pop_insert (loongarch_mips_pseudo_table);
+  else
+    pop_insert (loongarch_pseudo_table);
+}
+
+
+#define INTERNAL_LABEL_SPECIAL 10
+static unsigned long internal_label_count[INTERNAL_LABEL_SPECIAL] = {0};
+
+static const char *
+loongarch_internal_label_name (unsigned long label, int augend)
+{
+  static char symbol_name_build[24];
+  unsigned long want_label;
+  char *p;
+
+  want_label = internal_label_count[label] + augend;
+
+  p = symbol_name_build;
+#ifdef LOCAL_LABEL_PREFIX
+  *p++ = LOCAL_LABEL_PREFIX;
+#endif
+  *p++ = 'L';
+  for (; label; label /= 10)
+    *p++ = label % 10 + '0';
+  /* make sure internal label never belong to normal label namespace */
+  *p++ = ':';
+  for (; want_label; want_label /= 10)
+    *p++ = want_label % 10 + '0';
+  *p++ = '\0';
+  return symbol_name_build;
+}
+
+static void
+setup_internal_label_here (unsigned long label)
+{
+  assert (label < INTERNAL_LABEL_SPECIAL);
+  internal_label_count[label]++;
+  colon (loongarch_internal_label_name (label ,0));
+}
+
+extern void /* no static. used by 'loongarch-parse.y' */
+get_internal_label (expressionS *label_expr,
+		    unsigned long label,
+		    int augend/* 0 for previous, 1 for next */);
+
+void
+get_internal_label (expressionS *label_expr,
+		    unsigned long label,
+		    int augend/* 0 for previous, 1 for next */)
+{
+  assert (label < INTERNAL_LABEL_SPECIAL);
+  if (augend == 0 && internal_label_count[label] == 0)
+    as_fatal (_("internal error: we have no internal label yet"));
+  label_expr->X_op = O_symbol;
+  label_expr->X_add_symbol =
+    symbol_find_or_make (loongarch_internal_label_name (label, augend));
+  label_expr->X_add_number = 0;
+}
+
+extern int
+loongarch_parse_expr (const char *expr,
+		     struct reloc_info *reloc_stack_top,
+		     size_t max_reloc_num,
+		     size_t *reloc_num,
+		     offsetT *imm_if_no_reloc);
+
+static int32_t
+loongarch_args_parser_can_match_arg_helper (char esc_ch1,
+					   char esc_ch2,
+					   const char *bit_field,
+					   const char *arg,
+					   void *context)
+{
+  struct loongarch_cl_insn *ip = context;
+  offsetT imm, ret = 0;
+  size_t reloc_num_we_have = MAX_RELOC_NUMBER_A_INSN - ip->reloc_num;
+  size_t reloc_num = 0;
+
+  if (!ip->match_now)
+    return 0;
+
+  switch (esc_ch1)
+    {
+    case 'l':
+      switch (esc_ch2)
+	{
+	default:
+	  ip->match_now = is_label (arg);
+	  if (!ip->match_now && is_label_with_addend (arg))
+	    as_fatal (_("This label shouldn't be with addend."));
+	  break;
+	case 'a':
+	  ip->match_now = is_label_with_addend (arg);
+	  break;
+	}
+      break;
+    case 's':
+    case 'u':
+      ip->match_now =
+	loongarch_parse_expr (arg, ip->reloc_info + ip->reloc_num,
+	  reloc_num_we_have, &reloc_num, &imm) == 0;
+
+      if (!ip->match_now)
+	break;
+
+      if (esc_ch1 == 's')
+	switch (esc_ch2)
+	  {
+	  case 'c':
+	    ip->match_now = reloc_num == 0;
+	    break;
+	  }
+      else
+	switch (esc_ch2)
+	  {
+	  case 'c':
+	    ip->match_now = reloc_num == 0 && 0 <= imm;
+	    break;
+	  }
+
+      if (!ip->match_now)
+	break;
+
+      ret = imm;
+      if (reloc_num)
+	{
+	  bfd_reloc_code_real_type reloc_type = BFD_RELOC_NONE;
+	  reloc_num_we_have -= reloc_num;
+	  if (reloc_num_we_have == 0)
+	    as_fatal (_("expr too huge") /* want one more reloc */);
+	  if (esc_ch1 == 'u')
+	    {
+	      if (strncmp (bit_field, "10:12", strlen ("10:12")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_U_10_12;
+	    }
+	  else if (esc_ch1 == 's')
+	    {
+	      if (strncmp (bit_field, "10:16<<2", strlen ("10:16<<2")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2;
+	      else if (strncmp (bit_field, "0:5|10:16<<2", strlen ("0:5|10:16<<2")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2;
+	      else if (strncmp (bit_field, "0:10|10:16<<2", strlen ("0:10|10:16<<2")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2;
+	      else if (strncmp (bit_field, "10:12", strlen ("10:12")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_12;
+	      else if (strncmp (bit_field, "5:20", strlen ("5:20")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_5_20;
+	      else if (strncmp (bit_field, "10:16", strlen ("10:16")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_16;
+	      else if (strncmp (bit_field, "10:5", strlen ("10:5")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_5;
+	    }
+	  if (reloc_type == BFD_RELOC_NONE)
+	    as_fatal (_("not support reloc bit-field\nfmt: %c%c %s\nargs: %s"),
+		      esc_ch1, esc_ch2, bit_field , arg);
+	  reloc_num++;
+	  ip->reloc_num += reloc_num;
+	  ip->reloc_info[ip->reloc_num - 1].type = reloc_type;
+	  ip->reloc_info[ip->reloc_num - 1].value = const_0;
+	}
+      break;
+    case 'r':
+      imm = (offsetT) str_hash_find (r_htab, arg);
+      ip->match_now = 0 < imm;
+      ret = imm - 1;
+      break;
+    case 'f':
+      imm = (offsetT) str_hash_find (f_htab, arg);
+      ip->match_now = 0 < imm;
+      ret = imm - 1;
+      break;
+    case 'c':
+      switch (esc_ch2)
+	{
+	case 'r':
+	  imm = (offsetT) str_hash_find (cr_htab, arg);
+	  break;
+	default:
+	  imm = (offsetT) str_hash_find (c_htab, arg);
+	}
+      ip->match_now = 0 < imm;
+      ret = imm - 1;
+      break;
+    case 'v':
+      imm = (offsetT) str_hash_find (v_htab, arg);
+      ip->match_now = 0 < imm;
+      ret = imm - 1;
+      break;
+    case 'x':
+      imm = (offsetT) str_hash_find (x_htab, arg);
+      ip->match_now = 0 < imm;
+      ret = imm - 1;
+      break;
+    case '\0':
+      ip->all_match = ip->match_now;
+      ip->insn_length = ip->insn->mask ? loongarch_insn_length (ip->insn->match) : 0;
+      /* FIXME: now we have no relax insn */
+      ip->relax_max_length = ip->insn_length;
+      break;
+    default:
+      as_fatal (_("unknown escape"));
+    }
+
+  do
+    {
+      // check imm overflow
+      int bit_width, bits_needed_s, bits_needed_u;
+      char *t;
+
+      if (!ip->match_now)
+	break;
+
+      if (0 < reloc_num)
+	break;
+
+      bit_width = loongarch_get_bit_field_width (bit_field, &t);
+
+      if (bit_width == -1)
+	// no specify bit width
+	break;
+
+      // 在这里求出实际填入的二进制数。这部分内容和 loongarch_encode_imm
+      // 有重合。但是需要在这里加入一些判断内容，比如分支指令立即数
+      // 右移两位，要保证立即数低两位为0
+      imm = ret;
+      if (t[0] == '<' && t[1] == '<')
+	{
+	  int i = strtol (t += 2, &t, 10), j;
+	  for (j = i; 0 < j; j--, imm >>= 1)
+	    if (imm & 1)
+	      as_fatal (_("require imm low %d bit is 0."), i);
+	}
+
+      if (*t == '+')
+	imm -= strtol (t, &t, 10);
+
+      bits_needed_s = loongarch_bits_imm_needed (imm, 1);
+      bits_needed_u = loongarch_bits_imm_needed (imm, 0);
+
+      // 在这里判断立即数是否溢出。关于有符号立即数我有两种理解
+      // 一是代数意义上的溢出，如果传入的值超出定义域，那么报错。
+      // 二是程序员可能希望指定位域表示，那么值可能是一个使得符号位为1的正数。
+      // riscv的溢出判断是第一种，这里按照riscv的方法来做
+      if ((esc_ch1 == 's' && bit_width < bits_needed_s)
+	  || (esc_ch1 != 's' && bit_width < bits_needed_u))
+	// how to do after we detect overflow
+	as_fatal (_("Immediate overflow.\n"
+		    "format: %c%c%s\n"
+		    "arg: %s"),
+		  esc_ch1, esc_ch2, bit_field, arg);
+    }
+  while (0);
+
+  if (esc_ch1 != '\0')
+    {
+      ip->args[ip->arg_num] = ret;
+      ip->arg_num++;
+    }
+  return ret;
+}
+
+static void
+get_loongarch_opcode (struct loongarch_cl_insn *insn)
+{
+  const struct loongarch_opcode *it;
+  struct loongarch_ase *ase;
+  for (ase = loongarch_ASEs; ase->enabled; ase++)
+    {
+      if (!*ase->enabled
+	  || (ase->include && !*ase->include)
+	  || (ase->exclude && *ase->exclude))
+	continue;
+
+      if (!ase->name_hash_entry)
+	{
+	  ase->name_hash_entry = str_htab_create ();
+	  for (it = ase->opcodes; it->name; it++)
+	    str_hash_insert (ase->name_hash_entry, it->name, (void *) it, 0);
+	}
+
+      if ((it = str_hash_find (ase->name_hash_entry, insn->name)) == NULL)
+	continue;
+
+      do
+	{
+	  insn->insn = it;
+	  insn->match_now = 1;
+	  insn->all_match = 0;
+	  insn->arg_num = 0;
+	  insn->reloc_num = 0;
+	  insn->insn_bin =
+	    loongarch_foreach_args (it->format, insn->arg_strs,
+	      loongarch_args_parser_can_match_arg_helper, insn);
+	  if (insn->all_match
+	      && !(it->include && !*it->include)
+	      && !(it->exclude && *it->exclude))
+	    {
+	      insn->insn_bin |= it->match;
+	      return;
+	    }
+	  it++;
+	}
+      while (it->name && strcasecmp (it->name, insn->name) == 0);
+    }
+}
+
+static int
+check_this_insn_before_appending (struct loongarch_cl_insn *ip)
+{
+  int ret = 0;
+  if (strcmp (ip->name, "la.abs") == 0)
+    {
+      ip->reloc_info[ip->reloc_num].type = BFD_RELOC_LARCH_MARK_LA;
+      my_getExpression (&ip->reloc_info[ip->reloc_num].value, ip->arg_strs[1]);
+      ip->reloc_num++;
+    }
+  else if (ip->insn->mask == 0xffff8000
+	   && ((ip->insn_bin & 0xfff00000) == 0x38600000
+	       || (ip->insn_bin & 0xffff0000) == 0x38700000
+	       || (ip->insn_bin & 0xffff0000) == 0x38710000))
+    {
+      /* for AMO insn amswap.[wd], amadd.[wd], etc. */
+      if (ip->args[0] != 0 &&
+	  (ip->args[0] == ip->args[1] || ip->args[0] == ip->args[2]))
+	as_fatal (_(
+"AMO insns require rd != base && rd != rt when rd isn't $r0"));
+    }
+  else if ((ip->insn->mask == 0xffe08000
+	    && (ip->insn_bin & 0xffe00000) == 0x00600000)
+	   || (ip->insn->mask == 0xffc00000
+	    && (ip->insn_bin & 0xff800000) == 0x00800000))
+    {
+      /* for bstr(ins|pick).[wd] */
+      if (ip->args[2] < ip->args[3])
+	as_fatal (_("bstr(ins|pick).[wd] require msbd >= lsbd"));
+    }
+  else if (ip->insn->mask != 0
+	   && (ip->insn_bin & 0xfe0003c0) == 0x04000000
+	   && (strcmp ("csrxchg", ip->name) == 0
+	       || strcmp ("gcsrxchg", ip->name) == 0))
+    as_fatal (_("g?csrxchg require rj != $r0 && rj != $r1"));
+
+  return ret;
+}
+
+static void
+install_insn (const struct loongarch_cl_insn *insn)
+{
+  char *f = insn->frag->fr_literal + insn->where;
+  if (0 < insn->insn_length)
+    md_number_to_chars (f, insn->insn_bin, insn->insn_length);
+}
+
+static void
+move_insn (struct loongarch_cl_insn *insn, fragS *frag, long where)
+{
+  size_t i;
+  insn->frag = frag;
+  insn->where = where;
+  for (i = 0; i < insn->reloc_num; i++)
+    {
+      insn->fixp[i]->fx_frag = frag;
+      insn->fixp[i]->fx_where = where;
+    }
+  install_insn (insn);
+}
+
+/* Add INSN to the end of the output.  */
+static void
+append_fixed_insn (struct loongarch_cl_insn *insn)
+{
+  char *f = frag_more (insn->insn_length);
+  move_insn (insn, frag_now, f - frag_now->fr_literal);
+}
+
+static void 
+append_fixp_and_insn (struct loongarch_cl_insn *ip)
+{
+  reloc_howto_type *howto;
+  bfd_reloc_code_real_type reloc_type;
+  struct reloc_info *reloc_info = ip->reloc_info;
+  size_t i;
+  for (i = 0; i < ip->reloc_num; i++)
+    {
+      reloc_type = reloc_info[i].type;
+      howto = bfd_reloc_type_lookup (stdoutput, reloc_type);
+      if (howto == NULL)
+	as_fatal (_("no HOWTO loong relocation number %d"), reloc_type);
+
+      ip->fixp[i] =
+	fix_new_exp (ip->frag, ip->where, bfd_get_reloc_size (howto),
+	  &reloc_info[i].value, FALSE, reloc_type);
+    }
+
+  if (ip->insn_length < ip->relax_max_length)
+    as_fatal (_("Internal error: not support relax now"));
+  else
+    append_fixed_insn (ip);
+}
+
+//ask helper for returning a malloced c_str or NULL
+static char *
+assember_macro_helper (const char * const args[], void *context_ptr)
+{
+  struct loongarch_cl_insn *insn = context_ptr;
+  char *ret = NULL;
+  if (strcmp (insn->name, "li") == 0
+      || strcmp (insn->name, "dli") == 0)
+    {
+      char args_buf[50], insns_buf[200];
+      const char *arg_strs[6];
+      uint32_t hi32, lo32;
+
+      /* We pay attention to sign extend beacause it is chance of reduce insn.
+         The exception is 12-bit and hi-12-bit unsigned,
+	 we need a 'ori' or a 'lu52i.d' accordingly. */
+      char all0_bit_vec, sign_bit_vec, allf_bit_vec, paritial_is_sext_of_prev;
+
+      lo32 = insn->args[1] & 0xffffffff;
+      hi32 = insn->args[1] >> 32;
+
+      if (strcmp (insn->name, "li") == 0)
+	{
+	  if (hi32 != 0 && hi32 != 0xffffffff)
+	    as_fatal (_("li overflow: hi32:0x%x lo32:0x%x"), hi32, lo32);
+	  hi32 = lo32 & 0x80000000 ? 0xffffffff : 0;
+	}
+
+      if (strcmp (insn->name, "dli") == 0 && LARCH_opts.rlen_is_32)
+	as_fatal (_("we can't dli on 32bit-arch"));
+
+      snprintf (args_buf, sizeof (args_buf), "0x%x,0x%x,0x%x,0x%x,%s",
+		(hi32 >> 20) & 0xfff, hi32 & 0xfffff,
+		(lo32 >> 12) & 0xfffff, lo32 & 0xfff, args[0]);
+      loongarch_split_args_by_comma (args_buf, arg_strs);
+
+      all0_bit_vec = (((hi32 & 0xfff00000) == 0) << 3)
+		   | (((hi32 & 0x000fffff) == 0) << 2)
+		   | (((lo32 & 0xfffff000) == 0) << 1)
+		   | ((lo32 & 0x00000fff) == 0);
+      sign_bit_vec = (((hi32 & 0x80000000) != 0) << 3)
+		   | (((hi32 & 0x00080000) != 0) << 2)
+		   | (((lo32 & 0x80000000) != 0) << 1)
+		   | ((lo32 & 0x00000800) != 0);
+      allf_bit_vec = (((hi32 & 0xfff00000) == 0xfff00000) << 3)
+		   | (((hi32 & 0x000fffff) == 0x000fffff) << 2)
+		   | (((lo32 & 0xfffff000) == 0xfffff000) << 1)
+		   | ((lo32 & 0x00000fff) == 0x00000fff);
+      paritial_is_sext_of_prev = (all0_bit_vec ^ allf_bit_vec)
+			       & (all0_bit_vec ^ (sign_bit_vec << 1));
+
+      static const char * const li_32bit [] = {
+	"lu12i.w %5,%3&0x80000?%3-0x100000:%3;ori %5,%5,%4;",
+	"lu12i.w %5,%3&0x80000?%3-0x100000:%3;",
+	"addi.w %5,$r0,%4&0x800?%4-0x1000:%4;",
+	"xor %5,%5,%5;",
+      };
+      static const char * const li_hi_32bit[] = {
+	"lu32i.d %5,%2&0x80000?%2-0x100000:%2;"
+	  "lu52i.d %5,%5,%1&0x800?%1-0x1000:%1;",
+	"lu52i.d %5,%5,%1&0x800?%1-0x1000:%1;",
+	"lu32i.d %5,%2&0x80000?%2-0x100000:%2;",
+	"",
+      };
+      do
+	{
+	  insns_buf[0] = '\0';
+	  if (paritial_is_sext_of_prev == 0x7)
+	    {
+	      strcat (insns_buf, "lu52i.d %5,$r0,%1&0x800?%1-0x1000:%1;");
+	      break;
+	    }
+	  if ((all0_bit_vec & 0x3) == 0x2)
+	    strcat (insns_buf, "ori %5,$r0,%4;");
+	  else
+	    strcat (insns_buf, li_32bit[paritial_is_sext_of_prev & 0x3]);
+	  strcat (insns_buf, li_hi_32bit[paritial_is_sext_of_prev >> 2]);
+	}
+      while (0);
+
+      ret = loongarch_expand_macro (insns_buf, arg_strs, NULL, NULL);
+    }
+  else if (strcmp (insn->name, "throw_error") == 0)
+    as_fatal (args[0]);
+  return ret;
+}
+
+//accept instructions separated by ';'
+//assuming 'not starting with space and not ending with space' or pass in empty c_str
+static void
+loongarch_assemble_INSNs (char *str)
+{
+  char *rest;
+
+  for (rest = str; *rest != ';' && *rest != '\0'; rest++);
+  if (*rest == ';')
+    *rest++ = '\0';
+
+  if (*str == ':')
+    {
+      str++;
+      setup_internal_label_here (strtol (str, &str, 10));
+      str++;
+    }
+
+  do
+    {
+      if (*str == '\0')
+	break;
+
+      struct loongarch_cl_insn the_one = {0};
+      the_one.name = str;
+
+      for (; *str && *str != ' '; str++);
+      if (*str == ' ')
+	*str++ = '\0';
+
+      loongarch_split_args_by_comma (str, the_one.arg_strs);
+      get_loongarch_opcode (&the_one);
+
+      if (!the_one.all_match)
+	as_fatal (_("no match insn: %s\t%s"),
+	  the_one.name, loongarch_cat_splited_strs (the_one.arg_strs));
+
+      if (check_this_insn_before_appending (&the_one) != 0)
+	break;
+
+      append_fixp_and_insn (&the_one);
+      if (the_one.insn_length == 0 && the_one.insn->macro)
+	{
+	  char *c_str =
+	    loongarch_expand_macro (the_one.insn->macro,
+	      the_one.arg_strs, assember_macro_helper, &the_one);
+	  loongarch_assemble_INSNs (c_str);
+	  free (c_str);
+	}
+    }
+  while (0);
+
+  if (*rest != '\0')
+    loongarch_assemble_INSNs (rest);
+}
+
+void
+md_assemble (char *str)
+{
+  if (ASM_opts.mips_converter_enabled)
+    {
+      char *insns = loongarch_converte_one_mips (str);
+      loongarch_assemble_INSNs (insns);
+      free (insns);
+    }
+  else
+    loongarch_assemble_INSNs (str);
+}
+
+const char *md_atof (int type, char *litP, int *sizeP)
+{
+  return ieee_md_atof (type, litP, sizeP, FALSE);
+}
+
+void md_number_to_chars (char *buf, valueT val, int n)
+{
+  number_to_chars_littleendian (buf, val, n);
+}
+
+/* The location from which a PC relative jump should be calculated,
+   given a PC relative reloc.  */
+long
+md_pcrel_from (fixS *fixP ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+void
+md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
+{
+  static int64_t stack_top;
+  static int last_reloc_is_sop_push_pcrel_1 = 0;
+  int last_reloc_is_sop_push_pcrel = last_reloc_is_sop_push_pcrel_1;
+  insn_t insn;
+  last_reloc_is_sop_push_pcrel_1 = 0;
+
+  char *buf = fixP->fx_frag->fr_literal + fixP->fx_where;
+  switch (fixP->fx_r_type)
+    {
+    case BFD_RELOC_LARCH_SOP_PUSH_TLS_TPREL:
+    case BFD_RELOC_LARCH_SOP_PUSH_TLS_GD:
+    case BFD_RELOC_LARCH_SOP_PUSH_TLS_GOT:
+      if (fixP->fx_addsy)
+	S_SET_THREAD_LOCAL (fixP->fx_addsy);
+    case BFD_RELOC_LARCH_SOP_PUSH_PCREL:
+    case BFD_RELOC_LARCH_SOP_PUSH_PLT_PCREL:
+      if (fixP->fx_addsy == NULL)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("Relocation against a constant"));
+      if (fixP->fx_r_type == BFD_RELOC_LARCH_SOP_PUSH_PCREL)
+	{
+	  /* 分支到内部符号的重定位尽量在这里解决。一方面是为了反汇编更好看；
+	     也是为了方便PMON的模块加载。PMON连接器的重定位类型枚举空间很小，
+	     无法实现全的重定位。编译时加入-mabiabs使得所有外部符号都有la.abs，
+	     从而有MARK_LA这个重定位，PMON连接器重定位时填4条la指令。 */
+	  last_reloc_is_sop_push_pcrel_1 = 1;
+	  if (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	    stack_top = S_GET_VALUE (fixP->fx_addsy) + fixP->fx_offset
+		      - (fixP->fx_where + fixP->fx_frag->fr_address);
+	  else
+	    stack_top = 0;
+	}
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_10_5:
+      if (!last_reloc_is_sop_push_pcrel)
+	break;
+      if ((stack_top & ~(uint64_t)0xf) != 0x0
+	  && (stack_top & ~(uint64_t)0xf) != ~(uint64_t)0xf)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & (~(uint32_t)0x7c00)) | ((stack_top & 0x1f) << 10);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_U_10_12:
+      if (!last_reloc_is_sop_push_pcrel)
+	break;
+      if (stack_top & ~(uint64_t)0xfff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & (~(uint32_t)0x3ffc00)) | ((stack_top & 0xfff) << 10);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_10_12:
+      if (!last_reloc_is_sop_push_pcrel)
+	break;
+      if ((stack_top & ~(uint64_t)0x7ff) != 0x0
+	  && (stack_top & ~(uint64_t)0x7ff) != ~(uint64_t)0x7ff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & (~(uint32_t)0x3ffc00)) | ((stack_top & 0xfff) << 10);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_10_16:
+      if (!last_reloc_is_sop_push_pcrel)
+	break;
+      if ((stack_top & ~(uint64_t)0x7fff) != 0x0
+	  && (stack_top & ~(uint64_t)0x7fff) != ~(uint64_t)0x7fff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & 0xfc0003ff) | ((stack_top & 0xffff) << 10);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2:
+      if (!last_reloc_is_sop_push_pcrel)
+	break;
+      if ((stack_top & 0x3) != 0)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      stack_top >>= 2;
+      if ((stack_top & ~(uint64_t)0x7fff) != 0x0
+	  && (stack_top & ~(uint64_t)0x7fff) != ~(uint64_t)0x7fff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & 0xfc0003ff) | ((stack_top & 0xffff) << 10);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2:
+      if (!last_reloc_is_sop_push_pcrel)
+	break;
+      if ((stack_top & 0x3) != 0)
+	break;
+      stack_top >>= 2;
+      if ((stack_top & ~(uint64_t)0xfffff) != 0x0
+	  && (stack_top & ~(uint64_t)0xfffff) != ~(uint64_t)0xfffff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & 0xfc0003e0)
+	   | ((stack_top & 0xffff) << 10) | ((stack_top & 0x1f0000) >> 16);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_5_20:
+      if (!last_reloc_is_sop_push_pcrel)
+	break;
+      if ((stack_top & ~(uint64_t)0x7ffff) != 0x0
+	  && (stack_top & ~(uint64_t)0x7ffff) != ~(uint64_t)0x7ffff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & (~(uint32_t)0x1ffffe0)) | ((stack_top & 0xfffff) << 5);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2:
+      if (!last_reloc_is_sop_push_pcrel)
+	break;
+      if ((stack_top & 0x3) != 0)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      stack_top >>= 2;
+      if ((stack_top & ~(uint64_t)0x1ffffff) != 0x0
+	  && (stack_top & ~(uint64_t)0x1ffffff) != ~(uint64_t)0x1ffffff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & 0xfc000000)
+	   | ((stack_top & 0xffff) << 10) | ((stack_top & 0x3ff0000) >> 16);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_U:
+      if (!last_reloc_is_sop_push_pcrel)
+	break;
+      if (stack_top & ~(uint64_t)0xffffffff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      bfd_putl32 (stack_top, buf);
+      break;
+
+    case BFD_RELOC_64:
+    case BFD_RELOC_32:
+      if (fixP->fx_subsy)
+	{
+    case BFD_RELOC_24:
+    case BFD_RELOC_16:
+    case BFD_RELOC_8:
+	  fixP->fx_next = xmemdup (fixP, sizeof (*fixP), sizeof (*fixP));
+	  fixP->fx_next->fx_addsy = fixP->fx_subsy;
+	  fixP->fx_next->fx_subsy = NULL;
+	  fixP->fx_next->fx_offset = 0;
+	  fixP->fx_subsy = NULL;
+
+	  switch (fixP->fx_r_type)
+	    {
+	    case BFD_RELOC_64:
+	      fixP->fx_r_type = BFD_RELOC_LARCH_ADD64;
+	      fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB64;
+	      break;
+	    case BFD_RELOC_32:
+	      fixP->fx_r_type = BFD_RELOC_LARCH_ADD32;
+	      fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB32;
+	      break;
+	    case BFD_RELOC_24:
+	      fixP->fx_r_type = BFD_RELOC_LARCH_ADD24;
+	      fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB24;
+	      break;
+	    case BFD_RELOC_16:
+	      fixP->fx_r_type = BFD_RELOC_LARCH_ADD16;
+	      fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB16;
+	      break;
+	    case BFD_RELOC_8:
+	      fixP->fx_r_type = BFD_RELOC_LARCH_ADD8;
+	      fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB8;
+	      break;
+	    default:
+	      break;
+	    }
+	  md_number_to_chars (buf, 0, fixP->fx_size);
+	  if (fixP->fx_next->fx_addsy == NULL)
+	    fixP->fx_next->fx_done = 1;
+	}
+      if (fixP->fx_addsy == NULL)
+	{
+	  fixP->fx_done = 1;
+	  md_number_to_chars (buf, *valP, fixP->fx_size);
+	}
+      break;
+
+    default:
+      break;
+    }
+}
+
+int
+loongarch_relax_frag (asection *sec ATTRIBUTE_UNUSED, fragS *fragp ATTRIBUTE_UNUSED, long stretch ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+int
+md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED, asection *segtype ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+/* Translate internal representation of relocation info to BFD target
+   format.  */
+arelent *
+tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
+{
+  arelent *reloc = (arelent *) xmalloc (sizeof (arelent));
+
+  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+  reloc->addend = fixp->fx_offset;
+
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
+  if (reloc->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("cannot represent %s relocation in object file"),
+		    bfd_get_reloc_code_name (fixp->fx_r_type));
+      return NULL;
+    }
+
+  return reloc;
+}
+
+/* Convert a machine dependent frag.  */
+void
+md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT asec ATTRIBUTE_UNUSED, fragS *fragp ATTRIBUTE_UNUSED)
+{
+  // fragp->fr_fix += 8;
+}
+
+/* Standard calling conventions leave the CFA at SP on entry.  */
+void
+loongarch_cfi_frame_initial_instructions (void)
+{
+  cfi_add_CFA_def_cfa_register (3 /* $sp */);
+}
+
+int
+loongarch_dwarf2_addr_size (void)
+{
+  return LARCH_opts.addrwidth_is_32? 4 : 8;
+}
+
+void
+tc_loongarch_parse_to_dw2regnum (expressionS *exp)
+{
+  expression_and_evaluate (exp);
+  if (ASM_opts.mips_converter_enabled)
+    exp->X_add_number =
+      tc_loongarch_mips_dw2regnum_mapping (exp->X_add_number);
+}
+
+void
+md_show_usage (FILE *stream)
+{
+  fprintf (stream, _("\
+		     LoongISA options:\n\
+		     "));
+}
+
+/* Fill in an rs_align_code fragment.  We want to fill 'andi $r0,$r0,0'.  */
+void
+loongarch_handle_align (fragS *fragp)
+{
+//   char nop_opcode;
+  char *p;
+  int bytes, size, excess;
+  valueT opcode;
+
+  if (fragp->fr_type != rs_align_code)
+    return;
+
+  struct loongarch_cl_insn nop =
+    {.name = "andi", .arg_strs = {"$r0", "$r0", "0", NULL}};
+
+  get_loongarch_opcode (&nop);
+  gas_assert (nop.all_match);
+
+  p = fragp->fr_literal + fragp->fr_fix;
+//   nop_opcode = *p;
+  //   switch (nop_opcode)
+  //     {
+  //     case NOP_OPCODE_MIPS:
+  //     default:
+  opcode = nop.insn_bin;
+  size = 4;
+  //       break;
+  //     }
+
+  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
+  excess = bytes % size;
+
+  /* Handle the leading part if we're not inserting a whole number of
+     instructions, and make it the end of the fixed part of the frag.
+     Try to fit in a short microMIPS NOP if applicable and possible,
+     and use zeroes otherwise.  */
+  gas_assert (excess < 4);
+  fragp->fr_fix += excess;
+  switch (excess)
+    {
+    case 3:
+      *p++ = '\0';
+    case 2:
+      *p++ = '\0';
+    case 1:
+      *p++ = '\0';
+    case 0:
+      break;
+    }
+
+  md_number_to_chars (p, opcode, size);
+  fragp->fr_var = size;
+}
+
+void
+loongarch_elf_final_processing (void)
+{
+  if (LARCH_opts.abi_is_lp64)
+    elf_elfheader (stdoutput)->e_flags |= EF_LARCH_ABI_LP64;
+  else if (LARCH_opts.abi_is_lp32)
+    elf_elfheader (stdoutput)->e_flags |= EF_LARCH_ABI_LP32;
+}
diff --git a/gas/config/tc-loongarch.h b/gas/config/tc-loongarch.h
new file mode 100644
index 00000000000..b22f7718370
--- /dev/null
+++ b/gas/config/tc-loongarch.h
@@ -0,0 +1,74 @@
+#ifndef TC_LOONGARCH
+#define TC_LOONGARCH
+
+#define TARGET_BYTES_BIG_ENDIAN 0
+#define TARGET_ARCH bfd_arch_loongarch
+
+#define WORKING_DOT_WORD	1
+#define REPEAT_CONS_EXPRESSIONS
+
+// early than md_begin
+#define md_after_parse_args loongarch_after_parse_args
+extern void loongarch_after_parse_args (void);
+
+extern void loongarch_pop_insert (void);
+#define md_pop_insert()		loongarch_pop_insert ()
+
+#define TARGET_FORMAT loongarch_target_format()
+extern const char * loongarch_target_format (void);
+
+
+#define md_relax_frag(segment, fragp, stretch) \
+  loongarch_relax_frag (segment, fragp, stretch)
+extern int loongarch_relax_frag (asection *, struct frag *, long);
+#define md_section_align(seg,size)	(size)
+#define md_undefined_symbol(name)	(0)
+
+/* This is called to see whether a reloc against a defined symbol
+   should be converted into a reloc against a section.  */
+#define tc_fix_adjustable(fixp) 0
+
+/* Values passed to md_apply_fix don't include symbol values.  */
+#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX, SEG) 1
+#define TC_VALIDATE_FIX_SUB(FIX, SEG) 1
+#define DIFF_EXPR_OK 1
+
+#define TARGET_USE_CFIPOP	1
+#define DWARF2_DEFAULT_RETURN_COLUMN	1 /* $ra */
+#define DWARF2_CIE_DATA_ALIGNMENT -4
+extern int loongarch_dwarf2_addr_size (void);
+#define DWARF2_FDE_RELOC_SIZE loongarch_dwarf2_addr_size ()
+#define DWARF2_ADDR_SIZE(bfd) loongarch_dwarf2_addr_size ()
+#define CFI_DIFF_EXPR_OK 0
+
+#define tc_cfi_frame_initial_instructions loongarch_cfi_frame_initial_instructions
+extern void loongarch_cfi_frame_initial_instructions (void);
+
+// 我们不实现 tc_regname_to_dw2regnum，而是重载tc_parse_to_dw2regnum。
+// 因为MIPS汇编兼容需要CFA来实现C++异常抛出。我们仅仅对数字作映射，
+// 不再考虑寄存器的名字了。
+//#define tc_regname_to_dw2regnum tc_loongarch_regname_to_dw2regnum
+#define tc_parse_to_dw2regnum tc_loongarch_parse_to_dw2regnum
+extern void tc_loongarch_parse_to_dw2regnum (expressionS *);
+
+// a enumerated values to specific how to deal with align in '.text'
+// now we want to fill 'andi $r0,$r0,0x0'
+#define loongarch_nop_opcode() 0
+#define NOP_OPCODE (loongarch_nop_opcode ())
+
+#define HANDLE_ALIGN(fragp)  loongarch_handle_align (fragp)
+extern void loongarch_handle_align (struct frag *);
+#define MAX_MEM_FOR_RS_ALIGN_CODE  (3 + 4)
+
+#define elf_tc_final_processing loongarch_elf_final_processing
+extern void loongarch_elf_final_processing (void);
+
+#define MAX_RELOC_NUMBER_A_INSN 20
+
+struct reloc_info
+{
+  bfd_reloc_code_real_type type;
+  expressionS value;
+};
+
+#endif
diff --git a/gas/configure.ac b/gas/configure.ac
index 82706561886..052d38fde17 100644
--- a/gas/configure.ac
+++ b/gas/configure.ac
@@ -447,6 +447,15 @@ changequote([,])dnl
 	using_cgen=yes
 	;;
 
+      loongarch)
+	for f in loongarch-parse.o loongarch-lex-wrapper.o; do
+	  case " $extra_objects " in
+	    *" $f "*) ;;
+	    *) extra_objects="$extra_objects $f" ;;
+	  esac
+	done
+	;;
+
       m32c)
 	using_cgen=yes
 	;;
diff --git a/gas/configure.tgt b/gas/configure.tgt
index 6f46e0a6329..b3a8e1e3be8 100644
--- a/gas/configure.tgt
+++ b/gas/configure.tgt
@@ -67,6 +67,7 @@ case ${cpu} in
   ip2k)			cpu_type=ip2k endian=big ;;
   iq2000)		cpu_type=iq2000 endian=big ;;
   lm32)			cpu_type=lm32 ;;
+  loongarch*)   cpu_type=loongarch ;;
   m32c)			cpu_type=m32c endian=little ;;
   m32r)			cpu_type=m32r endian=big ;;
   m32rle)		cpu_type=m32r endian=little ;;
@@ -272,6 +273,8 @@ case ${generic_target} in
 
   iq2000-*-elf)				fmt=elf ;;
 
+  loongarch*)				fmt=elf ;;
+
   lm32-*-*)				fmt=elf ;;
 
   m32c-*-elf)				fmt=elf ;;
@@ -434,7 +437,7 @@ esac
 
 case ${cpu_type} in
   aarch64 | alpha | arm | csky | i386 | ia64 | microblaze | mips | ns32k | \
-  or1k | or1knd | pdp11 | ppc | riscv | sh | sparc | z80 | z8k)
+  or1k | or1knd | pdp11 | ppc | riscv | sh | sparc | z80 | z8k | loongarch)
     bfd_gas=yes
     ;;
 esac
diff --git a/include/dis-asm.h b/include/dis-asm.h
index 368eb2734fb..2dacd5c53e4 100644
--- a/include/dis-asm.h
+++ b/include/dis-asm.h
@@ -299,6 +299,7 @@ extern void print_mips_disassembler_options (FILE *);
 extern void print_nfp_disassembler_options (FILE *);
 extern void print_ppc_disassembler_options (FILE *);
 extern void print_riscv_disassembler_options (FILE *);
+extern void print_loongarch_disassembler_options (FILE *);
 extern void print_arm_disassembler_options (FILE *);
 extern void print_arc_disassembler_options (FILE *);
 extern void print_s390_disassembler_options (FILE *);
diff --git a/include/elf/common.h b/include/elf/common.h
index e7d55ae0782..3df6b3f163e 100644
--- a/include/elf/common.h
+++ b/include/elf/common.h
@@ -674,6 +674,14 @@
 					/*   note name must be "LINUX".  */
 #define NT_ARC_V2	0x600		/* ARC HS accumulator/extra registers.  */
 					/*   note name must be "LINUX".  */
+#define NT_LARCH_CPUCFG	0x900		/* Loongarch CPU config registers */
+					/*   note name must be "LINUX".  */
+#define NT_LARCH_LBT	0x901		/* Loongarch Loongson Binary Translation registers */
+					/*   note name must be "LINUX".  */
+#define NT_LARCH_LSX	0x902		/* Loongarch Loongson SIMD Extension registers */
+					/*   note name must be "LINUX".  */
+#define NT_LARCH_LASX	0x903		/* Loongarch Loongson Advanced SIMD Extension registers */
+					/*   note name must be "LINUX".  */
 #define NT_SIGINFO	0x53494749	/* Fields of siginfo_t.  */
 #define NT_FILE		0x46494c45	/* Description of mapped files.  */
 
diff --git a/include/elf/loongarch.h b/include/elf/loongarch.h
new file mode 100644
index 00000000000..09a8ad23d18
--- /dev/null
+++ b/include/elf/loongarch.h
@@ -0,0 +1,94 @@
+#ifndef _ELF_LOONG_H
+#define _ELF_LOONG_H
+
+#include "elf/reloc-macros.h"
+#include "libiberty.h"
+
+START_RELOC_NUMBERS (elf_loongarch_reloc_type)
+/* used by the dynamic linker */
+RELOC_NUMBER (R_LARCH_NONE, 0)
+RELOC_NUMBER (R_LARCH_32, 1)
+RELOC_NUMBER (R_LARCH_64, 2)
+RELOC_NUMBER (R_LARCH_RELATIVE, 3)
+RELOC_NUMBER (R_LARCH_COPY, 4)
+RELOC_NUMBER (R_LARCH_JUMP_SLOT, 5)
+RELOC_NUMBER (R_LARCH_TLS_DTPMOD32, 6)
+RELOC_NUMBER (R_LARCH_TLS_DTPMOD64, 7)
+RELOC_NUMBER (R_LARCH_TLS_DTPREL32, 8)
+RELOC_NUMBER (R_LARCH_TLS_DTPREL64, 9)
+RELOC_NUMBER (R_LARCH_TLS_TPREL32, 10)
+RELOC_NUMBER (R_LARCH_TLS_TPREL64, 11)
+RELOC_NUMBER (R_LARCH_IRELATIVE, 12)
+
+/* Reserved for future relocs that the dynamic linker must understand.  */
+
+/* used by the static linker for relocating .text */
+RELOC_NUMBER (R_LARCH_MARK_LA, 20)
+RELOC_NUMBER (R_LARCH_MARK_PCREL, 21)
+
+/* 这个重定位类型将symbol距离重定位位置的pc相对位置偏移量压栈。
+   它against symbol，因为如果是个常数，虽然在no-pic的情况下可以得到结果，但因为
+   重定位位置相对这个常数的偏移量一定很大，八成填不进去；而在pic的情况下，
+   偏移量无法在静态连接时确定。因此我们约定这个重定位不可能against constant */
+RELOC_NUMBER (R_LARCH_SOP_PUSH_PCREL, 22)
+
+/* 这个重定位against a symbol or a constant。它将symbol的运行时绝对地址
+   或常数压栈，因此在pic的情况下会报错。另外我不太清楚常数和ABS段的关系。 */
+RELOC_NUMBER (R_LARCH_SOP_PUSH_ABSOLUTE, 23)
+
+RELOC_NUMBER (R_LARCH_SOP_PUSH_DUP, 24)
+RELOC_NUMBER (R_LARCH_SOP_PUSH_GPREL, 25)
+RELOC_NUMBER (R_LARCH_SOP_PUSH_TLS_TPREL, 26)
+RELOC_NUMBER (R_LARCH_SOP_PUSH_TLS_GOT, 27)
+RELOC_NUMBER (R_LARCH_SOP_PUSH_TLS_GD, 28)
+RELOC_NUMBER (R_LARCH_SOP_PUSH_PLT_PCREL, 29)
+
+RELOC_NUMBER (R_LARCH_SOP_ASSERT, 30)
+RELOC_NUMBER (R_LARCH_SOP_NOT, 31)
+RELOC_NUMBER (R_LARCH_SOP_SUB, 32)
+RELOC_NUMBER (R_LARCH_SOP_SL, 33)
+RELOC_NUMBER (R_LARCH_SOP_SR, 34)
+RELOC_NUMBER (R_LARCH_SOP_ADD, 35)
+RELOC_NUMBER (R_LARCH_SOP_AND, 36)
+RELOC_NUMBER (R_LARCH_SOP_IF_ELSE, 37)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_10_5, 38)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_U_10_12, 39)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_10_12, 40)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_10_16, 41)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_10_16_S2, 42)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_5_20, 43)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_0_5_10_16_S2, 44)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_0_10_10_16_S2, 45)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_U, 46)
+
+/* used by the static linker for relocating non .text */
+/* 这几个重定位类型是为了照顾到 ".dword sym1 - sym2" 这种求差的写法。
+   这些重定位类型处理的是连接时地址，一般情况下它们是成对出现的。
+   在直接求负数".dword - sym1"的情况下，R_LARCH_SUBxx会单独出现。但注意，
+   那个位置填进去的是连接时地址。 */
+RELOC_NUMBER (R_LARCH_ADD8, 47)
+RELOC_NUMBER (R_LARCH_ADD16, 48)
+RELOC_NUMBER (R_LARCH_ADD24, 49)
+RELOC_NUMBER (R_LARCH_ADD32, 50)
+RELOC_NUMBER (R_LARCH_ADD64, 51)
+RELOC_NUMBER (R_LARCH_SUB8, 52)
+RELOC_NUMBER (R_LARCH_SUB16, 53)
+RELOC_NUMBER (R_LARCH_SUB24, 54)
+RELOC_NUMBER (R_LARCH_SUB32, 55)
+RELOC_NUMBER (R_LARCH_SUB64, 56)
+
+/* I don't know what it is. Existing in almost all other arch */
+RELOC_NUMBER (R_LARCH_GNU_VTINHERIT, 57)
+RELOC_NUMBER (R_LARCH_GNU_VTENTRY, 58)
+
+END_RELOC_NUMBERS (R_LARCH_count)
+
+
+/* Processor specific flags for the ELF header e_flags field.  */
+
+#define EF_LARCH_ABI		0x0003
+#define EF_LARCH_ABI_LP64	0x0003
+#define EF_LARCH_ABI_XLP32	0x0002
+#define EF_LARCH_ABI_LP32	0x0001
+
+#endif /* _ELF_LOONG_H */
diff --git a/include/opcode/loongarch.h b/include/opcode/loongarch.h
new file mode 100644
index 00000000000..94e42da86b5
--- /dev/null
+++ b/include/opcode/loongarch.h
@@ -0,0 +1,217 @@
+#ifndef _LOONGARCH_H_
+#define _LOONGARCH_H_
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef uint32_t insn_t;
+
+struct loongarch_opcode
+{
+  const insn_t match;
+  const insn_t mask; /* High 1 byte is main opcode and it must be 0xf. */
+#define LARCH_INSN_OPC(insn) ((insn & 0xf0000000) >> 28)
+  const char * const name;
+
+  /* 
+     ACTUAL PARAMETER:
+
+  // BNF with regular expression. 
+args : token* end
+
+  // just few char separate 'iden'
+token : ','
+| '('
+| ')'
+| iden             // maybe a label (include at least one alphabet), maybe a number, maybe a expr
+| regname
+
+regname : '$' iden
+
+iden : [a-zA-Z0-9\.\+\-]+
+
+end : '\0'
+
+
+FORMAT: A string to describe the format of actual parameter including bit field infomation.
+For example, "r5:5,r0:5,sr10:16<<2" matches "$12,$13,12345" and "$4,$7,a_label".
+That 'sr' means the instruction may need relocate. '10:16' means bit field of instruction.
+In a 'format', every 'escape's can be replaced to 'iden' or 'regname' acrroding to its meaning.
+We fill all information needed by disassembing and assembing to 'format'.
+
+  // BNF with regular expression. 
+format : escape (literal+ escape)* literal* end
+| (literal+ escape)* literal* end
+
+end : '\0'       // Get here means parse end.
+
+  // The intersection between any two among FIRST (end), FIRST (literal) and FIRST (escape) must be empty.
+  // So we can build a simple parser.
+literal : ','
+| '('
+| ')'
+
+  // Double '<'s means the real number is the immediate after shifting left.
+escape : esc_ch bit_field '<' '<' dec2
+| esc_ch bit_field
+| esc_ch    // for MACRO. non-macro format must indicate 'bit_field'
+
+  // '|' means to concatenate nonadjacent bit fields 
+  // For example, "10:16|0:4" means 
+  // "16 bits starting from the 10th bit concatenating with 4 bits starting from the 0th bit".
+  // This is to say "[25..10]||[3..0]" (little endian).
+b_field : dec2 ':' dec2
+| dec2 ':' dec2 '|' bit_field
+
+esc_ch : 's' 'r'   // signed immediate or label need relocate
+| 's'       // signed immediate no need relocate
+| 'u'       // unsigned immediate
+| 'l'       // label needed relocate
+| 'r'       // general purpose registers
+| 'f'       // FPU registers
+| 'v'       // 128 bit SIMD register
+| 'x'       // 256 bit SIMD register
+
+dec2 : [1-9][0-9]?
+| 0
+
+*/
+  const char * const format;
+
+  /*
+MACRO: Indicate how a macro instruction expand for assembling.
+The main is to replace the '%num'(means the 'num'th 'escape' in 'format') in 'macro' string to get the real instruction.
+As for marco insn "b" in MIPS, we can say its name is "b", format is "l", macro is "j %1". So "b 3f" will be expanded to "j 3f".
+As for marco insn "li" in MIPS, we can say its name is "li", format is "s", macro is "ori"
+
+
+Maybe need 
+*/
+  const char * const macro;
+  const int *include;
+  const int *exclude;
+
+  const unsigned long pinfo;
+#define USELESS 0x0l
+
+};
+
+struct htab;
+
+struct loongarch_ase
+{
+  const int *enabled;
+  struct loongarch_opcode * const opcodes;
+  const int *include;
+  const int *exclude;
+
+  /* for disassemble to create main opcode hash table. */
+  const struct loongarch_opcode *opc_htab[16];
+  unsigned char opc_htab_inited;
+
+  /* for GAS to create hash table. */
+  struct htab *name_hash_entry;
+};
+
+extern int is_unsigned (const char *);
+extern int is_signed (const char *);
+extern int is_label_with_addend (const char *);
+extern int is_label (const char *);
+extern int is_branch_label (const char *);
+
+extern int
+loongarch_get_bit_field_width (const char *bit_field, char **end);
+extern int32_t
+loongarch_decode_imm (const char *bit_field, insn_t insn, int si);
+
+#define MAX_ARG_NUM_PLUS_2 9
+
+extern size_t
+loongarch_split_args_by_comma (char *args, const char *arg_strs[]);
+extern char *
+loongarch_cat_splited_strs (const char *arg_strs[]);
+extern insn_t
+loongarch_foreach_args (const char *format, const char *arg_strs[],
+			int32_t (*helper) (char esc1, char esc2,
+					   const char *bit_field,
+					   const char *arg, void *context),
+			void *context);
+
+extern int
+loongarch_check_format (const char *format);
+extern int
+loongarch_check_macro (const char *format, const char *macro);
+
+extern char *
+loongarch_expand_macro_with_format_map (const char *format, const char *macro,
+					const char * const arg_strs[],
+					const char * (*map) (
+					  char esc1, char esc2,
+					  const char *arg),
+					char * (*helper) (
+					  const char * const arg_strs[],
+					  void *context),
+					void *context);
+extern char *
+loongarch_expand_macro (const char *macro, const char * const arg_strs[],
+			char * (*helper) (const char * const arg_strs[],
+					  void *context),
+			void *context);
+extern size_t
+loongarch_bits_imm_needed (int64_t imm, int si);
+
+/* 将字符串中指定的连续字符化为1个 */
+extern void
+loongarch_eliminate_adjacent_repeat_char (char *dest, char c);
+
+/* 下面两个函数计划作为libopcode.a拿出来给一些系统软件反汇编用 */
+extern int
+loongarch_parse_dis_options (const char *opts_in);
+extern void
+loongarch_disassemble_one (int64_t pc, insn_t insn,
+			   int (*fprintf_func)
+			     (void *stream, const char *format, ...),
+			   void *stream);
+
+extern const char * const loongarch_r_normal_name[32];
+extern const char * const loongarch_r_lp64_name[32];
+extern const char * const loongarch_r_lp64_name1[32];
+extern const char * const loongarch_f_normal_name[32];
+extern const char * const loongarch_f_lp64_name[32];
+extern const char * const loongarch_f_lp64_name1[32];
+extern const char * const loongarch_c_normal_name[8];
+extern const char * const loongarch_cr_normal_name[4];
+extern const char * const loongarch_v_normal_name[32];
+extern const char * const loongarch_x_normal_name[32];
+
+extern struct loongarch_ase loongarch_ASEs[];
+
+extern struct loongarch_ASEs_option
+{
+  int ase_test;
+  int ase_fix;
+  int ase_float;
+  int ase_128vec;
+  int ase_256vec;
+
+  int addrwidth_is_32;
+  int addrwidth_is_64;
+  int rlen_is_32;
+  int rlen_is_64;
+  int la_local_with_abs;
+  int la_global_with_pcrel;
+  int la_global_with_abs;
+
+  int abi_is_lp32;
+  int abi_is_lp64;
+} LARCH_opts;
+
+extern size_t loongarch_insn_length (insn_t insn);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _LOONGARCH_H_ */
diff --git a/ld/Makefile.am b/ld/Makefile.am
index 2c9a487335c..66726f2f4f7 100644
--- a/ld/Makefile.am
+++ b/ld/Makefile.am
@@ -433,6 +433,7 @@ ALL_64_EMULATION_SOURCES = \
 	eelf64btsmip.c \
 	eelf64btsmip_fbsd.c \
 	eelf64hppa.c \
+	eelf64loongarch.c \
 	eelf64lppc.c \
 	eelf64lppc_fbsd.c \
 	eelf64lriscv.c \
@@ -920,6 +921,7 @@ $(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES): $(GEN_DEPENDS)
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64btsmip.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64btsmip_fbsd.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64hppa.Pc@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64loongarch.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lppc.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lppc_fbsd.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lriscv.Pc@am__quote@
diff --git a/ld/configure.tgt b/ld/configure.tgt
index 0c780b24d57..d67e778c9ff 100644
--- a/ld/configure.tgt
+++ b/ld/configure.tgt
@@ -1022,6 +1022,10 @@ z8k-*-coff)		targ_emul=z8002
 			targ_extra_emuls=z8001
 			targ_extra_ofiles=
 			;;
+loongarch32-*)		targ_emul=elf32loongarch
+			;;
+loongarch64-*)		targ_emul=elf64loongarch
+			;;
 *-*-ieee*)		targ_emul=vanilla
 			targ_extra_ofiles=
 			;;
diff --git a/ld/emulparams/elf64loongarch-defs.sh b/ld/emulparams/elf64loongarch-defs.sh
new file mode 100644
index 00000000000..571b197ec67
--- /dev/null
+++ b/ld/emulparams/elf64loongarch-defs.sh
@@ -0,0 +1,37 @@
+# This is an ELF platform.
+SCRIPT_NAME=elf
+ARCH=loongarch
+NO_REL_RELOCS=yes
+
+TEMPLATE_NAME=elf
+EXTRA_EM_FILE=loongarchelf
+
+ELFSIZE=64
+
+if test `echo "$host" | sed -e s/64//` = `echo "$target" | sed -e s/64//`; then
+  case " $EMULATION_LIBPATH " in
+    *" ${EMULATION_NAME} "*)
+      NATIVE=yes
+      ;;
+  esac
+fi
+
+# Enable shared library support for everything except an embedded elf target.
+case "$target" in
+  loongarch*-elf)
+    ;;
+  *)
+    GENERATE_SHLIB_SCRIPT=yes
+    GENERATE_PIE_SCRIPT=yes
+    ;;
+esac
+
+NOP=0x03400000
+
+TEXT_START_ADDR=0x120000000
+MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
+COMMONPAGESIZE="CONSTANT (COMMONPAGESIZE)"
+
+SEPARATE_GOTPLT=0
+INITIAL_READONLY_SECTIONS=".interp         : { *(.interp) } ${CREATE_PIE-${INITIAL_READONLY_SECTIONS}}"
+INITIAL_READONLY_SECTIONS="${RELOCATING+${CREATE_SHLIB-${INITIAL_READONLY_SECTIONS}}}"
diff --git a/ld/emulparams/elf64loongarch.sh b/ld/emulparams/elf64loongarch.sh
new file mode 100644
index 00000000000..65b6300b0df
--- /dev/null
+++ b/ld/emulparams/elf64loongarch.sh
@@ -0,0 +1,15 @@
+# RV64 code using LP64D ABI.
+# ABI not in emulation name to avoid breaking backward compatibility.
+. ${srcdir}/emulparams/elf64loongarch-defs.sh
+OUTPUT_FORMAT="elf64-loongarch"
+
+# On Linux, first look for 64 bit LP64D target libraries in /lib64/lp64d as per
+# the glibc ABI, and then /lib64 for backward compatility.
+case "$target" in
+  loong64*-linux*)
+    case "$EMULATION_NAME" in
+      *64*)
+	LIBPATH_SUFFIX="64/lib64 64";;
+    esac
+    ;;
+esac
diff --git a/ld/emultempl/loongarchelf.em b/ld/emultempl/loongarchelf.em
new file mode 100644
index 00000000000..f7ade1fc446
--- /dev/null
+++ b/ld/emultempl/loongarchelf.em
@@ -0,0 +1,91 @@
+# This shell script emits a C file. -*- C -*-
+#   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+#
+# This file is part of the GNU Binutils.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+
+fragment <<EOF
+
+#include "ldmain.h"
+#include "ldctor.h"
+#include "elf/loongarch.h"
+//#include "elfxx-riscv.h"
+
+static void
+loong_elf_before_allocation (void)
+{
+  gld${EMULATION_NAME}_before_allocation ();
+
+  if (link_info.discard == discard_sec_merge)
+    link_info.discard = discard_l;
+
+  if (!bfd_link_relocatable (&link_info))
+    {
+      /* We always need at least some relaxation to handle code alignment.  */
+      if (RELAXATION_DISABLED_BY_USER)
+	TARGET_ENABLE_RELAXATION;
+      else
+	ENABLE_RELAXATION;
+    }
+
+  link_info.relax_pass = 3;
+}
+
+static void
+gld${EMULATION_NAME}_after_allocation (void)
+{
+  int need_layout = 0;
+
+  /* Don't attempt to discard unused .eh_frame sections until the final link,
+     as we can't reliably tell if they're used until after relaxation.  */
+  if (!bfd_link_relocatable (&link_info))
+    {
+      need_layout = bfd_elf_discard_info (link_info.output_bfd, &link_info);
+      if (need_layout < 0)
+	{
+	  einfo (_("%X%P: .eh_frame/.stab edit: %E\n"));
+	  return;
+	}
+    }
+
+  ldelf_map_segments (need_layout);
+}
+
+/* This is a convenient point to tell BFD about target specific flags.
+   After the output has been created, but before inputs are read.  */
+
+static void
+loong_create_output_section_statements (void)
+{
+  /* See PR 22920 for an example of why this is necessary.  */
+  if (strstr (bfd_get_target (link_info.output_bfd), "loong") == NULL)
+    {
+      /* The RISC-V backend needs special fields in the output hash structure.
+	 These will only be created if the output format is a RISC-V format,
+	 hence we do not support linking and changing output formats at the
+	 same time.  Use a link followed by objcopy to change output formats.  */
+      einfo (_("%F%P: error: cannot change output format"
+	       " whilst linking %s binaries\n"), "RISC-V");
+      return;
+    }
+}
+
+EOF
+
+LDEMUL_BEFORE_ALLOCATION=loong_elf_before_allocation
+LDEMUL_AFTER_ALLOCATION=gld${EMULATION_NAME}_after_allocation
+LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS=loong_create_output_section_statements
diff --git a/opcodes/Makefile.am b/opcodes/Makefile.am
index 04980f36b11..7378570f7d1 100644
--- a/opcodes/Makefile.am
+++ b/opcodes/Makefile.am
@@ -162,6 +162,9 @@ TARGET_LIBOPCODES_CFILES = \
 	lm32-ibld.c \
 	lm32-opc.c \
 	lm32-opinst.c \
+	loongarch-opc.c \
+	loongarch-dis.c \
+	loongarch-coder.c \
 	m10200-dis.c \
 	m10200-opc.c \
 	m10300-dis.c \
diff --git a/opcodes/configure.ac b/opcodes/configure.ac
index 07e95f0ee31..a7a96a781f0 100644
--- a/opcodes/configure.ac
+++ b/opcodes/configure.ac
@@ -340,6 +340,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_z80_arch)		ta="$ta z80-dis.lo" ;;
 	bfd_z8k_arch)		ta="$ta z8k-dis.lo" ;;
 	bfd_bpf_arch)		ta="$ta bpf-asm.lo bpf-desc.lo bpf-dis.lo bpf-ibld.lo bpf-opc.lo" using_cgen=yes ;;
+	bfd_loongarch_arch)		ta="$ta loongarch-dis.lo loongarch-opc.lo loongarch-coder.lo" ;;
 
 	"")			;;
 	*)		AC_MSG_ERROR(*** unknown target architecture $arch) ;;
diff --git a/opcodes/disassemble.c b/opcodes/disassemble.c
index 560ee59d4e7..09cd9dc54c3 100644
--- a/opcodes/disassemble.c
+++ b/opcodes/disassemble.c
@@ -49,6 +49,7 @@
 #define ARCH_ip2k
 #define ARCH_iq2000
 #define ARCH_lm32
+#define ARCH_loongarch
 #define ARCH_m32c
 #define ARCH_m32r
 #define ARCH_m68hc11
@@ -100,6 +101,7 @@
 #define ARCH_xtensa
 #define ARCH_z80
 #define ARCH_z8k
+
 #endif
 
 #ifdef ARCH_m32c
@@ -551,6 +553,11 @@ disassembler (enum bfd_architecture a,
     case bfd_arch_tilepro:
       disassemble = print_insn_tilepro;
       break;
+#endif
+#ifdef ARCH_loongarch
+    case bfd_arch_loongarch:
+      disassemble = print_insn_loongarch;
+      break;
 #endif
     default:
       return 0;
@@ -591,6 +598,9 @@ disassembler_usage (FILE *stream ATTRIBUTE_UNUSED)
 #ifdef ARCH_wasm32
   print_wasm32_disassembler_options (stream);
 #endif
+#ifdef ARCH_loongarch
+  print_loongarch_disassembler_options (stream);
+#endif
 
   return;
 }
diff --git a/opcodes/disassemble.h b/opcodes/disassemble.h
index 8ee54dc9494..4e3ea2328e0 100644
--- a/opcodes/disassemble.h
+++ b/opcodes/disassemble.h
@@ -100,6 +100,7 @@ extern int print_insn_xtensa		(bfd_vma, disassemble_info *);
 extern int print_insn_z80		(bfd_vma, disassemble_info *);
 extern int print_insn_z8001		(bfd_vma, disassemble_info *);
 extern int print_insn_z8002		(bfd_vma, disassemble_info *);
+extern int print_insn_loongarch		(bfd_vma, disassemble_info *);
 
 extern disassembler_ftype csky_get_disassembler (bfd *);
 extern disassembler_ftype rl78_get_disassembler (bfd *);
diff --git a/opcodes/loongarch-coder.c b/opcodes/loongarch-coder.c
new file mode 100644
index 00000000000..c6196f9b6ad
--- /dev/null
+++ b/opcodes/loongarch-coder.c
@@ -0,0 +1,538 @@
+#include "sysdep.h"
+#include "opcode/loongarch.h"
+
+int
+is_unsigned (const char *c_str)
+{
+  if (c_str[0] == '0' && (c_str[1] == 'x' || c_str[1] == 'X'))
+    {
+      c_str += 2;
+      while (('a' <= *c_str && *c_str <= 'f')
+	     || ('A' <= *c_str && *c_str <= 'F')
+	     || ('0' <= *c_str && *c_str <= '9'))
+	c_str++;
+    }
+  else if (*c_str == '\0')
+    return 0;
+  else
+    while ('0' <= *c_str && *c_str <= '9')
+      c_str++;
+  return *c_str == '\0';
+}
+
+int
+is_signed (const char *c_str)
+{
+  return *c_str == '-' ? is_unsigned (c_str + 1) : is_unsigned (c_str);
+}
+
+static int
+is_internal_label (const char *c_str)
+{
+  do
+    {
+      if (*c_str != ':')
+	break;
+      c_str++;
+      if (!('0' <= *c_str && *c_str <= '9'))
+	break;
+      while ('0' <= *c_str && *c_str <= '9')
+	c_str++;
+      if (*c_str != 'b' && *c_str != 'f')
+	break;
+      c_str++;
+      return *c_str == '\0';
+    }
+  while (0);
+  return 0;
+}
+
+int
+is_label (const char *c_str)
+{
+  if (is_internal_label (c_str))
+    return 1;
+  else if ('0' <= *c_str && *c_str <= '9')
+    {
+      /* [0-9]+[bf] */
+      while ('0' <= *c_str && *c_str <= '9')
+	c_str++;
+      return *c_str == 'b' || *c_str == 'f';
+    }
+  else if (('a' <= *c_str && *c_str <= 'z')
+	   || ('A' <= *c_str && *c_str <= 'Z')
+	   || *c_str == '.'
+	   || *c_str == '_'
+	   || *c_str == '$')
+    {
+      /* [a-zA-Z\._\$][0-9a-zA-Z\._\$]* */
+      while (('a' <= *c_str && *c_str <= 'z')
+	     || ('A' <= *c_str && *c_str <= 'Z')
+	     || ('0' <= *c_str && *c_str <= '9')
+	     || *c_str == '.'
+	     || *c_str == '_'
+	     || *c_str == '$')
+	c_str++;
+      return *c_str == '\0';
+    }
+  else
+    return 0;
+}
+
+int
+is_label_with_addend (const char *c_str)
+{
+  if (is_internal_label (c_str))
+    return 1;
+  else if ('0' <= *c_str && *c_str <= '9')
+    {
+      /* [0-9]+[bf] */
+      while ('0' <= *c_str && *c_str <= '9')
+	c_str++;
+      if (*c_str == 'b' || *c_str == 'f')
+	c_str++;
+      else
+	return 0;
+      return *c_str == '\0'
+	     || ((*c_str == '-' || *c_str == '+') && is_unsigned (c_str + 1));
+
+    }
+  else if (('a' <= *c_str && *c_str <= 'z')
+	   || ('A' <= *c_str && *c_str <= 'Z')
+	   || *c_str == '.'
+	   || *c_str == '_'
+	   || *c_str == '$')
+    {
+      /* [a-zA-Z\._\$][0-9a-zA-Z\._\$]* */
+      while (('a' <= *c_str && *c_str <= 'z')
+	     || ('A' <= *c_str && *c_str <= 'Z')
+	     || ('0' <= *c_str && *c_str <= '9')
+	     || *c_str == '.'
+	     || *c_str == '_'
+	     || *c_str == '$')
+	c_str++;
+      return *c_str == '\0'
+	     || ((*c_str == '-' || *c_str == '+') && is_unsigned (c_str + 1));
+    }
+  else
+    return 0;
+}
+
+int
+loongarch_get_bit_field_width (const char *bit_field, char **end)
+{
+  int width = 0;
+  char has_specify = 0, *bit_field_1 = (char *) bit_field;
+  if (bit_field_1 && *bit_field_1 != '\0')
+    while (1)
+      {
+	strtol (bit_field_1, &bit_field_1, 10);
+
+	if (*bit_field_1 != ':')
+	  break;
+	bit_field_1++;
+
+	width += strtol (bit_field_1, &bit_field_1, 10);
+	has_specify = 1;
+
+	if (*bit_field_1 != '|')
+	  break;
+	bit_field_1++;
+      }
+  if (end)
+    *end = bit_field_1;
+  return has_specify ? width : -1;
+}
+
+int32_t
+loongarch_decode_imm (const char *bit_field, insn_t insn, int si)
+{
+  int32_t ret = 0;
+  uint32_t t;
+  int len = 0, width, b_start;
+  char *bit_field_1 = (char *) bit_field;
+  while (1)
+    {
+      b_start = strtol (bit_field_1, &bit_field_1, 10);
+      if (*bit_field_1 != ':')
+	break;
+      width = strtol (bit_field_1 + 1, &bit_field_1, 10);
+      len += width;
+
+      t = insn;
+      t <<= sizeof (t) * 8 - width - b_start;
+      t >>= sizeof (t) * 8 - width;
+      ret <<= width;
+      ret |= t;
+
+      if (*bit_field_1 != '|')
+	break;
+      bit_field_1++;
+    }
+
+  if (*bit_field_1 == '<' && *(++bit_field_1) == '<')
+    {
+      width = atoi(bit_field_1 + 1);
+      ret <<= width;
+      len += width;
+    }
+  else if (*bit_field_1 == '+')
+    ret += atoi(bit_field_1 + 1);
+
+  if (si)
+    {
+      ret <<= sizeof (ret) * 8 - len;
+      ret >>= sizeof (ret) * 8 - len;
+    }
+  return ret;
+}
+
+static insn_t
+loongarch_encode_imm (const char *bit_field, int32_t imm)
+{
+  char *bit_field_1 = (char *) bit_field;
+  char *t = bit_field_1;
+  int width, b_start;
+  insn_t ret = 0, i;
+
+  width = loongarch_get_bit_field_width (t, &t);
+  if (width == -1)
+    return ret;
+
+  if (*t == '<' && *(++t) == '<')
+    width += atoi (t + 1);
+  else if (*t == '+')
+    imm -= atoi (t + 1);
+
+  imm <<= sizeof (imm) * 8 - width;
+  while (1)
+    {
+      b_start = strtol (bit_field_1, &bit_field_1, 10);
+      if (*bit_field_1 != ':')
+	break;
+      width = strtol (bit_field_1 + 1, &bit_field_1, 10);
+      i = imm;
+      i >>= sizeof (i) * 8 - width;
+      i <<= b_start;
+      ret |= i;
+      imm <<= width;
+
+      if (*bit_field_1 != '|')
+	break;
+      bit_field_1++;
+    }
+  return ret;
+}
+
+/* parse such FORMAT
+     ""
+     "u"
+     "v0:5,r5:5,s10:10<<2"
+     "r0:5,r5:5,r10:5,u15:2+1"
+     "r,r,u0:5+32,u0:5+1"
+*/
+static int
+loongarch_parse_format (const char *format,
+			char *esc1s, char *esc2s, const char **bit_fields)
+{
+  size_t arg_num = 0;
+
+  if (*format == '\0')
+    goto end;
+
+  while (1)
+    {
+      /*        esc1    esc2
+	 for "[a-zA-Z][a-zA-Z]?" */
+      if (('a' <= *format && *format <= 'z')
+	  || ('A' <= *format && *format <= 'Z'))
+	{
+	  *esc1s++ = *format++;
+	  if (('a' <= *format && *format <= 'z')
+	      || ('A' <= *format && *format <= 'Z'))
+	    *esc2s++ = *format++;
+	  else
+	    *esc2s++ = '\0';
+	}
+      else
+	return -1;
+
+      arg_num++;
+      if (MAX_ARG_NUM_PLUS_2 - 2 < arg_num)
+	/* need larger MAX_ARG_NUM_PLUS_2 */
+	return -1;
+
+      *bit_fields++ = format;
+
+      if ('0' <= *format && *format <= '9')
+	{
+	  /* for "[0-9]+:[0-9]+(\|[0-9]+:[0-9]+)*" */
+	  while (1)
+	    {
+	      while ('0' <= *format && *format <= '9')
+		format++;
+
+	      if (*format != ':')
+		return -1;
+	      format++;
+
+	      if (!('0' <= *format && *format <= '9'))
+		return -1;
+	      while ('0' <= *format && *format <= '9')
+		format++;
+
+	      if (*format != '|')
+		break;
+	      format++;
+	    }
+
+	  /* for "((\+|<<)[1-9][0-9]*)?" */
+	  do
+	    {
+	      if (*format == '+')
+		format++;
+	      else if (format[0] == '<' && format[1] == '<')
+		format += 2;
+	      else
+		break;
+
+	      if (!('1' <= *format && *format <= '9'))
+		return -1;
+	      while ('0' <= *format && *format <= '9')
+		format++;
+	    }
+	  while (0);
+	}
+
+      if (*format == ',')
+	format++;
+      else if (*format == '\0')
+	break;
+      else
+	return -1;
+    }
+
+end:
+  *esc1s = '\0';
+  return 0;
+}
+
+size_t
+loongarch_split_args_by_comma (char *args, const char * arg_strs[])
+{
+  size_t num = 0;
+
+  if (*args)
+    arg_strs[num++] = args;
+  for (; *args; args++)
+    if (*args == ',')
+      {
+	if (MAX_ARG_NUM_PLUS_2 - 1 == num)
+	  break;
+	else
+	  *args = '\0', arg_strs[num++] = args + 1;
+      }
+  arg_strs[num] = NULL;
+  return num;
+}
+
+char *
+loongarch_cat_splited_strs (const char *arg_strs[])
+{
+  char *ret;
+  size_t n, l;
+
+  for (l = 0, n = 0; arg_strs[n]; n++)
+    l += strlen (arg_strs[n]);
+  ret = malloc (l + n + 1);
+  ret[0] = '\0';
+  if (0 < n)
+    strcat (ret, arg_strs[0]);
+  for (l = 1; l < n; l++)
+    strcat (ret, ","), strcat (ret, arg_strs[l]);
+  return ret;
+}
+
+insn_t
+loongarch_foreach_args (const char *format, const char *arg_strs[],
+			int32_t (*helper) (char esc1, char esc2,
+					   const char *bit_field,
+					   const char *arg, void *context),
+			void *context)
+{
+  char esc1s[MAX_ARG_NUM_PLUS_2 - 1], esc2s[MAX_ARG_NUM_PLUS_2 - 1];
+  const char *bit_fields[MAX_ARG_NUM_PLUS_2 - 1];
+  size_t i;
+  insn_t ret = 0;
+  int ok;
+
+  ok = loongarch_parse_format (format, esc1s, esc2s, bit_fields) == 0;
+
+  /* make sure the num of actual args is equal to the num of escape */
+  for (i = 0; esc1s[i] && arg_strs[i]; i++);
+  ok = ok && !esc1s[i] && !arg_strs[i];
+
+  if (ok && helper)
+    {
+      for (i = 0; arg_strs[i]; i++)
+	ret |= loongarch_encode_imm (bit_fields[i],
+		 helper (esc1s[i], esc2s[i], bit_fields[i],
+			 arg_strs[i], context));
+      ret |= helper ('\0', '\0', NULL, NULL, context);
+    }
+
+  return ret;
+}
+
+int
+loongarch_check_format (const char *format)
+{
+  char esc1s[MAX_ARG_NUM_PLUS_2 - 1], esc2s[MAX_ARG_NUM_PLUS_2 - 1];
+  const char *bit_fields[MAX_ARG_NUM_PLUS_2 - 1];
+
+  if (!format)
+    return -1;
+
+  return loongarch_parse_format (format, esc1s, esc2s, bit_fields);
+}
+
+int
+loongarch_check_macro (const char *format, const char *macro)
+{
+  int num_of_args;
+  char esc1s[MAX_ARG_NUM_PLUS_2 - 1], esc2s[MAX_ARG_NUM_PLUS_2 - 1];
+  const char *bit_fields[MAX_ARG_NUM_PLUS_2 - 1];
+
+  if (!format || !macro
+      || loongarch_parse_format (format, esc1s, esc2s, bit_fields) != 0)
+    return -1;
+
+  for (num_of_args = 0; esc1s[num_of_args]; num_of_args++);
+
+  for (; macro[0]; macro++)
+    if (macro[0] == '%')
+      {
+	macro++;
+	if ('1' <= macro[0] && macro[0] <= '9')
+	  {
+	    if (num_of_args < macro[0] - '0')
+	      /* out of args num */
+	      return -1;
+	  }
+	else if (macro[0] == 'f');
+	else if (macro[0] == '%');
+	else
+	  return -1;
+      }
+  return 0;
+}
+
+static const char *
+I (char esc_ch1 ATTRIBUTE_UNUSED,
+   char esc_ch2 ATTRIBUTE_UNUSED,
+   const char *c_str)
+{
+  return c_str;
+}
+
+char *
+loongarch_expand_macro_with_format_map (const char *format, const char *macro,
+					const char * const arg_strs[],
+					const char * (*map) (
+					  char esc1, char esc2,
+					  const char *arg),
+					char * (*helper) (
+					  const char * const arg_strs[],
+					  void *context),
+					void *context)
+{
+  char esc1s[MAX_ARG_NUM_PLUS_2 - 1], esc2s[MAX_ARG_NUM_PLUS_2 - 1];
+  const char *bit_fields[MAX_ARG_NUM_PLUS_2 - 1];
+  const char *src;
+  char *dest;
+  char buffer[8192];
+
+  if (format)
+    loongarch_parse_format (format, esc1s, esc2s, bit_fields);
+
+  src = macro;
+  dest = buffer;
+
+  while (*src)
+    if (*src == '%')
+      {
+	src++;
+	if ('1' <= *src && *src <= '9')
+	  {
+	    size_t i = *src - '1';
+	    const char *t = map (esc1s[i], esc2s[i], arg_strs[i]);
+	    while (*t)
+	      *dest++ = *t++;
+	  }
+	else if (*src == '%')
+	  *dest++ = '%';
+	else if (*src == 'f' && helper)
+	  {
+	    char *b, *t;
+	    t = b = (*helper) (arg_strs, context);
+	    if (b)
+	      {
+		while (*t)
+		  *dest++ = *t++;
+		free (b);
+	      }
+	  }
+	src++;
+      }
+    else
+      *dest++ = *src++;
+
+  *dest = '\0';
+  return strdup (buffer);
+}
+
+char *
+loongarch_expand_macro (const char *macro, const char * const arg_strs[],
+			char * (*helper) (const char * const arg_strs[],
+					  void *context),
+			void *context)
+{
+  return loongarch_expand_macro_with_format_map
+	   (NULL, macro, arg_strs, I, helper, context);
+}
+
+size_t
+loongarch_bits_imm_needed (int64_t imm, int si)
+{
+  size_t ret;
+  if (si)
+    {
+      if (imm < 0)
+	{
+	  for (ret = 0; imm < 0; imm <<= 1, ret++);
+	  ret = 64 - ret + 1;
+	}
+      else
+	ret = loongarch_bits_imm_needed (imm, 0) + 1;
+    }
+  else
+    {
+      uint64_t t = imm;
+      for (ret = 0; t; t >>= 1, ret++);
+    }
+  return ret;
+}
+
+void
+loongarch_eliminate_adjacent_repeat_char (char *dest, char c)
+{
+  if (c == '\0')
+    return;
+  char *src = dest;
+  while (*dest)
+    {
+      while (src[0] == c && src[0] == src[1])
+	src++;
+      *dest++ = *src++;
+    }
+}
diff --git a/opcodes/loongarch-dis.c b/opcodes/loongarch-dis.c
new file mode 100644
index 00000000000..05fb8bdbeb1
--- /dev/null
+++ b/opcodes/loongarch-dis.c
@@ -0,0 +1,311 @@
+#include "sysdep.h"
+#include "disassemble.h"
+#include "opintl.h"
+#include "opcode/loongarch.h"
+#include <stdlib.h>
+
+static const struct loongarch_opcode *
+get_loongarch_opcode_by_binfmt (insn_t insn)
+{
+  const struct loongarch_opcode *it;
+  struct loongarch_ase *ase;
+  size_t i;
+  for (ase = loongarch_ASEs; ase->enabled; ase++)
+    {
+      if (!*ase->enabled
+          || (ase->include && !*ase->include)
+	  || (ase->exclude && *ase->exclude))
+	continue;
+
+      if (!ase->opc_htab_inited)
+	{
+	  for (it = ase->opcodes; it->mask; it++)
+	    if (!ase->opc_htab[LARCH_INSN_OPC (it->match)]
+		&& it->macro == NULL)
+	    ase->opc_htab[LARCH_INSN_OPC (it->match)] = it;
+	  for (i = 0; i < 16; i++)
+	    if (!ase->opc_htab[i])
+	      ase->opc_htab[i] = it;
+	  ase->opc_htab_inited = 1;
+	}
+
+      it = ase->opc_htab[LARCH_INSN_OPC(insn)];
+      for (; it->name; it++)
+	if ((insn & it->mask) == it->match
+	    && it->mask
+	    && !(it->include && !*it->include)
+	    && !(it->exclude && *it->exclude))
+	  return it;
+    }
+  return NULL;
+}
+
+static const char * const *loongarch_r_disname = NULL;
+static const char * const *loongarch_f_disname = NULL;
+static const char * const *loongarch_c_disname = NULL;
+static const char * const *loongarch_cr_disname = NULL;
+static const char * const *loongarch_v_disname = NULL;
+static const char * const *loongarch_x_disname = NULL;
+
+static void
+set_default_loongarch_dis_options (void)
+{
+  LARCH_opts.ase_test = 1;
+  LARCH_opts.ase_fix = 1;
+  LARCH_opts.ase_float = 1;
+  LARCH_opts.ase_128vec = 1;
+  LARCH_opts.ase_256vec = 1;
+
+  loongarch_r_disname = loongarch_r_normal_name;
+  loongarch_f_disname = loongarch_f_normal_name;
+  loongarch_c_disname = loongarch_c_normal_name;
+  loongarch_cr_disname = loongarch_cr_normal_name;
+  loongarch_v_disname = loongarch_v_normal_name;
+  loongarch_x_disname = loongarch_x_normal_name;
+}
+
+static int
+parse_loongarch_dis_option (const char *option ATTRIBUTE_UNUSED)
+{
+  return -1;
+}
+
+static int
+parse_loongarch_dis_options (const char *opts_in)
+{
+  set_default_loongarch_dis_options ();
+
+  if (opts_in == NULL)
+    return 0;
+
+  char opts[strlen (opts_in) + 1], *opt, *opt_end;
+  strcpy (opts, opts_in);
+
+  for (opt = opt_end = opts; opt_end != NULL; opt = opt_end + 1)
+    {
+      if ((opt_end = strchr (opt, ',')) != NULL)
+	*opt_end = 0;
+      if (parse_loongarch_dis_option (opt) != 0)
+	return -1;
+    }
+  return 0;
+}
+
+static int32_t
+dis_one_arg (char esc1, char esc2, const char *bit_field,
+	     const char *arg ATTRIBUTE_UNUSED, void *context)
+{
+  static int need_comma = 0;
+  struct disassemble_info *info = context;
+  insn_t insn = *(insn_t *) info->private_data;
+  int32_t imm, u_imm;
+
+  if (esc1)
+    {
+      if (need_comma)
+	info->fprintf_func (info->stream, ",");
+      need_comma = 1;
+      imm = loongarch_decode_imm (bit_field, insn, 1);
+      u_imm = loongarch_decode_imm (bit_field, insn, 0);
+    }
+
+  switch (esc1)
+    {
+    case 'r':
+      info->fprintf_func (info->stream, "%s", loongarch_r_disname[u_imm]);
+      break;
+    case 'f':
+      info->fprintf_func (info->stream, "%s", loongarch_f_disname[u_imm]);
+      break;
+    case 'c':
+      switch (esc2)
+	{
+	case 'r':
+	  info->fprintf_func (info->stream, "%s", loongarch_cr_disname[u_imm]);
+	  break;
+	default:
+	  info->fprintf_func (info->stream, "%s", loongarch_c_disname[u_imm]);
+	}
+      break;
+    case 'v':
+      info->fprintf_func (info->stream, "%s", loongarch_v_disname[u_imm]);
+      break;
+    case 'x':
+      info->fprintf_func (info->stream, "%s", loongarch_x_disname[u_imm]);
+      break;
+    case 'u':
+      info->fprintf_func (info->stream, "0x%x", u_imm);
+      break;
+    case 's':
+      if (imm == 0)
+	info->fprintf_func (info->stream, "%d", imm);
+      else
+	info->fprintf_func (info->stream, "%d(0x%x)", imm, u_imm);
+      switch (esc2)
+	{
+	case 'b':
+	  info->insn_type = dis_branch;
+	  info->target += imm;
+	}
+      break;
+    case '\0':
+      need_comma = 0;
+    }
+  return 0;
+}
+
+static void
+disassemble_one (insn_t insn, struct disassemble_info *info)
+{
+  const struct loongarch_opcode *opc = get_loongarch_opcode_by_binfmt (insn);
+
+#ifdef LOONGARCH_DEBUG
+  char have_space[32] = {0};
+  insn_t t;
+  int i;
+  const char *t_f = opc ? opc->format : NULL;
+  if(t_f)
+    while (*t_f)
+      {
+	while (('a' <= t_f[0] && t_f[0] <= 'z')
+	       || ('A' <= t_f[0] && t_f[0] <= 'Z')
+	       t_f[0] == ',')
+	  t_f++;
+	while (1)
+	  {
+	    i = strtol (t_f, &t_f, 10);
+	    have_space[i] = 1;
+	    t_f++; //':'
+	    i += strtol (t_f, &t_f, 10);
+	    have_space[i] = 1;
+	    if (t_f[0] == '|')
+	      t_f++;
+	    else
+	      break;
+	  }
+	if (t_f[0] == '<')
+	  t_f += 2; // '<' '<'
+	strtol (t_f, &t_f, 10);
+      }
+
+  have_space[28] = 1;
+  have_space[0] = 0;
+  t = ~((insn_t)-1 >> 1);
+  for (i = 31; 0 <= i ; i--)
+    {
+      if (t & insn)
+	info->fprintf_func (info->stream, "1");
+      else
+	info->fprintf_func (info->stream, "0");
+      if (have_space[i])
+	info->fprintf_func (info->stream, " ");
+      t = t >> 1;
+    }
+  info->fprintf_func (info->stream, "\t");
+#endif
+
+  if (!opc)
+    {
+      info->insn_type = dis_noninsn;
+      info->fprintf_func (info->stream, "0x%08x", insn);
+      return;
+    }
+
+  info->insn_type = dis_nonbranch;
+  info->fprintf_func (info->stream, "%s", opc->name);
+
+  {
+    char fake_args[strlen (opc->format) + 1];
+    const char *fake_arg_strs[MAX_ARG_NUM_PLUS_2];
+    strcpy (fake_args, opc->format);
+    if (0 < loongarch_split_args_by_comma (fake_args, fake_arg_strs))
+      info->fprintf_func (info->stream, "\t");
+    info->private_data = &insn;
+    loongarch_foreach_args (opc->format, fake_arg_strs, dis_one_arg, info);
+  }
+
+  if (info->insn_type == dis_branch || info->insn_type == dis_condbranch
+      /* || someother if we have extra info to print */)
+    info->fprintf_func (info->stream, " #");
+
+  if (info->insn_type == dis_branch || info->insn_type == dis_condbranch)
+    {
+      info->fprintf_func (info->stream, " ");
+      info->print_address_func (info->target, info);
+    }
+}
+
+int
+print_insn_loongarch (bfd_vma memaddr, struct disassemble_info *info)
+{
+  insn_t insn;
+  int status;
+
+  static int not_init_yet = 1;
+  if (not_init_yet)
+    {
+      parse_loongarch_dis_options (info->disassembler_options);
+      not_init_yet = 0;
+    }
+
+  info->bytes_per_chunk = 4;
+  info->bytes_per_line = 4;
+  info->display_endian = BFD_ENDIAN_LITTLE;
+  info->insn_info_valid = 1;
+  info->target = memaddr;
+
+  if ((status = info->read_memory_func
+		  (memaddr, (bfd_byte *) &insn, sizeof (insn), info))
+      != 0)
+    {
+      info->memory_error_func (status, memaddr, info);
+      return loongarch_insn_length (0);
+    }
+
+  disassemble_one (insn, info);
+
+  return loongarch_insn_length (insn);
+}
+
+void
+print_loongarch_disassembler_options (FILE *stream)
+{
+    fprintf (stream, _("\n\
+		       LoongISA:\n"));
+
+    fprintf (stream, _("\n"));
+}
+
+int
+loongarch_parse_dis_options (const char *opts_in)
+{
+  return parse_loongarch_dis_options (opts_in);
+}
+
+static void
+my_print_address_func (bfd_vma addr, struct disassemble_info *dinfo)
+{
+  dinfo->fprintf_func (dinfo->stream, "0x%llx", (long long) addr);
+}
+
+void
+loongarch_disassemble_one (int64_t pc, insn_t insn,
+			   int (*fprintf_func)
+			     (void *stream, const char *format, ...),
+			   void *stream)
+{
+  static struct disassemble_info my_disinfo = {
+    .print_address_func = my_print_address_func,
+  };
+  static int not_init_yet = 1;
+  if (not_init_yet)
+    {
+      loongarch_parse_dis_options (NULL);
+      not_init_yet = 0;
+    }
+
+  my_disinfo.fprintf_func = fprintf_func;
+  my_disinfo.stream = stream;
+  my_disinfo.target = pc;
+  disassemble_one (insn, &my_disinfo);
+}
diff --git a/opcodes/loongarch-opc.c b/opcodes/loongarch-opc.c
new file mode 100644
index 00000000000..9dce38172d4
--- /dev/null
+++ b/opcodes/loongarch-opc.c
@@ -0,0 +1,1199 @@
+#include <stddef.h>
+#include "opcode/loongarch.h"
+
+struct loongarch_ASEs_option LARCH_opts =
+{
+  .ase_test = 0,
+  .ase_fix = 0,
+  .ase_float = 0,
+  .ase_128vec = 0,
+  .ase_256vec = 0,
+
+  .addrwidth_is_32 = 0,
+  .addrwidth_is_64 = 0,
+  .rlen_is_32 = 0,
+  .rlen_is_64 = 0,
+  .la_local_with_abs = 0,
+  .la_global_with_pcrel = 0,
+  .la_global_with_abs = 0,
+
+  .abi_is_lp32 = 0,
+  .abi_is_lp64 = 0,
+};
+
+/* 预留。按理来说应该传入足够的信息使得这个函数可以返回指令长度 */
+size_t loongarch_insn_length (insn_t insn)
+{
+  return insn ? 4 : 4; /* eliminate warning */
+}
+
+const char * const loongarch_r_normal_name[32] =
+{
+  "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
+  "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
+  "$r16", "$r17", "$r18", "$r19", "$r20", "$r21", "$r22", "$r23",
+  "$r24", "$r25", "$r26", "$r27", "$r28", "$r29", "$r30", "$r31",
+};
+
+const char * const loongarch_r_lp64_name[32] =
+{
+  "$zero", "$ra", "$tp", "$sp", "$a0", "$a1", "$a2", "$a3",
+  "$a4", "$a5", "$a6", "$a7", "$t0", "$t1", "$t2", "$t3",
+  "$t4", "$t5", "$t6", "$t7", "$t8", "$x", "$fp", "$s0",
+  "$s1", "$s2", "$s3", "$s4", "$s5", "$s6", "$s7", "$s8",
+};
+
+const char * const loongarch_r_lp64_name1[32] =
+{
+  "", "", "", "", "$v0", "$v1", "", "",
+  "", "", "", "", "", "", "", "",
+  "", "", "", "", "", "", "", "",
+  "", "", "", "", "", "", "", "",
+};
+
+const char * const loongarch_f_normal_name[32] =
+{
+  "$f0", "$f1", "$f2", "$f3", "$f4", "$f5", "$f6", "$f7",
+  "$f8", "$f9", "$f10", "$f11", "$f12", "$f13", "$f14", "$f15",
+  "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23",
+  "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31",
+};
+
+const char * const loongarch_f_lp64_name[32] =
+{
+  "$fa0", "$fa1", "$fa2", "$fa3", "$fa4", "$fa5", "$fa6", "$fa7",
+  "$ft0", "$ft1", "$ft2", "$ft3", "$ft4", "$ft5", "$ft6", "$ft7",
+  "$ft8", "$ft9", "$ft10", "$ft11", "$ft12", "$ft13", "$ft14", "$ft15",
+  "$fs0", "$fs1", "$fs2", "$fs3", "$fs4", "$fs5", "$fs6", "$fs7",
+};
+
+const char * const loongarch_f_lp64_name1[32] =
+{
+  "$fv0", "$fv1", "", "", "", "", "", "",
+  "", "", "", "", "", "", "", "",
+  "", "", "", "", "", "", "", "",
+  "", "", "", "", "", "", "", "",
+};
+
+const char * const loongarch_c_normal_name[8] =
+{
+  "$fcc0", "$fcc1", "$fcc2", "$fcc3", "$fcc4", "$fcc5", "$fcc6", "$fcc7",
+};
+
+
+const char * const loongarch_cr_normal_name[4] =
+{
+  "$scr0", "$scr1", "$scr2", "$scr3",
+};
+
+const char * const loongarch_v_normal_name[32] =
+{
+  "$vr0", "$vr1", "$vr2", "$vr3", "$vr4", "$vr5", "$vr6", "$vr7",
+  "$vr8", "$vr9", "$vr10", "$vr11", "$vr12", "$vr13", "$vr14", "$vr15",
+  "$vr16", "$vr17", "$vr18", "$vr19", "$vr20", "$vr21", "$vr22", "$vr23",
+  "$vr24", "$vr25", "$vr26", "$vr27", "$vr28", "$vr29", "$vr30", "$vr31",
+};
+
+const char * const loongarch_x_normal_name[32] =
+{
+  "$xr0", "$xr1", "$xr2", "$xr3", "$xr4", "$xr5", "$xr6", "$xr7",
+  "$xr8", "$xr9", "$xr10", "$xr11", "$xr12", "$xr13", "$xr14", "$xr15",
+  "$xr16", "$xr17", "$xr18", "$xr19", "$xr20", "$xr21", "$xr22", "$xr23",
+  "$xr24", "$xr25", "$xr26", "$xr27", "$xr28", "$xr29", "$xr30", "$xr31",
+};
+
+#define SOME_INFORMATION 0
+const int ALWAYS_EXCLUSION = 1;
+static int FIX_FOR_SOME_ARCH = 1;
+
+static struct loongarch_opcode loongarch_test_opcodes[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+{
+0, 0, "a insn always excluded",	"r0:5,r5:5,r10:5",
+"insn_1 args_1"
+"insn_2 args_2"
+, 0, &ALWAYS_EXCLUSION, SOME_INFORMATION
+},
+{
+0, 0,
+"never disassemble when mask is 0"
+"and we only expand marco when mask is 0 for assemble",
+"r", "macro expand %1"
+, 0, 0, 0
+},
+{0, 0, "wrong_insn", "r",
+"throw_error use_fake_insn.for_example.something_goes_wrong_with_%1"
+, 0, 0, 0},
+
+{0, 0, "normal_insn", "r",
+"overloading of insn for your arch", &FIX_FOR_SOME_ARCH, 0, 0},
+{0, 0, "normal_insn", "l",
+"throw_error if_you_dont_want", &FIX_FOR_SOME_ARCH, 0, 0},
+
+{0, 0, "normal_insn", "r", "", 0, 0, 0},
+{0, 0, "normal_insn", "l", "", 0, 0, 0},
+{0} /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_macro_opcodes[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+{0, 0, "throw_error", "l", "%f", 0, 0, 0},
+{0, 0, "li", "r,sc", "%f", 0, 0, 0},
+{0, 0, "li.w", "r,sc", "%f", 0, 0, 0},
+{0, 0, "dli", "r,sc", "%f", 0, 0, 0},
+{0, 0, "li.d", "r,sc", "%f", 0, 0, 0},
+
+{0, 0, "la", "r,la", "la.global %1,%2", 0, 0, 0},
+
+{0, 0, "la.global", "r,la", "la.pcrel %1,%2", &LARCH_opts.la_global_with_pcrel, 0, 0},
+{0, 0, "la.global", "r,r,la", "la.pcrel %1,%2,%3", &LARCH_opts.la_global_with_pcrel, 0, 0},
+{0, 0, "la.global", "r,la", "la.abs %1,%2", &LARCH_opts.la_global_with_abs, 0, 0},
+{0, 0, "la.global", "r,r,la", "la.abs %1,%3", &LARCH_opts.la_global_with_abs, 0, 0},
+{0, 0, "la.global", "r,l", "la.got %1,%2", 0, 0, 0},
+{0, 0, "la.global", "r,r,l", "la.got %1,%2,%3", 0, 0, 0},
+
+{0, 0, "la.local", "r,la", "la.abs %1,%2", &LARCH_opts.la_local_with_abs, 0, 0},
+{0, 0, "la.local", "r,r,la", "la.abs %1,%3", &LARCH_opts.la_local_with_abs, 0, 0},
+{0, 0, "la.local", "r,la", "la.pcrel %1,%2", 0, 0, 0},
+{0, 0, "la.local", "r,r,la", "la.pcrel %1,%2,%3", 0, 0, 0},
+
+{0, 0, "la.abs", "r,la",
+"lu12i.w %1,%%abs(%2)>>12;"
+"ori %1,%1,%%abs(%2)&0xfff;"
+, &LARCH_opts.addrwidth_is_32, 0, 0},
+{0, 0, "la.abs", "r,la",
+"lu12i.w %1,%%abs(%2)<<32>>44;"
+"ori %1,%1,%%abs(%2)&0xfff;"
+"lu32i.d %1,%%abs(%2)<<12>>44;"
+"lu52i.d %1,%1,%%abs(%2)>>52;"
+, &LARCH_opts.addrwidth_is_64, 0, 0},
+
+{0, 0, "la.pcrel", "r,la",
+"pcaddu12i %1,%%pcrel(%2+0x800)<<32>>44;"
+"addi.w %1,%1,%%pcrel(%2+4)-(%%pcrel(%2+4+0x800)>>12<<12);"
+, &LARCH_opts.addrwidth_is_32, 0, 0},
+
+{0, 0, "la.pcrel", "r,la",
+"pcaddu12i %1,%%pcrel(%2+0x800)>>12;"
+"addi.d %1,%1,%%pcrel(%2+4)-(%%pcrel(%2+4+0x800)>>12<<12);"
+, &LARCH_opts.addrwidth_is_64, 0, 0},
+{0, 0, "la.pcrel", "r,r,la",
+"pcaddu12i %1,(%%pcrel(%3)-(%%pcrel(%3+0x80000000)>>32<<32))<<32>>44;"
+"ori %2,$r0,(%%pcrel(%3+4)-(%%pcrel(%3+4+0x80000000)>>32<<32))&0xfff;"
+"lu32i.d %2,%%pcrel(%3+8+0x80000000)<<12>>44;"
+"lu52i.d %2,%2,%%pcrel(%3+12+0x80000000)>>52;"
+"add.d %1,%1,%2;"
+, &LARCH_opts.addrwidth_is_64, 0, 0},
+
+{0, 0, "la.got", "r,l",
+"pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_+0x800)+%%gprel(%2))<<32>>44;"
+"ld.w %1,%1,%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%gprel(%2)-((%%pcrel(_GLOBAL_OFFSET_TABLE_+4+0x800)+%%gprel(%2))>>12<<12);"
+, &LARCH_opts.addrwidth_is_32, 0, 0},
+
+{0, 0, "la.got", "r,l",
+"pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_+0x800)+%%gprel(%2))>>12;"
+"ld.d %1,%1,%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%gprel(%2)-((%%pcrel(_GLOBAL_OFFSET_TABLE_+4+0x800)+%%gprel(%2))>>12<<12);"
+, &LARCH_opts.addrwidth_is_64, 0, 0},
+{0, 0, "la.got", "r,r,l",
+"pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_)+%%gprel(%3)-((%%pcrel(_GLOBAL_OFFSET_TABLE_+0x80000000)+%%gprel(%3))>>32<<32))<<32>>44;"
+"ori %2,$r0,(%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%gprel(%3)-((%%pcrel(_GLOBAL_OFFSET_TABLE_+4+0x80000000)+%%gprel(%3))>>32<<32))&0xfff;"
+"lu32i.d %2,(%%pcrel(_GLOBAL_OFFSET_TABLE_+8+0x80000000)+%%gprel(%3))<<12>>44;"
+"lu52i.d %2,%2,(%%pcrel(_GLOBAL_OFFSET_TABLE_+12+0x80000000)+%%gprel(%3))>>52;"
+"ldx.d %1,%1,%2;"
+, &LARCH_opts.addrwidth_is_64, 0, 0},
+
+{0, 0, "la.tls.le", "r,la",
+"lu12i.w %1,%%tprel(%2)>>12;"
+"ori %1,%1,%%tprel(%2)&0xfff"
+, &LARCH_opts.addrwidth_is_32, 0, 0},
+//{0, 0, "la.tls.le", "r,la",
+//"lu12i.w %1,%%tprel(%2)>>12;"
+//"ori %1,%1,%%tprel(%2)&0xfff"
+//, &LARCH_opts.addrwidth_is_64, 0, 0},
+{0, 0, "la.tls.le", "r,la",
+"lu12i.w %1,%%tprel(%2)<<32>>44;"
+"ori %1,%1,%%tprel(%2)&0xfff;"
+"lu32i.d %1,%%tprel(%2)<<12>>44;"
+"lu52i.d %1,%1,%%tprel(%2)>>52;"
+, &LARCH_opts.addrwidth_is_64, 0, 0},
+
+{0, 0, "la.tls.ie", "r,l",
+"pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_+0x800)+%%tlsgot(%2))<<32>>44;"
+"ld.w %1,%1,%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%tlsgot(%2)-((%%pcrel(_GLOBAL_OFFSET_TABLE_+4+0x800)+%%tlsgot(%2))>>12<<12);"
+, &LARCH_opts.addrwidth_is_32, 0, 0},
+
+{0, 0, "la.tls.ie", "r,l",
+"pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_+0x800)+%%tlsgot(%2))>>12;"
+"ld.d %1,%1,%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%tlsgot(%2)-((%%pcrel(_GLOBAL_OFFSET_TABLE_+4+0x800)+%%tlsgot(%2))>>12<<12);"
+, &LARCH_opts.addrwidth_is_64, 0, 0},
+{0, 0, "la.tls.ie", "r,r,l",
+"pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_)+%%tlsgot(%3)-((%%pcrel(_GLOBAL_OFFSET_TABLE_+0x80000000)+%%tlsgot(%3))>>32<<32))<<32>>44;"
+"ori %2,$r0,(%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%tlsgot(%3)-((%%pcrel(_GLOBAL_OFFSET_TABLE_+4+0x80000000)+%%tlsgot(%3))>>32<<32))&0xfff;"
+"lu32i.d %2,(%%pcrel(_GLOBAL_OFFSET_TABLE_+8+0x80000000)+%%tlsgot(%3))<<12>>44;"
+"lu52i.d %2,%2,(%%pcrel(_GLOBAL_OFFSET_TABLE_+12+0x80000000)+%%tlsgot(%3))>>52;"
+"ldx.d %1,%1,%2;"
+, &LARCH_opts.addrwidth_is_64, 0, 0},
+
+{0, 0, "la.tls.ld", "r,l", "la.tls.gd %1,%2", 0, 0, 0},
+{0, 0, "la.tls.ld", "r,r,l",
+"la.tls.gd %1,%2,%3"
+, &LARCH_opts.addrwidth_is_64, 0, 0},
+
+
+{0, 0, "la.tls.gd", "r,l",
+"pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_+0x800)+%%tlsgd(%2))<<32>>44;"
+"addi.w %1,%1,%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%tlsgd(%2)-((%%pcrel(_GLOBAL_OFFSET_TABLE_+4+0x800)+%%tlsgd(%2))>>12<<12);"
+, &LARCH_opts.addrwidth_is_32, 0, 0},
+
+{0, 0, "la.tls.gd", "r,l",
+"pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_+0x800)+%%tlsgd(%2))>>12;"
+"addi.d %1,%1,%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%tlsgd(%2)-((%%pcrel(_GLOBAL_OFFSET_TABLE_+4+0x800)+%%tlsgd(%2))>>12<<12);"
+, &LARCH_opts.addrwidth_is_64, 0, 0},
+{0, 0, "la.tls.gd", "r,r,l",
+"pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_)+%%tlsgd(%3)-((%%pcrel(_GLOBAL_OFFSET_TABLE_+0x80000000)+%%tlsgd(%3))>>32<<32))<<32>>44;"
+"ori %2,$r0,(%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%tlsgd(%3)-((%%pcrel(_GLOBAL_OFFSET_TABLE_+4+0x80000000)+%%tlsgd(%3))>>32<<32))&0xfff;"
+"lu32i.d %2,(%%pcrel(_GLOBAL_OFFSET_TABLE_+8+0x80000000)+%%tlsgd(%3))<<12>>44;"
+"lu52i.d %2,%2,(%%pcrel(_GLOBAL_OFFSET_TABLE_+12+0x80000000)+%%tlsgd(%3))>>52;"
+"add.d %1,%1,%2;"
+, &LARCH_opts.addrwidth_is_64, 0, 0},
+
+{0} /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_fix_opcodes[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+{0x00000800, 0xfffffc1c, "gr2scr", "cr0:2,r5:5", 0, 0, 0, 0},
+{0x00000c00, 0xffffff80, "scr2gr", "r0:5,cr5:2", 0, 0, 0, 0},
+{0x00001000, 0xfffffc00, "clo.w", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00001400, 0xfffffc00, "clz.w", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00001800, 0xfffffc00, "cto.w", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00001c00, 0xfffffc00, "ctz.w", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00002000, 0xfffffc00, "clo.d", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00002400, 0xfffffc00, "clz.d", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00002800, 0xfffffc00, "cto.d", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00002c00, 0xfffffc00, "ctz.d", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00003000, 0xfffffc00, "revb.2h", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00003400, 0xfffffc00, "revb.4h", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00003800, 0xfffffc00, "revb.2w", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00003c00, 0xfffffc00, "revb.d", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00004000, 0xfffffc00, "revh.2w", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00004400, 0xfffffc00, "revh.d", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00004800, 0xfffffc00, "bitrev.4b", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00004c00, 0xfffffc00, "bitrev.8b", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00005000, 0xfffffc00, "bitrev.w", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00005400, 0xfffffc00, "bitrev.d", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00005800, 0xfffffc00, "ext.w.h", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00005c00, 0xfffffc00, "ext.w.b", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00006000, 0xfffffc00, "rdtimel.w", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00006400, 0xfffffc00, "rdtimeh.w", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00006800, 0xfffffc00, "rdtime.d", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00006c00, 0xfffffc00, "cpucfg", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00007000, 0xffffff1f, "x86mttop", "u5:3", 0, 0, 0, 0},
+{0x00007400, 0xffffffe0, "x86mftop", "r0:5", 0, 0, 0, 0},
+{0x00007800, 0xfffffc00, "x86loope", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00007c00, 0xfffffc00, "x86loopne", "r0:5,r5:5", 0, 0, 0, 0},
+{0x00008000, 0xfffffc1f, "x86inc.b", "r5:5", 0, 0, 0, 0},
+{0x00008001, 0xfffffc1f, "x86inc.h", "r5:5", 0, 0, 0, 0},
+{0x00008002, 0xfffffc1f, "x86inc.w", "r5:5", 0, 0, 0, 0},
+{0x00008003, 0xfffffc1f, "x86inc.d", "r5:5", 0, 0, 0, 0},
+{0x00008004, 0xfffffc1f, "x86dec.b", "r5:5", 0, 0, 0, 0},
+{0x00008005, 0xfffffc1f, "x86dec.h", "r5:5", 0, 0, 0, 0},
+{0x00008006, 0xfffffc1f, "x86dec.w", "r5:5", 0, 0, 0, 0},
+{0x00008007, 0xfffffc1f, "x86dec.d", "r5:5", 0, 0, 0, 0},
+{0x00008008, 0xffffffff, "x86settm", "", 0, 0, 0, 0},
+{0x00008028, 0xffffffff, "x86clrtm", "", 0, 0, 0, 0},
+{0x00008009, 0xffffffff, "x86inctop", "", 0, 0, 0, 0},
+{0x00008029, 0xffffffff, "x86dectop", "", 0, 0, 0, 0},
+{0x00010000, 0xffff801f, "asrtle.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x00018000, 0xffff801f, "asrtgt.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x00040000, 0xfffe0000, "alsl.w", "r0:5,r5:5,r10:5,u15:2+1", 0, 0, 0, 0},
+{0x00060000, 0xfffe0000, "alsl.wu", "r0:5,r5:5,r10:5,u15:2+1", 0, 0, 0, 0},
+{0x00080000, 0xfffe0000, "bytepick.w", "r0:5,r5:5,r10:5,u15:2", 0, 0, 0, 0},
+{0x000c0000, 0xfffc0000, "bytepick.d", "r0:5,r5:5,r10:5,u15:3", 0, 0, 0, 0},
+{0x00100000, 0xffff8000, "add.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00108000, 0xffff8000, "add.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00110000, 0xffff8000, "sub.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00118000, 0xffff8000, "sub.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00120000, 0xffff8000, "slt", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00128000, 0xffff8000, "sltu", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00130000, 0xffff8000, "maskeqz", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00138000, 0xffff8000, "masknez", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00140000, 0xffff8000, "nor", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00148000, 0xffff8000, "and", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00150000, 0xfffffc00, "move", "r0:5,r5:5", 0/* or %1,%2,$r0 */, 0, 0, 0},
+{0x00150000, 0xffff8000, "or", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00158000, 0xffff8000, "xor", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00160000, 0xffff8000, "orn", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00168000, 0xffff8000, "andn", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00170000, 0xffff8000, "sll.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00178000, 0xffff8000, "srl.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00180000, 0xffff8000, "sra.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00188000, 0xffff8000, "sll.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00190000, 0xffff8000, "srl.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00198000, 0xffff8000, "sra.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x001a0000, 0xffff8000, "rotr.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x001a8000, 0xffff8000, "rotr.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x001b0000, 0xffff8000, "rotr.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x001b8000, 0xffff8000, "rotr.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x001c0000, 0xffff8000, "mul.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x001c8000, 0xffff8000, "mulh.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x001d0000, 0xffff8000, "mulh.wu", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x001d8000, 0xffff8000, "mul.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x001e0000, 0xffff8000, "mulh.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x001e8000, 0xffff8000, "mulh.du", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x001f0000, 0xffff8000, "mulw.d.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x001f8000, 0xffff8000, "mulw.d.wu", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00200000, 0xffff8000, "div.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00208000, 0xffff8000, "mod.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00210000, 0xffff8000, "div.wu", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00218000, 0xffff8000, "mod.wu", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00220000, 0xffff8000, "div.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00228000, 0xffff8000, "mod.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00230000, 0xffff8000, "div.du", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00238000, 0xffff8000, "mod.du", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00240000, 0xffff8000, "crc.w.b.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00248000, 0xffff8000, "crc.w.h.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00250000, 0xffff8000, "crc.w.w.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00258000, 0xffff8000, "crc.w.d.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00260000, 0xffff8000, "crcc.w.b.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00268000, 0xffff8000, "crcc.w.h.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00270000, 0xffff8000, "crcc.w.w.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00278000, 0xffff8000, "crcc.w.d.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00290000, 0xffff8000, "addu12i.w", "r0:5,r5:5,s10:5", 0, 0, 0, 0},
+{0x00298000, 0xffff8000, "addu12i.d", "r0:5,r5:5,s10:5", 0, 0, 0, 0},
+{0x002a0000, 0xffff8000, "break", "u0:15", 0, 0, 0, 0},
+{0x002a8000, 0xffff8000, "dbgcall", "u0:15", 0, 0, 0, 0},
+{0x002b0000, 0xffff8000, "syscall", "u0:15", 0, 0, 0, 0},
+{0x002b8000, 0xffff8000, "hypcall", "u0:15", 0, 0, 0, 0},
+{0x002c0000, 0xfffe0000, "alsl.d", "r0:5,r5:5,r10:5,u15:2+1", 0, 0, 0, 0},
+{0x00300000, 0xffff8000, "adc.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00308000, 0xffff8000, "adc.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00310000, 0xffff8000, "adc.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00318000, 0xffff8000, "adc.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00320000, 0xffff8000, "sbc.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00328000, 0xffff8000, "sbc.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00330000, 0xffff8000, "sbc.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00338000, 0xffff8000, "sbc.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00340000, 0xffff8000, "rcr.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00348000, 0xffff8000, "rcr.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00350000, 0xffff8000, "rcr.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00358000, 0xffff8000, "rcr.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x00364000, 0xffffc000, "armmove", "r0:5,r5:5,u10:4", 0, 0, 0, 0},
+{0x00368000, 0xffffc3e0, "setx86j", "r0:5,u10:4", 0, 0, 0, 0},
+{0x0036c000, 0xffffc3e0, "setarmj", "r0:5,u10:4", 0, 0, 0, 0},
+{0x00370010, 0xffff8010, "armadd.w", "r5:5,r10:5,u0:4", 0, 0, 0, 0},
+{0x00378010, 0xffff8010, "armsub.w", "r5:5,r10:5,u0:4", 0, 0, 0, 0},
+{0x00380010, 0xffff8010, "armadc.w", "r5:5,r10:5,u0:4", 0, 0, 0, 0},
+{0x00388010, 0xffff8010, "armsbc.w", "r5:5,r10:5,u0:4", 0, 0, 0, 0},
+{0x00390010, 0xffff8010, "armand.w", "r5:5,r10:5,u0:4", 0, 0, 0, 0},
+{0x00398010, 0xffff8010, "armor.w", "r5:5,r10:5,u0:4", 0, 0, 0, 0},
+{0x003a0010, 0xffff8010, "armxor.w", "r5:5,r10:5,u0:4", 0, 0, 0, 0},
+{0x003a8010, 0xffff8010, "armsll.w", "r5:5,r10:5,u0:4", 0, 0, 0, 0},
+{0x003b0010, 0xffff8010, "armsrl.w", "r5:5,r10:5,u0:4", 0, 0, 0, 0},
+{0x003b8010, 0xffff8010, "armsra.w", "r5:5,r10:5,u0:4", 0, 0, 0, 0},
+{0x003c0010, 0xffff8010, "armrotr.w", "r5:5,r10:5,u0:4", 0, 0, 0, 0},
+{0x003c8010, 0xffff8010, "armslli.w", "r5:5,u10:5,u0:4", 0, 0, 0, 0},
+{0x003d0010, 0xffff8010, "armsrli.w", "r5:5,u10:5,u0:4", 0, 0, 0, 0},
+{0x003d8010, 0xffff8010, "armsrai.w", "r5:5,u10:5,u0:4", 0, 0, 0, 0},
+{0x003e0010, 0xffff8010, "armrotri.w", "r5:5,u10:5,u0:4", 0, 0, 0, 0},
+{0x003e8000, 0xffff801f, "x86mul.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003e8001, 0xffff801f, "x86mul.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003e8002, 0xffff801f, "x86mul.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003e8003, 0xffff801f, "x86mul.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003e8004, 0xffff801f, "x86mul.bu", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003e8005, 0xffff801f, "x86mul.hu", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003e8006, 0xffff801f, "x86mul.wu", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003e8007, 0xffff801f, "x86mul.du", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0000, 0xffff801f, "x86add.wu", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0001, 0xffff801f, "x86add.du", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0002, 0xffff801f, "x86sub.wu", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0003, 0xffff801f, "x86sub.du", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0004, 0xffff801f, "x86add.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0005, 0xffff801f, "x86add.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0006, 0xffff801f, "x86add.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0007, 0xffff801f, "x86add.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0008, 0xffff801f, "x86sub.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0009, 0xffff801f, "x86sub.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f000a, 0xffff801f, "x86sub.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f000b, 0xffff801f, "x86sub.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f000c, 0xffff801f, "x86adc.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f000d, 0xffff801f, "x86adc.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f000e, 0xffff801f, "x86adc.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f000f, 0xffff801f, "x86adc.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0010, 0xffff801f, "x86sbc.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0011, 0xffff801f, "x86sbc.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0012, 0xffff801f, "x86sbc.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0013, 0xffff801f, "x86sbc.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0014, 0xffff801f, "x86sll.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0015, 0xffff801f, "x86sll.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0016, 0xffff801f, "x86sll.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0017, 0xffff801f, "x86sll.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0018, 0xffff801f, "x86srl.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f0019, 0xffff801f, "x86srl.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f001a, 0xffff801f, "x86srl.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f001b, 0xffff801f, "x86srl.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f001c, 0xffff801f, "x86sra.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f001d, 0xffff801f, "x86sra.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f001e, 0xffff801f, "x86sra.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f001f, 0xffff801f, "x86sra.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8000, 0xffff801f, "x86rotr.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8001, 0xffff801f, "x86rotr.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8002, 0xffff801f, "x86rotr.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8003, 0xffff801f, "x86rotr.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8004, 0xffff801f, "x86rotl.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8005, 0xffff801f, "x86rotl.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8006, 0xffff801f, "x86rotl.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8007, 0xffff801f, "x86rotl.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8008, 0xffff801f, "x86rcr.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8009, 0xffff801f, "x86rcr.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f800a, 0xffff801f, "x86rcr.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f800b, 0xffff801f, "x86rcr.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f800c, 0xffff801f, "x86rcl.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f800d, 0xffff801f, "x86rcl.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f800e, 0xffff801f, "x86rcl.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f800f, 0xffff801f, "x86rcl.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8010, 0xffff801f, "x86and.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8011, 0xffff801f, "x86and.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8012, 0xffff801f, "x86and.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8013, 0xffff801f, "x86and.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8014, 0xffff801f, "x86or.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8015, 0xffff801f, "x86or.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8016, 0xffff801f, "x86or.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8017, 0xffff801f, "x86or.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8018, 0xffff801f, "x86xor.b", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f8019, 0xffff801f, "x86xor.h", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f801a, 0xffff801f, "x86xor.w", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003f801b, 0xffff801f, "x86xor.d", "r5:5,r10:5", 0, 0, 0, 0},
+{0x003fc01c, 0xffffc01f, "armnot.w", "r5:5,u10:4", 0, 0, 0, 0},
+{0x003fc01d, 0xffffc01f, "armmov.w", "r5:5,u10:4", 0, 0, 0, 0},
+{0x003fc01e, 0xffffc01f, "armmov.d", "r5:5,u10:4", 0, 0, 0, 0},
+{0x003fc01f, 0xffffc01f, "armrrx.w", "r5:5,u10:4", 0, 0, 0, 0},
+{0x00408000, 0xffff8000, "slli.w", "r0:5,r5:5,u10:5", 0, 0, 0, 0},
+{0x00410000, 0xffff0000, "slli.d", "r0:5,r5:5,u10:6", 0, 0, 0, 0},
+{0x00448000, 0xffff8000, "srli.w", "r0:5,r5:5,u10:5", 0, 0, 0, 0},
+{0x00450000, 0xffff0000, "srli.d", "r0:5,r5:5,u10:6", 0, 0, 0, 0},
+{0x00488000, 0xffff8000, "srai.w", "r0:5,r5:5,u10:5", 0, 0, 0, 0},
+{0x00490000, 0xffff0000, "srai.d", "r0:5,r5:5,u10:6", 0, 0, 0, 0},
+{0x004c2000, 0xffffe000, "rotri.b", "r0:5,r5:5,u10:3", 0, 0, 0, 0},
+{0x004c4000, 0xffffc000, "rotri.h", "r0:5,r5:5,u10:4", 0, 0, 0, 0},
+{0x004c8000, 0xffff8000, "rotri.w", "r0:5,r5:5,u10:5", 0, 0, 0, 0},
+{0x004d0000, 0xffff0000, "rotri.d", "r0:5,r5:5,u10:6", 0, 0, 0, 0},
+{0x00502000, 0xffffe000, "rcri.b", "r0:5,r5:5,u10:3", 0, 0, 0, 0},
+{0x00504000, 0xffffc000, "rcri.h", "r0:5,r5:5,u10:4", 0, 0, 0, 0},
+{0x00508000, 0xffff8000, "rcri.w", "r0:5,r5:5,u10:5", 0, 0, 0, 0},
+{0x00510000, 0xffff0000, "rcri.d", "r0:5,r5:5,u10:6", 0, 0, 0, 0},
+{0x00542000, 0xffffe01f, "x86slli.b", "r5:5,u10:3", 0, 0, 0, 0},
+{0x00544001, 0xffffc01f, "x86slli.h", "r5:5,u10:4", 0, 0, 0, 0},
+{0x00548002, 0xffff801f, "x86slli.w", "r5:5,u10:5", 0, 0, 0, 0},
+{0x00550003, 0xffff001f, "x86slli.d", "r5:5,u10:6", 0, 0, 0, 0},
+{0x00542004, 0xffffe01f, "x86srli.b", "r5:5,u10:3", 0, 0, 0, 0},
+{0x00544005, 0xffffc01f, "x86srli.h", "r5:5,u10:4", 0, 0, 0, 0},
+{0x00548006, 0xffff801f, "x86srli.w", "r5:5,u10:5", 0, 0, 0, 0},
+{0x00550007, 0xffff001f, "x86srli.d", "r5:5,u10:6", 0, 0, 0, 0},
+{0x00542008, 0xffffe01f, "x86srai.b", "r5:5,u10:3", 0, 0, 0, 0},
+{0x00544009, 0xffffc01f, "x86srai.h", "r5:5,u10:4", 0, 0, 0, 0},
+{0x0054800a, 0xffff801f, "x86srai.w", "r5:5,u10:5", 0, 0, 0, 0},
+{0x0055000b, 0xffff001f, "x86srai.d", "r5:5,u10:6", 0, 0, 0, 0},
+{0x0054200c, 0xffffe01f, "x86rotri.b", "r5:5,u10:3", 0, 0, 0, 0},
+{0x0054400d, 0xffffc01f, "x86rotri.h", "r5:5,u10:4", 0, 0, 0, 0},
+{0x0054800e, 0xffff801f, "x86rotri.w", "r5:5,u10:5", 0, 0, 0, 0},
+{0x0055000f, 0xffff001f, "x86rotri.d", "r5:5,u10:6", 0, 0, 0, 0},
+{0x00542010, 0xffffe01f, "x86rcri.b", "r5:5,u10:3", 0, 0, 0, 0},
+{0x00544011, 0xffffc01f, "x86rcri.h", "r5:5,u10:4", 0, 0, 0, 0},
+{0x00548012, 0xffff801f, "x86rcri.w", "r5:5,u10:5", 0, 0, 0, 0},
+{0x00550013, 0xffff001f, "x86rcri.d", "r5:5,u10:6", 0, 0, 0, 0},
+{0x00542014, 0xffffe01f, "x86rotli.b", "r5:5,u10:3", 0, 0, 0, 0},
+{0x00544015, 0xffffc01f, "x86rotli.h", "r5:5,u10:4", 0, 0, 0, 0},
+{0x00548016, 0xffff801f, "x86rotli.w", "r5:5,u10:5", 0, 0, 0, 0},
+{0x00550017, 0xffff001f, "x86rotli.d", "r5:5,u10:6", 0, 0, 0, 0},
+{0x00542018, 0xffffe01f, "x86rcli.b", "r5:5,u10:3", 0, 0, 0, 0},
+{0x00544019, 0xffffc01f, "x86rcli.h", "r5:5,u10:4", 0, 0, 0, 0},
+{0x0054801a, 0xffff801f, "x86rcli.w", "r5:5,u10:5", 0, 0, 0, 0},
+{0x0055001b, 0xffff001f, "x86rcli.d", "r5:5,u10:6", 0, 0, 0, 0},
+{0x00580000, 0xfffc0000, "x86settag", "r0:5,u5:5,u10:8", 0, 0, 0, 0},
+{0x005c0000, 0xfffc03e0, "x86mfflag", "r0:5,u10:8", 0, 0, 0, 0},
+{0x005c0020, 0xfffc03e0, "x86mtflag", "r0:5,u10:8", 0, 0, 0, 0},
+{0x005c0040, 0xfffc03e0, "armmfflag", "r0:5,u10:8", 0, 0, 0, 0},
+{0x005c0060, 0xfffc03e0, "armmtflag", "r0:5,u10:8", 0, 0, 0, 0},
+{0x00600000, 0xffe08000, "bstrins.w", "r0:5,r5:5,u16:5,u10:5", 0, 0, 0, 0},
+{0x00608000, 0xffe08000, "bstrpick.w", "r0:5,r5:5,u16:5,u10:5", 0, 0, 0, 0},
+{0x00800000, 0xffc00000, "bstrins.d", "r0:5,r5:5,u16:6,u10:6", 0, 0, 0, 0},
+{0x00c00000, 0xffc00000, "bstrpick.d", "r0:5,r5:5,u16:6,u10:6", 0, 0, 0, 0},
+{0} /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_float_opcodes[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+{0x01000000, 0xffff8000, "fadd.h", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01008000, 0xffff8000, "fadd.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01010000, 0xffff8000, "fadd.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01020000, 0xffff8000, "fsub.h", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01028000, 0xffff8000, "fsub.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01030000, 0xffff8000, "fsub.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01040000, 0xffff8000, "fmul.h", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01048000, 0xffff8000, "fmul.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01050000, 0xffff8000, "fmul.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01060000, 0xffff8000, "fdiv.h", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01068000, 0xffff8000, "fdiv.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01070000, 0xffff8000, "fdiv.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01080000, 0xffff8000, "fmax.h", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01088000, 0xffff8000, "fmax.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01090000, 0xffff8000, "fmax.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x010a0000, 0xffff8000, "fmin.h", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x010a8000, 0xffff8000, "fmin.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x010b0000, 0xffff8000, "fmin.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x010c0000, 0xffff8000, "fmaxa.h", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x010c8000, 0xffff8000, "fmaxa.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x010d0000, 0xffff8000, "fmaxa.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x010e0000, 0xffff8000, "fmina.h", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x010e8000, 0xffff8000, "fmina.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x010f0000, 0xffff8000, "fmina.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01100000, 0xffff8000, "fscaleb.h", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01108000, 0xffff8000, "fscaleb.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01110000, 0xffff8000, "fscaleb.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01120000, 0xffff8000, "fcopysign.h", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01128000, 0xffff8000, "fcopysign.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01130000, 0xffff8000, "fcopysign.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01140000, 0xfffffc00, "fabs.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01140400, 0xfffffc00, "fabs.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01140800, 0xfffffc00, "fabs.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01141000, 0xfffffc00, "fneg.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01141400, 0xfffffc00, "fneg.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01141800, 0xfffffc00, "fneg.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01142000, 0xfffffc00, "flogb.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01142400, 0xfffffc00, "flogb.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01142800, 0xfffffc00, "flogb.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01143000, 0xfffffc00, "fclass.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01143400, 0xfffffc00, "fclass.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01143800, 0xfffffc00, "fclass.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01144000, 0xfffffc00, "fsqrt.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01144400, 0xfffffc00, "fsqrt.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01144800, 0xfffffc00, "fsqrt.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01145000, 0xfffffc00, "frecip.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01145400, 0xfffffc00, "frecip.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01145800, 0xfffffc00, "frecip.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01146000, 0xfffffc00, "frsqrt.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01146400, 0xfffffc00, "frsqrt.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01146800, 0xfffffc00, "frsqrt.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01147000, 0xfffffc00, "frecipe.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01147400, 0xfffffc00, "frecipe.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01147800, 0xfffffc00, "frecipe.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01148000, 0xfffffc00, "frsqrte.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01148400, 0xfffffc00, "frsqrte.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01148800, 0xfffffc00, "frsqrte.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01149000, 0xfffffc00, "fmov.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01149400, 0xfffffc00, "fmov.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01149800, 0xfffffc00, "fmov.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0114a000, 0xfffffc00, "movgr2fr.h", "f0:5,r5:5", 0, 0, 0, 0},
+{0x0114a400, 0xfffffc00, "movgr2fr.w", "f0:5,r5:5", 0, 0, 0, 0},
+{0x0114a800, 0xfffffc00, "movgr2fr.d", "f0:5,r5:5", 0, 0, 0, 0},
+{0x0114ac00, 0xfffffc00, "movgr2frh.w", "f0:5,r5:5", 0, 0, 0, 0},
+{0x0114b000, 0xfffffc00, "movfr2gr.h", "r0:5,f5:5", 0, 0, 0, 0},
+{0x0114b400, 0xfffffc00, "movfr2gr.s", "r0:5,f5:5", 0, 0, 0, 0},
+{0x0114b800, 0xfffffc00, "movfr2gr.d", "r0:5,f5:5", 0, 0, 0, 0},
+{0x0114bc00, 0xfffffc00, "movfrh2gr.s", "r0:5,f5:5", 0, 0, 0, 0},
+{0x0114c000, 0xfffffc00, "movgr2fcsr", "r0:5,r5:5", 0, 0, 0, 0},
+{0x0114c800, 0xfffffc00, "movfcsr2gr", "r0:5,r5:5", 0, 0, 0, 0},
+{0x0114d000, 0xfffffc18, "movfr2cf", "c0:3,f5:5", 0, 0, 0, 0},
+{0x0114d400, 0xffffff00, "movcf2fr", "f0:5,c5:3", 0, 0, 0, 0},
+{0x0114d800, 0xfffffc18, "movgr2cf", "c0:3,r5:5", 0, 0, 0, 0},
+{0x0114dc00, 0xffffff00, "movcf2gr", "r0:5,c5:3", 0, 0, 0, 0},
+{0x0114e000, 0xfffffc00, "fcvt.ld.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0114e400, 0xfffffc00, "fcvt.ud.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01150000, 0xffff8000, "fcvt.d.ld", "f0:5,f5:5,f10:5", 0, 0, 0, 0},
+{0x01180400, 0xfffffc00, "fcvtrm.h.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01180800, 0xfffffc00, "fcvtrm.h.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01180c00, 0xfffffc00, "fcvtrm.h.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01181000, 0xfffffc00, "fcvtrm.s.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01181800, 0xfffffc00, "fcvtrm.s.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01181c00, 0xfffffc00, "fcvtrm.s.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01182000, 0xfffffc00, "fcvtrm.d.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01182400, 0xfffffc00, "fcvtrm.d.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01182c00, 0xfffffc00, "fcvtrm.d.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01183000, 0xfffffc00, "fcvtrm.q.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01183400, 0xfffffc00, "fcvtrm.q.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01183800, 0xfffffc00, "fcvtrm.q.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01184400, 0xfffffc00, "fcvtrp.h.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01184800, 0xfffffc00, "fcvtrp.h.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01184c00, 0xfffffc00, "fcvtrp.h.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01185000, 0xfffffc00, "fcvtrp.s.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01185800, 0xfffffc00, "fcvtrp.s.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01185c00, 0xfffffc00, "fcvtrp.s.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01186000, 0xfffffc00, "fcvtrp.d.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01186400, 0xfffffc00, "fcvtrp.d.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01186c00, 0xfffffc00, "fcvtrp.d.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01187000, 0xfffffc00, "fcvtrp.q.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01187400, 0xfffffc00, "fcvtrp.q.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01187800, 0xfffffc00, "fcvtrp.q.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01188400, 0xfffffc00, "fcvtrz.h.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01188800, 0xfffffc00, "fcvtrz.h.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01188c00, 0xfffffc00, "fcvtrz.h.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01189000, 0xfffffc00, "fcvtrz.s.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01189800, 0xfffffc00, "fcvtrz.s.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01189c00, 0xfffffc00, "fcvtrz.s.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118a000, 0xfffffc00, "fcvtrz.d.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118a400, 0xfffffc00, "fcvtrz.d.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118ac00, 0xfffffc00, "fcvtrz.d.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118b000, 0xfffffc00, "fcvtrz.q.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118b400, 0xfffffc00, "fcvtrz.q.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118b800, 0xfffffc00, "fcvtrz.q.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118c400, 0xfffffc00, "fcvtrne.h.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118c800, 0xfffffc00, "fcvtrne.h.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118cc00, 0xfffffc00, "fcvtrne.h.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118d000, 0xfffffc00, "fcvtrne.s.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118d800, 0xfffffc00, "fcvtrne.s.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118dc00, 0xfffffc00, "fcvtrne.s.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118e000, 0xfffffc00, "fcvtrne.d.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118e400, 0xfffffc00, "fcvtrne.d.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118ec00, 0xfffffc00, "fcvtrne.d.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118f000, 0xfffffc00, "fcvtrne.q.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118f400, 0xfffffc00, "fcvtrne.q.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x0118f800, 0xfffffc00, "fcvtrne.q.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01190400, 0xfffffc00, "fcvt.h.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01190800, 0xfffffc00, "fcvt.h.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01190c00, 0xfffffc00, "fcvt.h.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01191000, 0xfffffc00, "fcvt.s.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01191800, 0xfffffc00, "fcvt.s.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01191c00, 0xfffffc00, "fcvt.s.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01192000, 0xfffffc00, "fcvt.d.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01192400, 0xfffffc00, "fcvt.d.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01192c00, 0xfffffc00, "fcvt.d.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01193000, 0xfffffc00, "fcvt.q.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01193400, 0xfffffc00, "fcvt.q.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x01193800, 0xfffffc00, "fcvt.q.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a0000, 0xfffffc00, "ftintrm.w.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a0400, 0xfffffc00, "ftintrm.w.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a0800, 0xfffffc00, "ftintrm.w.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a0c00, 0xfffffc00, "ftintrm.w.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a1000, 0xfffffc00, "ftintrm.wu.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a1400, 0xfffffc00, "ftintrm.wu.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a1800, 0xfffffc00, "ftintrm.wu.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a1c00, 0xfffffc00, "ftintrm.wu.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a2000, 0xfffffc00, "ftintrm.l.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a2400, 0xfffffc00, "ftintrm.l.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a2800, 0xfffffc00, "ftintrm.l.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a2c00, 0xfffffc00, "ftintrm.l.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a3000, 0xfffffc00, "ftintrm.lu.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a3400, 0xfffffc00, "ftintrm.lu.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a3800, 0xfffffc00, "ftintrm.lu.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a3c00, 0xfffffc00, "ftintrm.lu.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a4000, 0xfffffc00, "ftintrp.w.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a4400, 0xfffffc00, "ftintrp.w.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a4800, 0xfffffc00, "ftintrp.w.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a4c00, 0xfffffc00, "ftintrp.w.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a5000, 0xfffffc00, "ftintrp.wu.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a5400, 0xfffffc00, "ftintrp.wu.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a5800, 0xfffffc00, "ftintrp.wu.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a5c00, 0xfffffc00, "ftintrp.wu.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a6000, 0xfffffc00, "ftintrp.l.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a6400, 0xfffffc00, "ftintrp.l.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a6800, 0xfffffc00, "ftintrp.l.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a6c00, 0xfffffc00, "ftintrp.l.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a7000, 0xfffffc00, "ftintrp.lu.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a7400, 0xfffffc00, "ftintrp.lu.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a7800, 0xfffffc00, "ftintrp.lu.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a7c00, 0xfffffc00, "ftintrp.lu.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a8000, 0xfffffc00, "ftintrz.w.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a8400, 0xfffffc00, "ftintrz.w.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a8800, 0xfffffc00, "ftintrz.w.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a8c00, 0xfffffc00, "ftintrz.w.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a9000, 0xfffffc00, "ftintrz.wu.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a9400, 0xfffffc00, "ftintrz.wu.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a9800, 0xfffffc00, "ftintrz.wu.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011a9c00, 0xfffffc00, "ftintrz.wu.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011aa000, 0xfffffc00, "ftintrz.l.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011aa400, 0xfffffc00, "ftintrz.l.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011aa800, 0xfffffc00, "ftintrz.l.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011aac00, 0xfffffc00, "ftintrz.l.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ab000, 0xfffffc00, "ftintrz.lu.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ab400, 0xfffffc00, "ftintrz.lu.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ab800, 0xfffffc00, "ftintrz.lu.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011abc00, 0xfffffc00, "ftintrz.lu.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ac000, 0xfffffc00, "ftintrne.w.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ac400, 0xfffffc00, "ftintrne.w.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ac800, 0xfffffc00, "ftintrne.w.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011acc00, 0xfffffc00, "ftintrne.w.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ad000, 0xfffffc00, "ftintrne.wu.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ad400, 0xfffffc00, "ftintrne.wu.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ad800, 0xfffffc00, "ftintrne.wu.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011adc00, 0xfffffc00, "ftintrne.wu.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ae000, 0xfffffc00, "ftintrne.l.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ae400, 0xfffffc00, "ftintrne.l.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ae800, 0xfffffc00, "ftintrne.l.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011aec00, 0xfffffc00, "ftintrne.l.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011af000, 0xfffffc00, "ftintrne.lu.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011af400, 0xfffffc00, "ftintrne.lu.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011af800, 0xfffffc00, "ftintrne.lu.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011afc00, 0xfffffc00, "ftintrne.lu.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b0000, 0xfffffc00, "ftint.w.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b0400, 0xfffffc00, "ftint.w.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b0800, 0xfffffc00, "ftint.w.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b0c00, 0xfffffc00, "ftint.w.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b1000, 0xfffffc00, "ftint.wu.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b1400, 0xfffffc00, "ftint.wu.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b1800, 0xfffffc00, "ftint.wu.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b1c00, 0xfffffc00, "ftint.wu.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b2000, 0xfffffc00, "ftint.l.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b2400, 0xfffffc00, "ftint.l.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b2800, 0xfffffc00, "ftint.l.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b2c00, 0xfffffc00, "ftint.l.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b3000, 0xfffffc00, "ftint.lu.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b3400, 0xfffffc00, "ftint.lu.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b3800, 0xfffffc00, "ftint.lu.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011b3c00, 0xfffffc00, "ftint.lu.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c0000, 0xfffffc00, "ffintrm.h.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c0400, 0xfffffc00, "ffintrm.h.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c0800, 0xfffffc00, "ffintrm.h.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c0c00, 0xfffffc00, "ffintrm.h.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c1000, 0xfffffc00, "ffintrm.s.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c1400, 0xfffffc00, "ffintrm.s.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c1800, 0xfffffc00, "ffintrm.s.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c1c00, 0xfffffc00, "ffintrm.s.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c2000, 0xfffffc00, "ffintrm.d.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c2400, 0xfffffc00, "ffintrm.d.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c2800, 0xfffffc00, "ffintrm.d.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c2c00, 0xfffffc00, "ffintrm.d.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c3000, 0xfffffc00, "ffintrm.q.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c3400, 0xfffffc00, "ffintrm.q.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c3800, 0xfffffc00, "ffintrm.q.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c3c00, 0xfffffc00, "ffintrm.q.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c4000, 0xfffffc00, "ffintrp.h.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c4400, 0xfffffc00, "ffintrp.h.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c4800, 0xfffffc00, "ffintrp.h.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c4c00, 0xfffffc00, "ffintrp.h.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c5000, 0xfffffc00, "ffintrp.s.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c5400, 0xfffffc00, "ffintrp.s.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c5800, 0xfffffc00, "ffintrp.s.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c5c00, 0xfffffc00, "ffintrp.s.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c6000, 0xfffffc00, "ffintrp.d.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c6400, 0xfffffc00, "ffintrp.d.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c6800, 0xfffffc00, "ffintrp.d.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c6c00, 0xfffffc00, "ffintrp.d.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c7000, 0xfffffc00, "ffintrp.q.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c7400, 0xfffffc00, "ffintrp.q.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c7800, 0xfffffc00, "ffintrp.q.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c7c00, 0xfffffc00, "ffintrp.q.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c8000, 0xfffffc00, "ffintrz.h.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c8400, 0xfffffc00, "ffintrz.h.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c8800, 0xfffffc00, "ffintrz.h.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c8c00, 0xfffffc00, "ffintrz.h.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c9000, 0xfffffc00, "ffintrz.s.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c9400, 0xfffffc00, "ffintrz.s.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c9800, 0xfffffc00, "ffintrz.s.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011c9c00, 0xfffffc00, "ffintrz.s.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ca000, 0xfffffc00, "ffintrz.d.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ca400, 0xfffffc00, "ffintrz.d.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ca800, 0xfffffc00, "ffintrz.d.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cac00, 0xfffffc00, "ffintrz.d.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cb000, 0xfffffc00, "ffintrz.q.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cb400, 0xfffffc00, "ffintrz.q.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cb800, 0xfffffc00, "ffintrz.q.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cbc00, 0xfffffc00, "ffintrz.q.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cc000, 0xfffffc00, "ffintrne.h.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cc400, 0xfffffc00, "ffintrne.h.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cc800, 0xfffffc00, "ffintrne.h.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ccc00, 0xfffffc00, "ffintrne.h.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cd000, 0xfffffc00, "ffintrne.s.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cd400, 0xfffffc00, "ffintrne.s.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cd800, 0xfffffc00, "ffintrne.s.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cdc00, 0xfffffc00, "ffintrne.s.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ce000, 0xfffffc00, "ffintrne.d.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ce400, 0xfffffc00, "ffintrne.d.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011ce800, 0xfffffc00, "ffintrne.d.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cec00, 0xfffffc00, "ffintrne.d.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cf000, 0xfffffc00, "ffintrne.q.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cf400, 0xfffffc00, "ffintrne.q.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cf800, 0xfffffc00, "ffintrne.q.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011cfc00, 0xfffffc00, "ffintrne.q.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d0000, 0xfffffc00, "ffint.h.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d0400, 0xfffffc00, "ffint.h.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d0800, 0xfffffc00, "ffint.h.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d0c00, 0xfffffc00, "ffint.h.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d1000, 0xfffffc00, "ffint.s.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d1400, 0xfffffc00, "ffint.s.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d1800, 0xfffffc00, "ffint.s.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d1c00, 0xfffffc00, "ffint.s.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d2000, 0xfffffc00, "ffint.d.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d2400, 0xfffffc00, "ffint.d.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d2800, 0xfffffc00, "ffint.d.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d2c00, 0xfffffc00, "ffint.d.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d3000, 0xfffffc00, "ffint.q.w", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d3400, 0xfffffc00, "ffint.q.wu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d3800, 0xfffffc00, "ffint.q.l", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011d3c00, 0xfffffc00, "ffint.q.lu", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e0000, 0xfffffc00, "frintrm.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e0400, 0xfffffc00, "frintrm.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e0800, 0xfffffc00, "frintrm.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e0c00, 0xfffffc00, "frintrm.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e1000, 0xfffffc00, "frintrp.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e1400, 0xfffffc00, "frintrp.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e1800, 0xfffffc00, "frintrp.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e1c00, 0xfffffc00, "frintrp.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e2000, 0xfffffc00, "frintrz.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e2400, 0xfffffc00, "frintrz.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e2800, 0xfffffc00, "frintrz.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e2c00, 0xfffffc00, "frintrz.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e3000, 0xfffffc00, "frintrne.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e3400, 0xfffffc00, "frintrne.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e3800, 0xfffffc00, "frintrne.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e3c00, 0xfffffc00, "frintrne.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e4000, 0xfffffc00, "frint.h", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e4400, 0xfffffc00, "frint.s", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e4800, 0xfffffc00, "frint.d", "f0:5,f5:5", 0, 0, 0, 0},
+{0x011e4c00, 0xfffffc00, "frint.q", "f0:5,f5:5", 0, 0, 0, 0},
+{0} /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_lmm_opcodes[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+{0x02000000, 0xffc00000, "slti", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x02400000, 0xffc00000, "sltui", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x02800000, 0xffc00000, "addi.w", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x02c00000, 0xffc00000, "addi.d", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x03000000, 0xffc00000, "lu52i.d", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0, 0, "nop", "", "andi $r0,$r0,0", 0, 0, 0},
+{0x03400000, 0xffc00000, "andi", "r0:5,r5:5,u10:12", 0, 0, 0, 0},
+{0x03800000, 0xffc00000, "ori", "r0:5,r5:5,u10:12", 0, 0, 0, 0},
+{0x03c00000, 0xffc00000, "xori", "r0:5,r5:5,u10:12", 0, 0, 0, 0},
+{0x10000000, 0xfc000000, "addu16i.d", "r0:5,r5:5,s10:16", 0, 0, 0, 0},
+{0x14000000, 0xfe000000, "lu12i.w", "r0:5,s5:20", 0, 0, 0, 0},
+{0x16000000, 0xfe000000, "lu32i.d", "r0:5,s5:20", 0, 0, 0, 0},
+{0x18000000, 0xfe000000, "pcaddi", "r0:5,s5:20", 0, 0, 0, 0},
+{0x1a000000, 0xfe000000, "pcalau12i", "r0:5,s5:20", 0, 0, 0, 0},
+{0x1c000000, 0xfe000000, "pcaddu12i", "r0:5,s5:20", 0, 0, 0, 0},
+{0x1e000000, 0xfe000000, "pcaddu18i", "r0:5,s5:20", 0, 0, 0, 0},
+{0} /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_privilege_opcodes[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+{0x04000000, 0xff0003e0, "csrrd", "r0:5,u10:14", 0, 0, 0, 0},
+{0x04000020, 0xff0003e0, "csrwr", "r0:5,u10:14", 0, 0, 0, 0},
+{0x04000000, 0xff000000, "csrxchg", "r0:5,r5:5,u10:14", 0, 0, 0, 0},
+{0x05000000, 0xff0003e0, "gcsrrd", "r0:5,u10:14", 0, 0, 0, 0},
+{0x05000020, 0xff0003e0, "gcsrwr", "r0:5,u10:14", 0, 0, 0, 0},
+{0x05000000, 0xff000000, "gcsrxchg", "r0:5,r5:5,u10:14", 0, 0, 0, 0},
+{0x06000000, 0xffc00000, "cache", "u0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x06400000, 0xfffc0000, "lddir", "r0:5,r5:5,u10:8", 0, 0, 0, 0},
+{0x06440000, 0xfffc001f, "ldpte", "r5:5,u10:8", 0, 0, 0, 0},
+{0x06480000, 0xfffffc00, "iocsrrd.b", "r0:5,r5:5", 0, 0, 0, 0},
+{0x06480400, 0xfffffc00, "iocsrrd.h", "r0:5,r5:5", 0, 0, 0, 0},
+{0x06480800, 0xfffffc00, "iocsrrd.w", "r0:5,r5:5", 0, 0, 0, 0},
+{0x06480c00, 0xfffffc00, "iocsrrd.d", "r0:5,r5:5", 0, 0, 0, 0},
+{0x06481000, 0xfffffc00, "iocsrwr.b", "r0:5,r5:5", 0, 0, 0, 0},
+{0x06481400, 0xfffffc00, "iocsrwr.h", "r0:5,r5:5", 0, 0, 0, 0},
+{0x06481800, 0xfffffc00, "iocsrwr.w", "r0:5,r5:5", 0, 0, 0, 0},
+{0x06481c00, 0xfffffc00, "iocsrwr.d", "r0:5,r5:5", 0, 0, 0, 0},
+{0x06482000, 0xffffffff, "tlbinv", "", 0, 0, 0, 0},
+{0x06482001, 0xffffffff, "gtlbinv", "", 0, 0, 0, 0},
+{0x06482400, 0xffffffff, "tlbflush", "", 0, 0, 0, 0},
+{0x06482401, 0xffffffff, "gtlbflush", "", 0, 0, 0, 0},
+{0x06482800, 0xffffffff, "tlbp", "", 0, 0, 0, 0},
+{0x06482801, 0xffffffff, "gtlbp", "", 0, 0, 0, 0},
+{0x06482c00, 0xffffffff, "tlbr", "", 0, 0, 0, 0},
+{0x06482c01, 0xffffffff, "gtlbr", "", 0, 0, 0, 0},
+{0x06483000, 0xffffffff, "tlbwi", "", 0, 0, 0, 0},
+{0x06483001, 0xffffffff, "gtlbwi", "", 0, 0, 0, 0},
+{0x06483400, 0xffffffff, "tlbwr", "", 0, 0, 0, 0},
+{0x06483401, 0xffffffff, "gtlbwr", "", 0, 0, 0, 0},
+{0x06483800, 0xffffffff, "eret", "", 0, 0, 0, 0},
+{0x06483c00, 0xffffffff, "deret", "", 0, 0, 0, 0},
+{0x06488000, 0xffff8000, "wait", "u0:15", 0, 0, 0, 0},
+{0x06498000, 0xffff8000, "invtlb", "u0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0} /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_4opt_opcodes[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+{0x08000000, 0xfff00000, "fmadd.h", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0},
+{0x08100000, 0xfff00000, "fmadd.s", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0},
+{0x08200000, 0xfff00000, "fmadd.d", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0},
+{0x08400000, 0xfff00000, "fmsub.h", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0},
+{0x08500000, 0xfff00000, "fmsub.s", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0},
+{0x08600000, 0xfff00000, "fmsub.d", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0},
+{0x08800000, 0xfff00000, "fnmadd.h", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0},
+{0x08900000, 0xfff00000, "fnmadd.s", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0},
+{0x08a00000, 0xfff00000, "fnmadd.d", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0},
+{0x08c00000, 0xfff00000, "fnmsub.h", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0},
+{0x08d00000, 0xfff00000, "fnmsub.s", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0},
+{0x08e00000, 0xfff00000, "fnmsub.d", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0},
+{0x0c000000, 0xffff8018, "fcmp.caf.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c008000, 0xffff8018, "fcmp.saf.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c010000, 0xffff8018, "fcmp.clt.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c018000, 0xffff8018, "fcmp.slt.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c020000, 0xffff8018, "fcmp.ceq.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c028000, 0xffff8018, "fcmp.seq.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c030000, 0xffff8018, "fcmp.cle.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c038000, 0xffff8018, "fcmp.sle.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c040000, 0xffff8018, "fcmp.cun.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c048000, 0xffff8018, "fcmp.sun.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c050000, 0xffff8018, "fcmp.cult.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c058000, 0xffff8018, "fcmp.sult.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c060000, 0xffff8018, "fcmp.cueq.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c068000, 0xffff8018, "fcmp.sueq.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c070000, 0xffff8018, "fcmp.cule.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c078000, 0xffff8018, "fcmp.sule.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c080000, 0xffff8018, "fcmp.cne.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c088000, 0xffff8018, "fcmp.sne.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c0a0000, 0xffff8018, "fcmp.cor.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c0a8000, 0xffff8018, "fcmp.sor.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c0c0000, 0xffff8018, "fcmp.cune.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c0c8000, 0xffff8018, "fcmp.sune.h", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c100000, 0xffff8018, "fcmp.caf.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c108000, 0xffff8018, "fcmp.saf.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c110000, 0xffff8018, "fcmp.clt.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c118000, 0xffff8018, "fcmp.slt.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c120000, 0xffff8018, "fcmp.ceq.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c128000, 0xffff8018, "fcmp.seq.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c130000, 0xffff8018, "fcmp.cle.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c138000, 0xffff8018, "fcmp.sle.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c140000, 0xffff8018, "fcmp.cun.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c148000, 0xffff8018, "fcmp.sun.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c150000, 0xffff8018, "fcmp.cult.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c158000, 0xffff8018, "fcmp.sult.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c160000, 0xffff8018, "fcmp.cueq.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c168000, 0xffff8018, "fcmp.sueq.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c170000, 0xffff8018, "fcmp.cule.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c178000, 0xffff8018, "fcmp.sule.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c180000, 0xffff8018, "fcmp.cne.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c188000, 0xffff8018, "fcmp.sne.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c1a0000, 0xffff8018, "fcmp.cor.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c1a8000, 0xffff8018, "fcmp.sor.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c1c0000, 0xffff8018, "fcmp.cune.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c1c8000, 0xffff8018, "fcmp.sune.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c200000, 0xffff8018, "fcmp.caf.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c208000, 0xffff8018, "fcmp.saf.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c210000, 0xffff8018, "fcmp.clt.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c218000, 0xffff8018, "fcmp.slt.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c220000, 0xffff8018, "fcmp.ceq.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c228000, 0xffff8018, "fcmp.seq.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c230000, 0xffff8018, "fcmp.cle.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c238000, 0xffff8018, "fcmp.sle.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c240000, 0xffff8018, "fcmp.cun.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c248000, 0xffff8018, "fcmp.sun.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c250000, 0xffff8018, "fcmp.cult.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c258000, 0xffff8018, "fcmp.sult.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c260000, 0xffff8018, "fcmp.cueq.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c268000, 0xffff8018, "fcmp.sueq.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c270000, 0xffff8018, "fcmp.cule.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c278000, 0xffff8018, "fcmp.sule.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c280000, 0xffff8018, "fcmp.cne.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c288000, 0xffff8018, "fcmp.sne.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c2a0000, 0xffff8018, "fcmp.cor.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c2a8000, 0xffff8018, "fcmp.sor.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c2c0000, 0xffff8018, "fcmp.cune.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0c2c8000, 0xffff8018, "fcmp.sune.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0},
+{0x0d000000, 0xfffc0000, "fsel", "f0:5,f5:5,f10:5,c15:3", 0, 0, 0, 0},
+{0} /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_load_store_opcodes[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+{0x20000000, 0xff000000, "ll.w", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0},
+{0x21000000, 0xff000000, "sc.w", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0},
+{0x22000000, 0xff000000, "ll.d", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0},
+{0x23000000, 0xff000000, "sc.d", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0},
+{0x24000000, 0xff000000, "ldptr.w", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0},
+{0x25000000, 0xff000000, "stptr.w", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0},
+{0x26000000, 0xff000000, "ldptr.d", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0},
+{0x27000000, 0xff000000, "stptr.d", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0},
+{0x28000000, 0xffc00000, "ld.b", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x28400000, 0xffc00000, "ld.h", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x28800000, 0xffc00000, "ld.w", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x28c00000, 0xffc00000, "ld.d", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x29000000, 0xffc00000, "st.b", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x29400000, 0xffc00000, "st.h", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x29800000, 0xffc00000, "st.w", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x29c00000, 0xffc00000, "st.d", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2a000000, 0xffc00000, "ld.bu", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2a400000, 0xffc00000, "ld.hu", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2a800000, 0xffc00000, "ld.wu", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2ac00000, 0xffc00000, "preld", "u0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2b000000, 0xffc00000, "fld.s", "f0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2b400000, 0xffc00000, "fst.s", "f0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2b800000, 0xffc00000, "fld.d", "f0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2bc00000, 0xffc00000, "fst.d", "f0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2e000000, 0xffc00000, "ldl.w", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2e400000, 0xffc00000, "ldr.w", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2e800000, 0xffc00000, "ldl.d", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2ec00000, 0xffc00000, "ldr.d", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2f000000, 0xffc00000, "stl.w", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2f400000, 0xffc00000, "str.w", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2f800000, 0xffc00000, "stl.d", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x2fc00000, 0xffc00000, "str.d", "r0:5,r5:5,s10:12", 0, 0, 0, 0},
+{0x38000000, 0xffff8000, "ldx.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38040000, 0xffff8000, "ldx.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38080000, 0xffff8000, "ldx.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x380c0000, 0xffff8000, "ldx.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38100000, 0xffff8000, "stx.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38140000, 0xffff8000, "stx.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38180000, 0xffff8000, "stx.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x381c0000, 0xffff8000, "stx.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38200000, 0xffff8000, "ldx.bu", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38240000, 0xffff8000, "ldx.hu", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38280000, 0xffff8000, "ldx.wu", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x382c0000, 0xffff8000, "preldx", "u0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38300000, 0xffff8000, "fldx.s", "f0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38340000, 0xffff8000, "fldx.d", "f0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38380000, 0xffff8000, "fstx.s", "f0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x383c0000, 0xffff8000, "fstx.d", "f0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0, 0, "amswap.w", "r,r,r,u0:0", "amswap.w %1,%2,%3", 0, 0, 0},
+{0x38600000, 0xffff8000, "amswap.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amswap.d", "r,r,r,u0:0", "amswap.d %1,%2,%3", 0, 0, 0},
+{0x38608000, 0xffff8000, "amswap.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amadd.w", "r,r,r,u0:0", "amadd.w %1,%2,%3", 0, 0, 0},
+{0x38610000, 0xffff8000, "amadd.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amadd.d", "r,r,r,u0:0", "amadd.d %1,%2,%3", 0, 0, 0},
+{0x38618000, 0xffff8000, "amadd.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amand.w", "r,r,r,u0:0", "amand.w %1,%2,%3", 0, 0, 0},
+{0x38620000, 0xffff8000, "amand.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amand.d", "r,r,r,u0:0", "amand.d %1,%2,%3", 0, 0, 0},
+{0x38628000, 0xffff8000, "amand.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amor.w", "r,r,r,u0:0", "amor.w %1,%2,%3", 0, 0, 0},
+{0x38630000, 0xffff8000, "amor.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amor.d", "r,r,r,u0:0", "amor.d %1,%2,%3", 0, 0, 0},
+{0x38638000, 0xffff8000, "amor.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amxor.w", "r,r,r,u0:0", "amxor.w %1,%2,%3", 0, 0, 0},
+{0x38640000, 0xffff8000, "amxor.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amxor.d", "r,r,r,u0:0", "amxor.d %1,%2,%3", 0, 0, 0},
+{0x38648000, 0xffff8000, "amxor.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammax.w", "r,r,r,u0:0", "ammax.w %1,%2,%3", 0, 0, 0},
+{0x38650000, 0xffff8000, "ammax.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammax.d", "r,r,r,u0:0", "ammax.d %1,%2,%3", 0, 0, 0},
+{0x38658000, 0xffff8000, "ammax.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammin.w", "r,r,r,u0:0", "ammin.w %1,%2,%3", 0, 0, 0},
+{0x38660000, 0xffff8000, "ammin.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammin.d", "r,r,r,u0:0", "ammin.d %1,%2,%3", 0, 0, 0},
+{0x38668000, 0xffff8000, "ammin.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammax.wu", "r,r,r,u0:0", "ammax.wu %1,%2,%3", 0, 0, 0},
+{0x38670000, 0xffff8000, "ammax.wu", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammax.du", "r,r,r,u0:0", "ammax.du %1,%2,%3", 0, 0, 0},
+{0x38678000, 0xffff8000, "ammax.du", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammin.wu", "r,r,r,u0:0", "ammin.wu %1,%2,%3", 0, 0, 0},
+{0x38680000, 0xffff8000, "ammin.wu", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammin.du", "r,r,r,u0:0", "ammin.du %1,%2,%3", 0, 0, 0},
+{0x38688000, 0xffff8000, "ammin.du", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amswap_db.w", "r,r,r,u0:0", "amswap_db.w %1,%2,%3", 0, 0, 0},
+{0x38690000, 0xffff8000, "amswap_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amswap_db.d", "r,r,r,u0:0", "amswap_db.d %1,%2,%3", 0, 0, 0},
+{0x38698000, 0xffff8000, "amswap_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amadd_db.w", "r,r,r,u0:0", "amadd_db.w %1,%2,%3", 0, 0, 0},
+{0x386a0000, 0xffff8000, "amadd_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amadd_db.d", "r,r,r,u0:0", "amadd_db.d %1,%2,%3", 0, 0, 0},
+{0x386a8000, 0xffff8000, "amadd_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amand_db.w", "r,r,r,u0:0", "amand_db.w %1,%2,%3", 0, 0, 0},
+{0x386b0000, 0xffff8000, "amand_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amand_db.d", "r,r,r,u0:0", "amand_db.d %1,%2,%3", 0, 0, 0},
+{0x386b8000, 0xffff8000, "amand_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amor_db.w", "r,r,r,u0:0", "amor_db.w %1,%2,%3", 0, 0, 0},
+{0x386c0000, 0xffff8000, "amor_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amor_db.d", "r,r,r,u0:0", "amor_db.d %1,%2,%3", 0, 0, 0},
+{0x386c8000, 0xffff8000, "amor_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amxor_db.w", "r,r,r,u0:0", "amxor_db.w %1,%2,%3", 0, 0, 0},
+{0x386d0000, 0xffff8000, "amxor_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "amxor_db.d", "r,r,r,u0:0", "amxor_db.d %1,%2,%3", 0, 0, 0},
+{0x386d8000, 0xffff8000, "amxor_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammax_db.w", "r,r,r,u0:0", "ammax_db.w %1,%2,%3", 0, 0, 0},
+{0x386e0000, 0xffff8000, "ammax_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammax_db.d", "r,r,r,u0:0", "ammax_db.d %1,%2,%3", 0, 0, 0},
+{0x386e8000, 0xffff8000, "ammax_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammin_db.w", "r,r,r,u0:0", "ammin_db.w %1,%2,%3", 0, 0, 0},
+{0x386f0000, 0xffff8000, "ammin_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammin_db.d", "r,r,r,u0:0", "ammin_db.d %1,%2,%3", 0, 0, 0},
+{0x386f8000, 0xffff8000, "ammin_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammax_db.wu", "r,r,r,u0:0", "ammax_db.wu %1,%2,%3", 0, 0, 0},
+{0x38700000, 0xffff8000, "ammax_db.wu", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammax_db.du", "r,r,r,u0:0", "ammax_db.du %1,%2,%3", 0, 0, 0},
+{0x38708000, 0xffff8000, "ammax_db.du", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammin_db.wu", "r,r,r,u0:0", "ammin_db.wu %1,%2,%3", 0, 0, 0},
+{0x38710000, 0xffff8000, "ammin_db.wu", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0, 0, "ammin_db.du", "r,r,r,u0:0", "ammin_db.du %1,%2,%3", 0, 0, 0},
+{0x38718000, 0xffff8000, "ammin_db.du", "r0:5,r10:5,r5:5", 0, 0, 0, 0},
+{0x38720000, 0xffff8000, "dbar", "u0:15", 0, 0, 0, 0},
+{0x38728000, 0xffff8000, "ibar", "u0:15", 0, 0, 0, 0},
+{0x38740000, 0xffff8000, "fldgt.s", "f0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38748000, 0xffff8000, "fldgt.d", "f0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38750000, 0xffff8000, "fldle.s", "f0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38758000, 0xffff8000, "fldle.d", "f0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38760000, 0xffff8000, "fstgt.s", "f0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38768000, 0xffff8000, "fstgt.d", "f0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38770000, 0xffff8000, "fstle.s", "f0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38778000, 0xffff8000, "fstle.d", "f0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38780000, 0xffff8000, "ldgt.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38788000, 0xffff8000, "ldgt.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38790000, 0xffff8000, "ldgt.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x38798000, 0xffff8000, "ldgt.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x387a0000, 0xffff8000, "ldle.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x387a8000, 0xffff8000, "ldle.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x387b0000, 0xffff8000, "ldle.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x387b8000, 0xffff8000, "ldle.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x387c0000, 0xffff8000, "stgt.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x387c8000, 0xffff8000, "stgt.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x387d0000, 0xffff8000, "stgt.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x387d8000, 0xffff8000, "stgt.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x387e0000, 0xffff8000, "stle.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x387e8000, 0xffff8000, "stle.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x387f0000, 0xffff8000, "stle.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0x387f8000, 0xffff8000, "stle.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0},
+{0} /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_jmp_opcodes[] = {
+/* match,    mask,       name, format, macro, include, exclude, pinfo */
+{0, 0, "beqz", "r,la", "beqz %1,%%pcrel(%2)", 0, 0, 0},
+{0x40000000, 0xfc000000, "beqz", "r5:5,sb0:5|10:16<<2", 0, 0, 0, 0},
+{0, 0, "bnez", "r,la", "bnez %1,%%pcrel(%2)", 0, 0, 0},
+{0x44000000, 0xfc000000, "bnez", "r5:5,sb0:5|10:16<<2", 0, 0, 0, 0},
+{0, 0, "bceqz", "c,la", "bceqz %1,%%pcrel(%2)", 0, 0, 0},
+{0x48000000, 0xfc000300, "bceqz", "c5:3,sb0:5|10:16<<2", 0, 0, 0, 0},
+{0, 0, "bcnez", "c,la", "bcnez %1,%%pcrel(%2)", 0, 0, 0},
+{0x48000100, 0xfc000300, "bcnez", "c5:3,sb0:5|10:16<<2", 0, 0, 0, 0},
+{0x48000200, 0xfc0003e0, "jiscr0", "s0:5|10:16<<2", 0, 0, 0, 0},
+{0x48000300, 0xfc0003e0, "jiscr1", "s0:5|10:16<<2", 0, 0, 0, 0},
+{0, 0, "jr", "r", "jirl $r0,%1,0", 0, 0, 0},
+{0x4c000000, 0xfc000000, "jirl", "r0:5,r5:5,s10:16<<2", 0, 0, 0, 0},
+{0, 0, "b", "la", "b %%pcrel(%1)", 0, 0, 0},
+{0x50000000, 0xfc000000, "b", "sb0:10|10:16<<2", 0, 0, 0, 0},
+{0, 0, "bl", "la", "bl %%pcrel(%1)", 0, 0, 0},
+{0x54000000, 0xfc000000, "bl", "sb0:10|10:16<<2", 0, 0, 0, 0},
+{0, 0, "beq", "r,r,la", "beq %1,%2,%%pcrel(%3)", 0, 0, 0},
+{0x58000000, 0xfc000000, "beq", "r5:5,r0:5,sb10:16<<2", 0, 0, 0, 0},
+{0, 0, "bne", "r,r,la", "bne %1,%2,%%pcrel(%3)", 0, 0, 0},
+{0x5c000000, 0xfc000000, "bne", "r5:5,r0:5,sb10:16<<2", 0, 0, 0, 0},
+{0, 0, "blt", "r,r,la", "blt %1,%2,%%pcrel(%3)", 0, 0, 0},
+{0x60000000, 0xfc000000, "blt", "r5:5,r0:5,sb10:16<<2", 0, 0, 0, 0},
+{0, 0, "bge", "r,r,la", "bge %1,%2,%%pcrel(%3)", 0, 0, 0},
+{0x64000000, 0xfc000000, "bge", "r5:5,r0:5,sb10:16<<2", 0, 0, 0, 0},
+{0, 0, "bltu", "r,r,la", "bltu %1,%2,%%pcrel(%3)", 0, 0, 0},
+{0x68000000, 0xfc000000, "bltu", "r5:5,r0:5,sb10:16<<2", 0, 0, 0, 0},
+{0, 0, "bgeu", "r,r,la", "bgeu %1,%2,%%pcrel(%3)", 0, 0, 0},
+{0x6c000000, 0xfc000000, "bgeu", "r5:5,r0:5,sb10:16<<2", 0, 0, 0, 0},
+{0, 0, "fbceqz", "c,s", "bceqz %1,%2", 0, 0, 0},
+{0, 0, "fbceqz", "c,l", "bceqz %1,%2", 0, 0, 0},
+{0, 0, "vbceqz", "c,s", "bceqz %1,%2", 0, 0, 0},
+{0, 0, "vbceqz", "c,l", "bceqz %1,%2", 0, 0, 0},
+{0, 0, "xvbceqz", "c,s", "bceqz %1,%2", 0, 0, 0},
+{0, 0, "xvbceqz", "c,l", "bceqz %1,%2", 0, 0, 0},
+{0, 0, "fbcnez", "c,s", "bcnez %1,%2", 0, 0, 0},
+{0, 0, "fbcnez", "c,l", "bcnez %1,%2", 0, 0, 0},
+{0, 0, "vbcnez", "c,s", "bcnez %1,%2", 0, 0, 0},
+{0, 0, "vbcnez", "c,l", "bcnez %1,%2", 0, 0, 0},
+{0, 0, "xvbcnez", "c,s", "bcnez %1,%2", 0, 0, 0},
+{0, 0, "xvbcnez", "c,l", "bcnez %1,%2", 0, 0, 0},
+{0} /* Terminate the list.  */
+};
+
+struct loongarch_ase loongarch_ASEs[] = {
+{&LARCH_opts.ase_test, loongarch_test_opcodes, 0, 0, {0}, 0, 0},
+{&LARCH_opts.ase_fix, loongarch_macro_opcodes, 0, 0, {0}, 0, 0},
+{&LARCH_opts.ase_fix, loongarch_lmm_opcodes, 0, 0, {0}, 0, 0},
+{&LARCH_opts.ase_fix, loongarch_privilege_opcodes, 0, 0, {0}, 0, 0},
+{&LARCH_opts.ase_fix, loongarch_jmp_opcodes, 0, 0, {0}, 0, 0},
+{&LARCH_opts.ase_fix, loongarch_load_store_opcodes, 0, 0, {0}, 0, 0},
+{&LARCH_opts.ase_fix, loongarch_fix_opcodes, 0, 0, {0}, 0, 0},
+{&LARCH_opts.ase_float, loongarch_4opt_opcodes, 0, 0, {0}, 0, 0},
+{&LARCH_opts.ase_float, loongarch_float_opcodes, 0, 0, {0}, 0, 0},
+
+{0},
+};
+
-- 
2.30.1

