From 49e2d61855ad290558e3509a349f6afe89ecdf98 Mon Sep 17 00:00:00 2001
From: liuzhensong <liuzhensong@loongson.cn>
Date: Fri, 30 Jul 2021 10:02:48 +0800
Subject: [PATCH 01/30] Add support for loongarch architecture.

  bfd/Makefile.am
  bfd/Makefile.in
  bfd/archures.c
  bfd/bfd-in2.h
  bfd/config.bfd
  bfd/configure
  bfd/configure.ac
  bfd/cpu-loongarch.c
  bfd/elf-bfd.h
  bfd/elfnn-loongarch.c
  bfd/elfxx-loongarch.c
  bfd/elfxx-loongarch.h
  bfd/libbfd.h
  bfd/reloc.c
  bfd/targets.c
  binutils/readelf.c
  binutils/testsuite/binutils-all/objdump.exp
  gas/Makefile.am
  gas/Makefile.in
  gas/config/loongarch-lex-wrapper.c
  gas/config/loongarch-lex.l
  gas/config/loongarch-parse.y
  gas/config/tc-loongarch.c
  gas/config/tc-loongarch.h
  gas/configure
  gas/configure.ac
  gas/configure.tgt
  gas/testsuite/lib/gas-defs.exp
  include/dis-asm.h
  include/elf/loongarch.h
  include/opcode/loongarch.h
  ld/Makefile.am
  ld/Makefile.in
  ld/configure.tgt
  ld/emulparams/elf64loongarch-defs.sh
  ld/emulparams/elf64loongarch.sh
  ld/emultempl/loongarchelf.em
  opcodes/Makefile.am
  opcodes/Makefile.in
  opcodes/configure
  opcodes/configure.ac
  opcodes/disassemble.c
  opcodes/disassemble.h
  opcodes/loongarch-coder.c
  opcodes/loongarch-dis.c
  opcodes/loongarch-opc.c
---
 bfd/Makefile.am                             |   17 +-
 bfd/Makefile.in                             |   21 +-
 bfd/archures.c                              |    5 +
 bfd/bfd-in2.h                               |   48 +
 bfd/config.bfd                              |   15 +
 bfd/configure                               |    2 +
 bfd/configure.ac                            |    2 +
 bfd/cpu-loongarch.c                         |   59 +
 bfd/elf-bfd.h                               |    9 +
 bfd/elfnn-loongarch.c                       | 3125 +++++++++++++++++++
 bfd/elfxx-loongarch.c                       |  195 ++
 bfd/elfxx-loongarch.h                       |   30 +
 bfd/libbfd.h                                |   43 +
 bfd/reloc.c                                 |   89 +
 bfd/targets.c                               |    8 +
 binutils/readelf.c                          |    8 +
 binutils/testsuite/binutils-all/objdump.exp |    2 +-
 gas/Makefile.am                             |   26 +-
 gas/Makefile.in                             |   29 +-
 gas/config/loongarch-lex-wrapper.c          |   20 +
 gas/config/loongarch-lex.l                  |   55 +
 gas/config/loongarch-parse.y                |  448 +++
 gas/config/tc-loongarch.c                   | 1232 ++++++++
 gas/config/tc-loongarch.h                   |   91 +
 gas/configure                               |    9 +
 gas/configure.ac                            |    9 +
 gas/configure.tgt                           |    5 +-
 gas/testsuite/lib/gas-defs.exp              |    4 +
 include/dis-asm.h                           |    1 +
 include/elf/loongarch.h                     |  101 +
 include/opcode/loongarch.h                  |  217 ++
 ld/Makefile.am                              |    2 +
 ld/Makefile.in                              |    3 +
 ld/configure.tgt                            |    4 +
 ld/emulparams/elf64loongarch-defs.sh        |   38 +
 ld/emulparams/elf64loongarch.sh             |   11 +
 ld/emultempl/loongarchelf.em                |   91 +
 opcodes/Makefile.am                         |    3 +
 opcodes/Makefile.in                         |    6 +
 opcodes/configure                           |    1 +
 opcodes/configure.ac                        |    1 +
 opcodes/disassemble.c                       |    9 +
 opcodes/disassemble.h                       |    1 +
 opcodes/loongarch-coder.c                   |  548 ++++
 opcodes/loongarch-dis.c                     |  332 ++
 opcodes/loongarch-opc.c                     |  781 +++++
 46 files changed, 7749 insertions(+), 7 deletions(-)
 create mode 100644 bfd/cpu-loongarch.c
 create mode 100644 bfd/elfnn-loongarch.c
 create mode 100644 bfd/elfxx-loongarch.c
 create mode 100644 bfd/elfxx-loongarch.h
 create mode 100644 gas/config/loongarch-lex-wrapper.c
 create mode 100644 gas/config/loongarch-lex.l
 create mode 100644 gas/config/loongarch-parse.y
 create mode 100644 gas/config/tc-loongarch.c
 create mode 100644 gas/config/tc-loongarch.h
 create mode 100644 include/elf/loongarch.h
 create mode 100644 include/opcode/loongarch.h
 create mode 100644 ld/emulparams/elf64loongarch-defs.sh
 create mode 100644 ld/emulparams/elf64loongarch.sh
 create mode 100644 ld/emultempl/loongarchelf.em
 create mode 100644 opcodes/loongarch-coder.c
 create mode 100644 opcodes/loongarch-dis.c
 create mode 100644 opcodes/loongarch-opc.c

diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index ed2f701805d..097177bae5c 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -118,6 +118,7 @@ ALL_MACHINES = \
 	cpu-ip2k.lo \
 	cpu-iq2000.lo \
 	cpu-lm32.lo \
+	cpu-loongarch.lo \
 	cpu-m10200.lo \
 	cpu-m10300.lo \
 	cpu-m32c.lo \
@@ -202,6 +203,7 @@ ALL_MACHINES_CFILES = \
 	cpu-ip2k.c \
 	cpu-iq2000.c \
 	cpu-lm32.c \
+	cpu-loongarch.c \
 	cpu-m10200.c \
 	cpu-m10300.c \
 	cpu-m32c.c \
@@ -548,6 +550,9 @@ BFD64_BACKENDS = \
 	elf64-ia64.lo \
 	elf64-ia64-vms.lo \
 	elfxx-ia64.lo \
+	elf32-loongarch.lo \
+	elf64-loongarch.lo \
+	elfxx-loongarch.lo \
 	elfn32-mips.lo \
 	elf64-mips.lo \
 	elfxx-mips.lo \
@@ -601,6 +606,7 @@ BFD64_BACKENDS_CFILES = \
 	elfn32-mips.c \
 	elfxx-aarch64.c \
 	elfxx-ia64.c \
+	elfxx-loongarch.c \
 	elfxx-mips.c \
 	elfxx-riscv.c \
 	mach-o-aarch64.c \
@@ -665,6 +671,7 @@ SOURCE_CFILES = \
 BUILD_CFILES = \
 	elf32-aarch64.c elf64-aarch64.c \
 	elf32-ia64.c elf64-ia64.c \
+	elf32-loongarch.c elf64-loongarch.c \
 	elf32-riscv.c elf64-riscv.c \
 	peigen.c pepigen.c pex64igen.c
 
@@ -686,7 +693,7 @@ SOURCE_HFILES = \
 	elf-bfd.h elfcode.h elfcore.h elf-hppa.h elf-linker-x86.h \
 	elf-linux-core.h elf-nacl.h elf-s390.h elf-vxworks.h \
 	elfxx-aarch64.h elfxx-ia64.h elfxx-mips.h elfxx-riscv.h \
-	elfxx-sparc.h elfxx-tilegx.h elfxx-x86.h \
+	elfxx-sparc.h elfxx-tilegx.h elfxx-x86.h elfxx-loongarch.h \
 	genlink.h go32stub.h \
 	libaout.h libbfd.h libcoff.h libecoff.h libhppa.h \
 	libpei.h libxcoff.h \
@@ -842,6 +849,14 @@ elf64-ia64.c : elfnn-ia64.c
 	echo "#line 1 \"elfnn-ia64.c\"" > $@
 	$(SED) -e s/NN/64/g < $< >> $@
 
+elf32-loongarch.c : elfnn-loongarch.c
+	echo "#line 1 \"elfnn-loongarch.c\"" > $@
+	$(SED) -e s/NN/32/g < $< >> $@
+
+elf64-loongarch.c : elfnn-loongarch.c
+	echo "#line 1 \"elfnn-loongarch.c\"" > $@
+	$(SED) -e s/NN/64/g < $< >> $@
+
 elf32-riscv.c : elfnn-riscv.c
 	echo "#line 1 \"elfnn-riscv.c\"" > $@
 	$(SED) -e s/NN/32/g < $< >> $@
diff --git a/bfd/Makefile.in b/bfd/Makefile.in
index 12807d99760..a76b653247f 100644
--- a/bfd/Makefile.in
+++ b/bfd/Makefile.in
@@ -543,6 +543,7 @@ ALL_MACHINES = \
 	cpu-ip2k.lo \
 	cpu-iq2000.lo \
 	cpu-lm32.lo \
+	cpu-loongarch.lo \
 	cpu-m10200.lo \
 	cpu-m10300.lo \
 	cpu-m32c.lo \
@@ -627,6 +628,7 @@ ALL_MACHINES_CFILES = \
 	cpu-ip2k.c \
 	cpu-iq2000.c \
 	cpu-lm32.c \
+	cpu-loongarch.c \
 	cpu-m10200.c \
 	cpu-m10300.c \
 	cpu-m32c.c \
@@ -975,6 +977,9 @@ BFD64_BACKENDS = \
 	elf64-ia64.lo \
 	elf64-ia64-vms.lo \
 	elfxx-ia64.lo \
+	elf32-loongarch.lo \
+	elf64-loongarch.lo \
+	elfxx-loongarch.lo \
 	elfn32-mips.lo \
 	elf64-mips.lo \
 	elfxx-mips.lo \
@@ -1028,6 +1033,7 @@ BFD64_BACKENDS_CFILES = \
 	elfn32-mips.c \
 	elfxx-aarch64.c \
 	elfxx-ia64.c \
+	elfxx-loongarch.c \
 	elfxx-mips.c \
 	elfxx-riscv.c \
 	mach-o-aarch64.c \
@@ -1091,6 +1097,7 @@ SOURCE_CFILES = \
 BUILD_CFILES = \
 	elf32-aarch64.c elf64-aarch64.c \
 	elf32-ia64.c elf64-ia64.c \
+	elf32-loongarch.c elf64-loongarch.c \
 	elf32-riscv.c elf64-riscv.c \
 	peigen.c pepigen.c pex64igen.c
 
@@ -1109,7 +1116,7 @@ SOURCE_HFILES = \
 	elf-bfd.h elfcode.h elfcore.h elf-hppa.h elf-linker-x86.h \
 	elf-linux-core.h elf-nacl.h elf-s390.h elf-vxworks.h \
 	elfxx-aarch64.h elfxx-ia64.h elfxx-mips.h elfxx-riscv.h \
-	elfxx-sparc.h elfxx-tilegx.h elfxx-x86.h \
+	elfxx-sparc.h elfxx-tilegx.h elfxx-x86.h elfxx-loongarch.h \
 	genlink.h go32stub.h \
 	libaout.h libbfd.h libcoff.h libecoff.h libhppa.h \
 	libpei.h libxcoff.h \
@@ -1349,6 +1356,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-k1om.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-l1om.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-lm32.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-loongarch.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-m10200.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-m10300.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-m32c.Plo@am__quote@
@@ -1442,6 +1450,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-ip2k.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-iq2000.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-lm32.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-loongarch.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-m32c.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-m32r.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-m68hc11.Plo@am__quote@
@@ -1492,6 +1501,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-hppa.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-ia64-vms.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-ia64.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-loongarch.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-mips.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-mmix.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-nfp.Plo@am__quote@
@@ -1506,6 +1516,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elfn32-mips.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elfxx-aarch64.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elfxx-ia64.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elfxx-loongarch.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elfxx-mips.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elfxx-riscv.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elfxx-sparc.Plo@am__quote@
@@ -1972,6 +1983,14 @@ elf64-ia64.c : elfnn-ia64.c
 	echo "#line 1 \"elfnn-ia64.c\"" > $@
 	$(SED) -e s/NN/64/g < $< >> $@
 
+elf32-loongarch.c : elfnn-loongarch.c
+	echo "#line 1 \"elfnn-loongarch.c\"" > $@
+	$(SED) -e s/NN/32/g < $< >> $@
+
+elf64-loongarch.c : elfnn-loongarch.c
+	echo "#line 1 \"elfnn-loongarch.c\"" > $@
+	$(SED) -e s/NN/64/g < $< >> $@
+
 elf32-riscv.c : elfnn-riscv.c
 	echo "#line 1 \"elfnn-riscv.c\"" > $@
 	$(SED) -e s/NN/32/g < $< >> $@
diff --git a/bfd/archures.c b/bfd/archures.c
index 390691bfba1..69dd9e5213f 100644
--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -555,6 +555,9 @@ DESCRIPTION
 .#define bfd_mach_ck807		6
 .#define bfd_mach_ck810		7
 .#define bfd_mach_ck860		8
+.  bfd_arch_loongarch,       {* Loongarch *}
+.#define bfd_mach_loongarch32	1
+.#define bfd_mach_loongarch64	2
 .  bfd_arch_last
 .  };
 */
@@ -635,6 +638,7 @@ extern const bfd_arch_info_type bfd_iq2000_arch;
 extern const bfd_arch_info_type bfd_k1om_arch;
 extern const bfd_arch_info_type bfd_l1om_arch;
 extern const bfd_arch_info_type bfd_lm32_arch;
+extern const bfd_arch_info_type bfd_loongarch_arch;
 extern const bfd_arch_info_type bfd_m32c_arch;
 extern const bfd_arch_info_type bfd_m32r_arch;
 extern const bfd_arch_info_type bfd_m68hc11_arch;
@@ -724,6 +728,7 @@ static const bfd_arch_info_type * const bfd_archures_list[] =
     &bfd_k1om_arch,
     &bfd_l1om_arch,
     &bfd_lm32_arch,
+    &bfd_loongarch_arch,
     &bfd_m32c_arch,
     &bfd_m32r_arch,
     &bfd_m68hc11_arch,
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 43d4ff0b925..9d11d352c20 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -1932,6 +1932,9 @@ enum bfd_architecture
 #define bfd_mach_ck807         6
 #define bfd_mach_ck810         7
 #define bfd_mach_ck860         8
+  bfd_arch_loongarch,       /* Loongarch */
+#define bfd_mach_loongarch32   1
+#define bfd_mach_loongarch64   2
   bfd_arch_last
   };
 
@@ -6263,6 +6266,51 @@ assembler and not (currently) written to any object files.  */
 
 /* S12Z relocations.  */
   BFD_RELOC_S12Z_OPR,
+
+/* LARCH relocations.  */
+  BFD_RELOC_LARCH_TLS_DTPMOD32,
+  BFD_RELOC_LARCH_TLS_DTPREL32,
+  BFD_RELOC_LARCH_TLS_DTPMOD64,
+  BFD_RELOC_LARCH_TLS_DTPREL64,
+  BFD_RELOC_LARCH_TLS_TPREL32,
+  BFD_RELOC_LARCH_TLS_TPREL64,
+  BFD_RELOC_LARCH_MARK_LA,
+  BFD_RELOC_LARCH_MARK_PCREL,
+  BFD_RELOC_LARCH_SOP_PUSH_PCREL,
+  BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE,
+  BFD_RELOC_LARCH_SOP_PUSH_DUP,
+  BFD_RELOC_LARCH_SOP_PUSH_GPREL,
+  BFD_RELOC_LARCH_SOP_PUSH_TLS_TPREL,
+  BFD_RELOC_LARCH_SOP_PUSH_TLS_GOT,
+  BFD_RELOC_LARCH_SOP_PUSH_TLS_GD,
+  BFD_RELOC_LARCH_SOP_PUSH_PLT_PCREL,
+  BFD_RELOC_LARCH_SOP_ASSERT,
+  BFD_RELOC_LARCH_SOP_NOT,
+  BFD_RELOC_LARCH_SOP_SUB,
+  BFD_RELOC_LARCH_SOP_SL,
+  BFD_RELOC_LARCH_SOP_SR,
+  BFD_RELOC_LARCH_SOP_ADD,
+  BFD_RELOC_LARCH_SOP_AND,
+  BFD_RELOC_LARCH_SOP_IF_ELSE,
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_5,
+  BFD_RELOC_LARCH_SOP_POP_32_U_10_12,
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_12,
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_16,
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2,
+  BFD_RELOC_LARCH_SOP_POP_32_S_5_20,
+  BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2,
+  BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2,
+  BFD_RELOC_LARCH_SOP_POP_32_U,
+  BFD_RELOC_LARCH_ADD8,
+  BFD_RELOC_LARCH_ADD16,
+  BFD_RELOC_LARCH_ADD24,
+  BFD_RELOC_LARCH_ADD32,
+  BFD_RELOC_LARCH_ADD64,
+  BFD_RELOC_LARCH_SUB8,
+  BFD_RELOC_LARCH_SUB16,
+  BFD_RELOC_LARCH_SUB24,
+  BFD_RELOC_LARCH_SUB32,
+  BFD_RELOC_LARCH_SUB64,
   BFD_RELOC_UNUSED };
 
 typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
diff --git a/bfd/config.bfd b/bfd/config.bfd
index 30087e3b8f8..50c4e4416a4 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -182,6 +182,7 @@ hppa*)		 targ_archs=bfd_hppa_arch ;;
 i[3-7]86)	 targ_archs=bfd_i386_arch ;;
 ia16)		 targ_archs=bfd_i386_arch ;;
 lm32)	         targ_archs=bfd_lm32_arch ;;
+loongarch*)		 targ_archs=bfd_loongarch_arch ;;
 m6811*|m68hc11*) targ_archs="bfd_m68hc11_arch bfd_m68hc12_arch bfd_m9s12x_arch bfd_m9s12xg_arch" ;;
 m6812*|m68hc12*) targ_archs="bfd_m68hc12_arch bfd_m68hc11_arch bfd_m9s12x_arch bfd_m9s12xg_arch" ;;
 m68*)		 targ_archs=bfd_m68k_arch ;;
@@ -1413,6 +1414,20 @@ case "${targ}" in
     targ_underscore=yes
     ;;
 
+#ifdef BFD64
+  loongarch32-*)
+    targ_defvec=loongarch_elf32_vec
+    targ_selvecs="loongarch_elf32_vec"
+    want64=false
+    ;;
+
+  loongarch64-*)
+    targ_defvec=loongarch_elf64_vec
+    targ_selvecs="loongarch_elf32_vec loongarch_elf64_vec"
+    want64=true
+    ;;
+#endif
+
 # END OF targmatch.h
   bpf-*-*)
     echo "*** Configuration $targ is not fully supported." >&2
diff --git a/bfd/configure b/bfd/configure
index 24171d00344..98a1790b05b 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -13348,6 +13348,8 @@ do
     l1om_elf64_fbsd_vec)	 tb="$tb elf64-x86-64.lo elfxx-x86.lo elf-ifunc.lo elf64.lo $elf"; target_size=64 ;;
     lm32_elf32_vec)		 tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
     lm32_elf32_fdpic_vec)	 tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
+    loongarch_elf32_vec)     tb="$tb elf32-loongarch.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf" ;;
+    loongarch_elf64_vec)	 tb="$tb elf64-loongarch.lo elf64.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf"; target_size=64 ;;
     m32c_elf32_vec)		 tb="$tb elf32-m32c.lo elf32.lo $elf" ;;
     m32r_elf32_vec)		 tb="$tb elf32-m32r.lo elf32.lo $elf" ;;
     m32r_elf32_le_vec)		 tb="$tb elf32-m32r.lo elf32.lo $elf" ;;
diff --git a/bfd/configure.ac b/bfd/configure.ac
index fec067b2135..4000b5fce58 100644
--- a/bfd/configure.ac
+++ b/bfd/configure.ac
@@ -528,6 +528,8 @@ do
     l1om_elf64_fbsd_vec)	 tb="$tb elf64-x86-64.lo elfxx-x86.lo elf-ifunc.lo elf64.lo $elf"; target_size=64 ;;
     lm32_elf32_vec)		 tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
     lm32_elf32_fdpic_vec)	 tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
+    loongarch_elf32_vec)	 tb="$tb elf32-loongarch.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf" ;;
+    loongarch_elf64_vec)	 tb="$tb elf64-loongarch.lo elf64.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf"; target_size=64 ;;
     m32c_elf32_vec)		 tb="$tb elf32-m32c.lo elf32.lo $elf" ;;
     m32r_elf32_vec)		 tb="$tb elf32-m32r.lo elf32.lo $elf" ;;
     m32r_elf32_le_vec)		 tb="$tb elf32-m32r.lo elf32.lo $elf" ;;
diff --git a/bfd/cpu-loongarch.c b/bfd/cpu-loongarch.c
new file mode 100644
index 00000000000..436a8784906
--- /dev/null
+++ b/bfd/cpu-loongarch.c
@@ -0,0 +1,59 @@
+/* BFD support for Loongarch.
+   Copyright (C) 2021-2021 Free Software Foundation, Inc.
+   Contributed by Loongson Ltd.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+static const bfd_arch_info_type bfd_loongarch32_arch = 
+{
+  32,                     /* 32 bits in a word.  */
+  32,                     /* 64 bits in an address.  */
+  8,                      /* 8 bits in a byte.  */
+  bfd_arch_loongarch,     /* Architecture.  */
+  bfd_mach_loongarch32,   /* Machine number - 0 for now.  */
+  "loongarch32",          /* Architecture name.  */
+  "Loongarch32",          /* Printable name.  */
+  3,                      /* Section align power.  */
+  false,                  /* This is the default architecture.  */
+  bfd_default_compatible, /* Architecture comparison function.  */
+  bfd_default_scan,       /* String to architecture conversion.  */
+  bfd_arch_default_fill,  /* Default fill.  */
+  NULL,                   /* Next in list.  */
+  0,
+};
+
+const bfd_arch_info_type bfd_loongarch_arch = 
+{
+  32,                   /* 32 bits in a word.  */
+  64,                   /* 64 bits in an address.  */
+  8,                    /* 8 bits in a byte.  */
+  bfd_arch_loongarch,   /* Architecture.  */
+  bfd_mach_loongarch64, /* Machine number of loongarch64 is larger so that loongarch64 is compatible to loongarch32  */
+  "loongarch64",        /* Architecture name.  */
+  "Loongarch64",        /* Printable name.  */
+  3,                    /* Section align power.  */
+  true,                 /* This is the default architecture.  */
+  bfd_default_compatible, /* Architecture comparison function.  */
+  bfd_default_scan,       /* String to architecture conversion.  */
+  bfd_arch_default_fill,  /* Default fill.  */
+  &bfd_loongarch32_arch,  /* Next in list.  */
+  0,
+};
diff --git a/bfd/elf-bfd.h b/bfd/elf-bfd.h
index b3f56b8c2ce..b93eb8dca33 100644
--- a/bfd/elf-bfd.h
+++ b/bfd/elf-bfd.h
@@ -508,6 +508,7 @@ enum elf_target_id
   I386_ELF_DATA,
   IA64_ELF_DATA,
   LM32_ELF_DATA,
+  LARCH_ELF_DATA,
   M32R_ELF_DATA,
   M68HC11_ELF_DATA,
   M68K_ELF_DATA,
@@ -2854,6 +2855,14 @@ extern char *elfcore_write_register_note
   (bfd *, char *, int *, const char *, const void *, int);
 extern char *elfcore_write_file_note
   (bfd *, char *, int *, const void*, int);
+extern char *elfcore_write_loongarch_cpucfg
+  (bfd *, char *, int *, const void*, int);
+extern char *elfcore_write_loongarch_lbt
+  (bfd *, char *, int *, const void*, int);
+extern char *elfcore_write_loongarch_lsx
+  (bfd *, char *, int *, const void*, int);
+extern char *elfcore_write_loongarch_lasx
+  (bfd *, char *, int *, const void*, int);
 
 /* Internal structure which holds information to be included in the
    PRPSINFO section of Linux core files.
diff --git a/bfd/elfnn-loongarch.c b/bfd/elfnn-loongarch.c
new file mode 100644
index 00000000000..6d135da2342
--- /dev/null
+++ b/bfd/elfnn-loongarch.c
@@ -0,0 +1,3125 @@
+/* Loongarch-specific support for NN-bit ELF.
+   Copyright (C) 2021-2021 Free Software Foundation, Inc.
+   Contributed by Loongson Ltd.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#define ARCH_SIZE NN
+#include "elf-bfd.h"
+#include "objalloc.h"
+#include "elf/loongarch.h"
+#include "elfxx-loongarch.h"
+
+#include <sys/procfs.h>
+
+static bool
+loongarch_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
+                              Elf_Internal_Rela *dst)
+{
+  cache_ptr->howto = loongarch_elf_rtype_to_howto (ELFNN_R_TYPE (dst->r_info));
+  return cache_ptr->howto != NULL;
+}
+
+/* Loongarch ELF linker hash entry.  */
+struct loongarch_elf_link_hash_entry
+{
+  struct elf_link_hash_entry elf;
+
+  /* Track dynamic relocs copied for this symbol.  */
+  struct elf_dyn_relocs *dyn_relocs;
+
+#define GOT_UNKNOWN 0
+#define GOT_NORMAL 1
+#define GOT_TLS_GD 2
+#define GOT_TLS_IE 4
+#define GOT_TLS_LE 8
+  char tls_type;
+};
+
+#define loongarch_elf_hash_entry(ent)                                         \
+  ((struct loongarch_elf_link_hash_entry *) (ent))
+
+struct _bfd_loongarch_elf_obj_tdata
+{
+  struct elf_obj_tdata root;
+
+  /* tls_type for each local got entry.  */
+  char *local_got_tls_type;
+};
+
+#define _bfd_loongarch_elf_tdata(abfd)                                        \
+  ((struct _bfd_loongarch_elf_obj_tdata *) (abfd)->tdata.any)
+
+#define _bfd_loongarch_elf_local_got_tls_type(abfd)                           \
+  (_bfd_loongarch_elf_tdata (abfd)->local_got_tls_type)
+
+#define _bfd_loongarch_elf_tls_type(abfd, h, symndx)                          \
+  (*((h) != NULL ? &loongarch_elf_hash_entry (h)->tls_type                    \
+                 : &_bfd_loongarch_elf_local_got_tls_type (abfd)[symndx]))
+
+#define is_loongarch_elf(bfd)                                                 \
+  (bfd_get_flavour (bfd) == bfd_target_elf_flavour &&                         \
+   elf_tdata (bfd) != NULL && elf_object_id (bfd) == LARCH_ELF_DATA)
+
+struct loongarch_elf_link_hash_table
+{
+  struct elf_link_hash_table elf;
+
+  /* Short-cuts to get to dynamic linker sections.  */
+  asection *sdyntdata;
+
+  /* Small local sym to section mapping cache.  */
+  struct sym_cache sym_cache;
+
+  /* Used by local STT_GNU_IFUNC symbols.  */
+  htab_t loc_hash_table;
+  void *loc_hash_memory;
+
+  /* The max alignment of output sections.  */
+  bfd_vma max_alignment;
+};
+
+/* Get the Loongarch ELF linker hash table from a link_info structure.  */
+#define loongarch_elf_hash_table(p)                                           \
+  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) ==          \
+       LARCH_ELF_DATA                                                         \
+     ? ((struct loongarch_elf_link_hash_table *) ((p)->hash))                 \
+     : NULL)
+
+#define MINUS_ONE ((bfd_vma) 0 - 1)
+
+#define sec_addr(sec) ((sec)->output_section->vma + (sec)->output_offset)
+
+#define LARCH_ELF_LOG_WORD_BYTES (ARCH_SIZE == 32 ? 2 : 3)
+#define LARCH_ELF_WORD_BYTES (1 << LARCH_ELF_LOG_WORD_BYTES)
+
+#define PLT_HEADER_INSNS 8
+#define PLT_HEADER_SIZE (PLT_HEADER_INSNS * 4)
+
+#define PLT_ENTRY_INSNS 4
+#define PLT_ENTRY_SIZE (PLT_ENTRY_INSNS * 4)
+
+#define GOT_ENTRY_SIZE (LARCH_ELF_WORD_BYTES)
+
+#define GOTPLT_HEADER_SIZE (GOT_ENTRY_SIZE * 2)
+
+#define elf_backend_want_got_plt 1
+
+#define elf_backend_plt_readonly 1
+
+#define elf_backend_want_plt_sym 0
+#define elf_backend_plt_alignment 4
+#define elf_backend_can_gc_sections 1
+/* #define elf_backend_can_refcount	1 */
+#define elf_backend_want_got_sym 1
+
+#define elf_backend_got_header_size (GOT_ENTRY_SIZE * 1)
+
+#define elf_backend_want_dynrelro 1
+/* #define elf_backend_rela_normal		1
+#define elf_backend_default_execstack	0 */
+
+/* Generate a PLT header.  */
+
+static void
+loongarch_make_plt_header (bfd_vma got_plt_addr, bfd_vma plt_header_addr,
+                           uint32_t *entry)
+{
+  int64_t pcrel = got_plt_addr - plt_header_addr;
+  int64_t hi = (pcrel & 0x800 ? 1 : 0) + (pcrel >> 12);
+  int64_t lo = pcrel & 0xfff;
+  if ((hi >> 19) != 0 && (hi >> 19) != -1)
+    abort ();
+
+  /* pcaddu12i  $t2, %hi(%pcrel(.got.plt))
+     sub.[wd]   $t1, $t1, $t3
+     ld.[wd]    $t3, $t2, %lo(%pcrel(.got.plt)) # _dl_runtime_resolve
+     addi.[wd]  $t1, $t1, -(PLT_HEADER_SIZE + 12)
+     addi.[wd]  $t0, $t2, %lo(%pcrel(.got.plt))
+     srli.[wd]  $t1, $t1, log2(16 / GOT_ENTRY_SIZE)
+     ld.[wd]    $t0, $t0, GOT_ENTRY_SIZE
+     jirl   $r0, $t3, 0 */
+
+  if (GOT_ENTRY_SIZE == 8)
+    {
+      entry[0] = 0x1c00000e | (hi & 0xfffff) << 5;
+      entry[1] = 0x0011bdad;
+      entry[2] = 0x28c001cf | (lo & 0xfff) << 10;
+      entry[3] = 0x02c001ad | ((-(PLT_HEADER_SIZE + 12)) & 0xfff) << 10;
+      entry[4] = 0x02c001cc | (lo & 0xfff) << 10;
+      entry[5] = 0x004501ad | (4 - LARCH_ELF_LOG_WORD_BYTES) << 10;
+      entry[6] = 0x28c0018c | GOT_ENTRY_SIZE << 10;
+      entry[7] = 0x4c0001e0;
+    }
+  else
+    {
+      entry[0] = 0x1c00000e | (hi & 0xfffff) << 5;
+      entry[1] = 0x00113dad;
+      entry[2] = 0x288001cf | (lo & 0xfff) << 10;
+      entry[3] = 0x028001ad | ((-(PLT_HEADER_SIZE + 12)) & 0xfff) << 10;
+      entry[4] = 0x028001cc | (lo & 0xfff) << 10;
+      entry[5] = 0x004481ad | (4 - LARCH_ELF_LOG_WORD_BYTES) << 10;
+      entry[6] = 0x2880018c | GOT_ENTRY_SIZE << 10;
+      entry[7] = 0x4c0001e0;
+    }
+}
+
+/* Generate a PLT entry.  */
+
+static void
+loongarch_make_plt_entry (bfd_vma got_plt_entry_addr, bfd_vma plt_entry_addr,
+                          uint32_t *entry)
+{
+  int64_t pcrel = got_plt_entry_addr - plt_entry_addr;
+  int64_t hi = (pcrel & 0x800 ? 1 : 0) + (pcrel >> 12);
+  int64_t lo = pcrel & 0xfff;
+  if ((hi >> 19) != 0 && (hi >> 19) != -1)
+    abort ();
+
+  entry[0] = 0x1c00000f | (hi & 0xfffff) << 5;
+  entry[1] = (GOT_ENTRY_SIZE == 8 ? 0x28c001ef : 0x288001ef)
+	     | (lo & 0xfff) << 10;
+  entry[2] = 0x4c0001ed;        /* jirl $r13, $15, 0 */
+  entry[3] = 0x03400000;        /* nop */
+  /* entry[2] = 0x1c00000d; */ /* pcaddu12i $13, 4 */
+  /* entry[3] = 0x4c0001e0; */ /* jirl $r0, $15, 0 */
+}
+
+/* Create an entry in an Loongarch ELF linker hash table.  */
+
+static struct bfd_hash_entry *
+link_hash_newfunc (struct bfd_hash_entry *entry, struct bfd_hash_table *table,
+                   const char *string)
+{
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (entry == NULL)
+    {
+      entry = bfd_hash_allocate (
+        table, sizeof (struct loongarch_elf_link_hash_entry));
+      if (entry == NULL)
+        return entry;
+    }
+
+  /* Call the allocation method of the superclass.  */
+  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
+  if (entry != NULL)
+    {
+      struct loongarch_elf_link_hash_entry *eh;
+
+      eh = (struct loongarch_elf_link_hash_entry *) entry;
+      eh->dyn_relocs = NULL;
+      eh->tls_type = GOT_UNKNOWN;
+    }
+
+  return entry;
+}
+
+/* Compute a hash of a local hash entry.  We use elf_link_hash_entry
+  for local symbol so that we can handle local STT_GNU_IFUNC symbols
+  as global symbol.  We reuse indx and dynstr_index for local symbol
+  hash since they aren't used by global symbols in this backend.  */
+
+static hashval_t
+elfNN_loongarch_local_htab_hash (const void *ptr)
+{
+  struct elf_link_hash_entry *h = (struct elf_link_hash_entry *) ptr;
+  return ELF_LOCAL_SYMBOL_HASH (h->indx, h->dynstr_index);
+}
+
+/* Compare local hash entries.  */
+
+static int
+elfNN_loongarch_local_htab_eq (const void *ptr1, const void *ptr2)
+{
+  struct elf_link_hash_entry *h1 = (struct elf_link_hash_entry *) ptr1;
+  struct elf_link_hash_entry *h2 = (struct elf_link_hash_entry *) ptr2;
+
+  return h1->indx == h2->indx && h1->dynstr_index == h2->dynstr_index;
+}
+
+/* Find and/or create a hash entry for local symbol.  */
+static struct elf_link_hash_entry *
+elfNN_loongarch_get_local_sym_hash (struct loongarch_elf_link_hash_table *htab,
+                                    bfd *abfd, const Elf_Internal_Rela *rel,
+                                    bool create)
+{
+  struct loongarch_elf_link_hash_entry e, *ret;
+  asection *sec = abfd->sections;
+  hashval_t h = ELF_LOCAL_SYMBOL_HASH (sec->id, ELFNN_R_SYM (rel->r_info));
+  void **slot;
+
+  e.elf.indx = sec->id;
+  e.elf.dynstr_index = ELFNN_R_SYM (rel->r_info);
+  slot = htab_find_slot_with_hash (htab->loc_hash_table, &e, h,
+                                   create ? INSERT : NO_INSERT);
+
+  if (!slot)
+    return NULL;
+
+  if (*slot)
+    {
+      ret = (struct loongarch_elf_link_hash_entry *) *slot;
+      return &ret->elf;
+    }
+
+  ret = (struct loongarch_elf_link_hash_entry *) objalloc_alloc (
+    (struct objalloc *) htab->loc_hash_memory,
+    sizeof (struct loongarch_elf_link_hash_entry));
+  if (ret)
+    {
+      memset (ret, 0, sizeof (*ret));
+      ret->elf.indx = sec->id;
+      ret->elf.pointer_equality_needed = 0;
+      ret->elf.dynstr_index = ELFNN_R_SYM (rel->r_info);
+      ret->elf.dynindx = -1;
+      ret->elf.needs_plt = 0;
+      ret->elf.plt.refcount = -1;
+      ret->elf.got.refcount = -1;
+      ret->elf.def_dynamic = 0;
+      ret->elf.def_regular = 1;
+      ret->elf.ref_dynamic = 0; /* this should be always 0 for local  */
+      ret->elf.ref_regular = 0;
+      ret->elf.forced_local = 1;
+      ret->elf.root.type = bfd_link_hash_defined;
+      *slot = ret;
+    }
+  return &ret->elf;
+}
+
+/* Destroy an Loongarch elf linker hash table.  */
+
+static void
+elfNN_loongarch_link_hash_table_free (bfd *obfd)
+{
+  struct loongarch_elf_link_hash_table *ret =
+    (struct loongarch_elf_link_hash_table *) obfd->link.hash;
+
+  if (ret->loc_hash_table)
+    htab_delete (ret->loc_hash_table);
+  if (ret->loc_hash_memory)
+    objalloc_free ((struct objalloc *) ret->loc_hash_memory);
+
+  _bfd_elf_link_hash_table_free (obfd);
+}
+
+/* Create a Loongarch ELF linker hash table.  */
+
+static struct bfd_link_hash_table *
+loongarch_elf_link_hash_table_create (bfd *abfd)
+{
+  struct loongarch_elf_link_hash_table *ret;
+  bfd_size_type amt = sizeof (struct loongarch_elf_link_hash_table);
+
+  ret = (struct loongarch_elf_link_hash_table *) bfd_zmalloc (amt);
+  if (ret == NULL)
+    return NULL;
+
+  if (!_bfd_elf_link_hash_table_init (
+        &ret->elf, abfd, link_hash_newfunc,
+        sizeof (struct loongarch_elf_link_hash_entry), LARCH_ELF_DATA))
+    {
+      free (ret);
+      return NULL;
+    }
+
+  ret->max_alignment = MINUS_ONE;
+
+  ret->loc_hash_table = htab_try_create (1024, elfNN_loongarch_local_htab_hash,
+                                         elfNN_loongarch_local_htab_eq, NULL);
+  ret->loc_hash_memory = objalloc_create ();
+  if (!ret->loc_hash_table || !ret->loc_hash_memory)
+    {
+      elfNN_loongarch_link_hash_table_free (abfd);
+      return NULL;
+    }
+  ret->elf.root.hash_table_free = elfNN_loongarch_link_hash_table_free;
+
+  return &ret->elf.root;
+}
+
+/* Merge backend specific data from an object file to the output
+   object file when linking.  */
+
+static bool
+elfNN_loongarch_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
+{
+  bfd *obfd = info->output_bfd;
+  flagword in_flags = elf_elfheader (ibfd)->e_flags;
+  flagword out_flags = elf_elfheader (obfd)->e_flags;
+
+  if (!is_loongarch_elf (ibfd) || !is_loongarch_elf (obfd))
+    {
+      /* Make sure one of ibfd or obfd e_flags must be set.  */
+      /* FIXME: EF_LARCH_ABI_LP64 ? .  */
+      if (!is_loongarch_elf (ibfd) && !elf_flags_init (obfd))
+        {
+          elf_flags_init (obfd) = true;
+          elf_elfheader (obfd)->e_flags = EF_LARCH_ABI_LP64;
+        }
+
+      if (!is_loongarch_elf (obfd) && !elf_flags_init (ibfd))
+        {
+          elf_flags_init (ibfd) = true;
+          elf_elfheader (ibfd)->e_flags = EF_LARCH_ABI_LP64;
+        }
+
+      return true;
+    }
+
+  if (strcmp (bfd_get_target (ibfd), bfd_get_target (obfd)) != 0)
+    {
+      _bfd_error_handler (
+        _ ("%pB: ABI is incompatible with that of the selected emulation:\n"
+           "  target emulation `%s' does not match `%s'"),
+        ibfd, bfd_get_target (ibfd), bfd_get_target (obfd));
+      return false;
+    }
+
+  if (!_bfd_elf_merge_object_attributes (ibfd, info))
+    return false;
+
+  if (!elf_flags_init (obfd))
+    {
+      elf_flags_init (obfd) = true;
+      elf_elfheader (obfd)->e_flags = in_flags;
+      return true;
+    }
+
+  /* Disallow linking different float ABIs.  */
+  if ((out_flags ^ in_flags) & EF_LARCH_ABI)
+    {
+      _bfd_error_handler (_ ("%pB: can't link different ABI object."), ibfd);
+      goto fail;
+    }
+
+  return true;
+
+fail:
+  bfd_set_error (bfd_error_bad_value);
+  return false;
+}
+
+/* Create the .got section.  */
+
+static bool
+loongarch_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)
+{
+  flagword flags;
+  asection *s, *s_got;
+  struct elf_link_hash_entry *h;
+  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  struct elf_link_hash_table *htab = elf_hash_table (info);
+
+  /* This function may be called more than once.  */
+  if (htab->sgot != NULL)
+    return true;
+
+  flags = bed->dynamic_sec_flags;
+
+  s = bfd_make_section_anyway_with_flags (
+    abfd, bed->rela_plts_and_copies_p ? ".rela.got" : ".rel.got",
+    bed->dynamic_sec_flags | SEC_READONLY);
+  if (s == NULL || !bfd_set_section_alignment (s, bed->s->log_file_align))
+    return false;
+  htab->srelgot = s;
+
+  s = s_got = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
+  if (s == NULL || !bfd_set_section_alignment (s, bed->s->log_file_align))
+    return false;
+  htab->sgot = s;
+
+  /* The first bit of the global offset table is the header.  */
+  s->size += bed->got_header_size;
+
+  if (bed->want_got_plt)
+    {
+      s = bfd_make_section_anyway_with_flags (abfd, ".got.plt", flags);
+      if (s == NULL || !bfd_set_section_alignment (s, bed->s->log_file_align))
+        return false;
+      htab->sgotplt = s;
+
+      /* Reserve room for the header.  */
+      s->size = GOTPLT_HEADER_SIZE;
+    }
+
+  if (bed->want_got_sym)
+    {
+      /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
+	 section.  We don't do this in the linker script because we don't want
+	 to define the symbol if we are not creating a global offset table.  */
+      h = _bfd_elf_define_linkage_sym (abfd, info, s_got,
+                                       "_GLOBAL_OFFSET_TABLE_");
+      elf_hash_table (info)->hgot = h;
+      if (h == NULL)
+        return false;
+    }
+  return true;
+}
+
+/* Create .plt, .rela.plt, .got, .got.plt, .rela.got, .dynbss, and
+   .rela.bss sections in DYNOBJ, and set up shortcuts to them in our
+   hash table.  */
+
+static bool
+loongarch_elf_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
+{
+  struct loongarch_elf_link_hash_table *htab;
+
+  htab = loongarch_elf_hash_table (info);
+  BFD_ASSERT (htab != NULL);
+
+  if (!loongarch_elf_create_got_section (dynobj, info))
+    return false;
+
+  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
+    return false;
+
+  if (!bfd_link_pic (info))
+    {
+      htab->sdyntdata = bfd_make_section_anyway_with_flags (
+        dynobj, ".tdata.dyn", SEC_ALLOC | SEC_THREAD_LOCAL);
+    }
+
+  if (!htab->elf.splt || !htab->elf.srelplt || !htab->elf.sdynbss ||
+      (!bfd_link_pic (info) && (!htab->elf.srelbss || !htab->sdyntdata)))
+    abort ();
+
+  return true;
+}
+
+static bool
+loongarch_elf_record_tls_and_got_reference (bfd *abfd,
+                                            struct bfd_link_info *info,
+                                            struct elf_link_hash_entry *h,
+                                            unsigned long symndx,
+                                            char tls_type)
+{
+  struct loongarch_elf_link_hash_table *htab = loongarch_elf_hash_table (info);
+  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+
+  /* This is a global offset table entry for a local symbol.  */
+  if (elf_local_got_refcounts (abfd) == NULL)
+    {
+      bfd_size_type size =
+        symtab_hdr->sh_info * (sizeof (bfd_vma) + sizeof (tls_type));
+      if (!(elf_local_got_refcounts (abfd) = bfd_zalloc (abfd, size)))
+        return false;
+      _bfd_loongarch_elf_local_got_tls_type (abfd) =
+        (char *) (elf_local_got_refcounts (abfd) + symtab_hdr->sh_info);
+    }
+
+  switch (tls_type)
+    {
+    case GOT_NORMAL:
+    case GOT_TLS_GD:
+    case GOT_TLS_IE:
+      /* need GOT */
+      if (htab->elf.sgot == NULL &&
+          !loongarch_elf_create_got_section (htab->elf.dynobj, info))
+        return false;
+      if (h)
+        {
+          if (h->got.refcount < 0)
+            h->got.refcount = 0;
+          h->got.refcount++;
+        }
+      else
+        elf_local_got_refcounts (abfd)[symndx]++;
+      break;
+    case GOT_TLS_LE:
+      /* no need for GOT */
+      break;
+    default:
+      _bfd_error_handler (_ ("Interl error: unreachable."));
+      return false;
+    }
+
+  char *new_tls_type = &_bfd_loongarch_elf_tls_type (abfd, h, symndx);
+  *new_tls_type |= tls_type;
+  if ((*new_tls_type & GOT_NORMAL) && (*new_tls_type & ~GOT_NORMAL))
+    {
+      _bfd_error_handler (
+        _ ("%pB: `%s' accessed both as normal and thread local symbol"), abfd,
+        h ? h->root.root.string : "<local>");
+      return false;
+    }
+
+  return true;
+}
+
+/* Look through the relocs for a section during the first phase, and
+   allocate space in the global offset table or procedure linkage
+   table.  */
+
+static bool
+loongarch_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
+                            asection *sec, const Elf_Internal_Rela *relocs)
+{
+  struct loongarch_elf_link_hash_table *htab;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel;
+  asection *sreloc = NULL;
+
+  if (bfd_link_relocatable (info))
+    return true;
+
+  htab = loongarch_elf_hash_table (info);
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+
+  if (htab->elf.dynobj == NULL)
+    htab->elf.dynobj = abfd;
+
+  for (rel = relocs; rel < relocs + sec->reloc_count; rel++)
+    {
+      unsigned int r_type;
+      unsigned int r_symndx;
+      struct elf_link_hash_entry *h;
+      Elf_Internal_Sym *isym = NULL;
+
+      int need_dynreloc;
+      int only_need_pcrel;
+
+      r_symndx = ELFNN_R_SYM (rel->r_info);
+      r_type = ELFNN_R_TYPE (rel->r_info);
+
+      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
+        {
+          _bfd_error_handler (_ ("%pB: bad symbol index: %d"), abfd, r_symndx);
+          return false;
+        }
+
+      if (r_symndx < symtab_hdr->sh_info)
+        {
+          /* A local symbol.  */
+          isym = bfd_sym_from_r_symndx (&htab->sym_cache, abfd, r_symndx);
+          if (isym == NULL)
+            return false;
+
+          if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
+            {
+              h = elfNN_loongarch_get_local_sym_hash (htab, abfd, rel, true);
+              if (h == NULL)
+                return false;
+
+              h->type = STT_GNU_IFUNC;
+              h->ref_regular = 1;
+            }
+          else
+            h = NULL;
+        }
+      else
+        {
+          h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+          while (h->root.type == bfd_link_hash_indirect ||
+                 h->root.type == bfd_link_hash_warning)
+            h = (struct elf_link_hash_entry *) h->root.u.i.link;
+        }
+
+      if (h && h->type == STT_GNU_IFUNC)
+        {
+          if (htab->elf.dynobj == NULL)
+            htab->elf.dynobj = abfd;
+
+          if (!htab->elf.splt &&
+              !_bfd_elf_create_ifunc_sections (htab->elf.dynobj, info))
+            /* If '.plt' not represent, create '.iplt' to deal with ifunc. */
+            return false;
+
+          if (h->plt.refcount < 0)
+            h->plt.refcount = 0;
+          h->plt.refcount++;
+          h->needs_plt = 1;
+
+          elf_tdata (info->output_bfd)->has_gnu_osabi |= elf_gnu_osabi_ifunc;
+        }
+
+      need_dynreloc = 0;
+      only_need_pcrel = 0;
+      switch (r_type)
+        {
+        case R_LARCH_SOP_PUSH_GPREL:
+          if (!loongarch_elf_record_tls_and_got_reference (
+                abfd, info, h, r_symndx, GOT_NORMAL))
+            return false;
+          break;
+
+        case R_LARCH_SOP_PUSH_TLS_GD:
+          if (!loongarch_elf_record_tls_and_got_reference (
+                abfd, info, h, r_symndx, GOT_TLS_GD))
+            return false;
+          break;
+
+        case R_LARCH_SOP_PUSH_TLS_GOT:
+          if (bfd_link_pic (info))
+            /* may fail for lazy-bind */
+            info->flags |= DF_STATIC_TLS;
+
+          if (!loongarch_elf_record_tls_and_got_reference (
+                abfd, info, h, r_symndx, GOT_TLS_IE))
+            return false;
+          break;
+
+        case R_LARCH_SOP_PUSH_TLS_TPREL:
+          if (!bfd_link_executable (info))
+            return false;
+
+          info->flags |= DF_STATIC_TLS;
+
+          if (!loongarch_elf_record_tls_and_got_reference (
+                abfd, info, h, r_symndx, GOT_TLS_LE))
+            return false;
+          break;
+
+        case R_LARCH_SOP_PUSH_ABSOLUTE:
+          if (h != NULL)
+            /* If this reloc is in a read-only section, we might
+	       need a copy reloc.  We can't check reliably at this
+	       stage whether the section is read-only, as input
+	       sections have not yet been mapped to output sections.
+	       Tentatively set the flag for now, and correct in
+	       adjust_dynamic_symbol.  */
+            h->non_got_ref = 1;
+          break;
+
+        case R_LARCH_SOP_PUSH_PCREL:
+          if (h != NULL)
+            {
+              h->non_got_ref = 1;
+
+              /* We try to create PLT stub for all non-local function.  */
+              if (h->plt.refcount < 0)
+                h->plt.refcount = 0;
+              h->plt.refcount++;
+            }
+          break;
+
+        case R_LARCH_SOP_PUSH_PLT_PCREL:
+          /* This symbol requires a procedure linkage table entry.  We
+	     actually build the entry in adjust_dynamic_symbol,
+	     because this might be a case of linking PIC code without
+	     linking in any dynamic objects, in which case we don't
+	     need to generate a procedure linkage table after all.  */
+          if (h != NULL)
+            {
+              h->needs_plt = 1;
+              if (h->plt.refcount < 0)
+                h->plt.refcount = 0;
+              h->plt.refcount++;
+            }
+          break;
+
+        case R_LARCH_TLS_DTPREL32:
+        case R_LARCH_TLS_DTPREL64:
+          need_dynreloc = 1;
+          only_need_pcrel = 1;
+          break;
+
+        case R_LARCH_JUMP_SLOT:
+        case R_LARCH_32:
+        case R_LARCH_64:
+          need_dynreloc = 1;
+
+          /* If resolved symbol is defined in this object,
+	       1. Under pie, the symbol is known. We convert it
+		  into R_LARCH_RELATIVE and need load-addr still.
+	       2. Under pde, the symbol is known and we can discard R_LARCH_NN.
+	       3. Under dll, R_LARCH_NN can't be changed normally, since
+		  its defination could be covered by the one in executable.
+		  For symbolic, we convert it into R_LARCH_RELATIVE.
+	     Thus, only under pde, it needs pcrel only. We discard it. */
+          only_need_pcrel = bfd_link_pde (info);
+
+          if (h != NULL)
+            h->non_got_ref = 1;
+          break;
+
+        case R_LARCH_GNU_VTINHERIT:
+          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+            return false;
+          break;
+
+        case R_LARCH_GNU_VTENTRY:
+          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
+            return false;
+          break;
+
+        default:
+          break;
+        }
+
+      /* Record some info for sizing and allocating dynamic entry */
+      if (need_dynreloc && (sec->flags & SEC_ALLOC))
+        {
+          /* When creating a shared object, we must copy these
+	     relocs into the output file.  We create a reloc
+	     section in dynobj and make room for the reloc.  */
+          struct elf_dyn_relocs *p;
+          struct elf_dyn_relocs **head;
+
+          if (sreloc == NULL)
+            {
+              sreloc = _bfd_elf_make_dynamic_reloc_section (
+                sec, htab->elf.dynobj, LARCH_ELF_LOG_WORD_BYTES, abfd,
+                /*rela?*/ true);
+
+              if (sreloc == NULL)
+                return false;
+            }
+
+          /* If this is a global symbol, we count the number of
+	     relocations we need for this symbol.  */
+          if (h != NULL)
+            head = &((struct loongarch_elf_link_hash_entry *) h)->dyn_relocs;
+          else
+            {
+              /* Track dynamic relocs needed for local syms too.
+		 We really need local syms available to do this
+		 easily.  Oh well.  */
+
+              asection *s;
+              void *vpp;
+
+              s = bfd_section_from_elf_index (abfd, isym->st_shndx);
+              if (s == NULL)
+                s = sec;
+
+              vpp = &elf_section_data (s)->local_dynrel;
+              head = (struct elf_dyn_relocs **) vpp;
+            }
+
+          p = *head;
+          if (p == NULL || p->sec != sec)
+            {
+              bfd_size_type amt = sizeof *p;
+              p = (struct elf_dyn_relocs *) bfd_alloc (htab->elf.dynobj, amt);
+              if (p == NULL)
+                return false;
+              p->next = *head;
+              *head = p;
+              p->sec = sec;
+              p->count = 0;
+              p->pc_count = 0;
+            }
+
+          p->count++;
+          p->pc_count += only_need_pcrel;
+        }
+    }
+
+  return true;
+}
+
+/* Find dynamic relocs for H that apply to read-only sections.  */
+
+static asection *
+readonly_dynrelocs (struct elf_link_hash_entry *h)
+{
+  struct elf_dyn_relocs *p;
+
+  for (p = loongarch_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *s = p->sec->output_section;
+
+      if (s != NULL && (s->flags & SEC_READONLY) != 0)
+        return p->sec;
+    }
+  return NULL;
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+static bool
+loongarch_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
+                                     struct elf_link_hash_entry *h)
+{
+  struct loongarch_elf_link_hash_table *htab;
+  struct loongarch_elf_link_hash_entry *eh;
+  bfd *dynobj;
+  asection *s, *srel;
+
+  htab = loongarch_elf_hash_table (info);
+  BFD_ASSERT (htab != NULL);
+
+  dynobj = htab->elf.dynobj;
+
+  /* Make sure we know what is going on here.  */
+  BFD_ASSERT (dynobj != NULL &&
+              (h->needs_plt || h->type == STT_GNU_IFUNC || h->is_weakalias ||
+               (h->def_dynamic && h->ref_regular && !h->def_regular)));
+
+  /* If this is a function, put it in the procedure linkage table.  We
+     will fill in the contents of the procedure linkage table later
+     (although we could actually do it here).  */
+  if (h->type == STT_FUNC || h->type == STT_GNU_IFUNC || h->needs_plt)
+    {
+      if (h->plt.refcount < 0 ||
+          (h->type != STT_GNU_IFUNC &&
+           (SYMBOL_REFERENCES_LOCAL (info, h) ||
+            (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT &&
+             h->root.type == bfd_link_hash_undefweak))))
+        {
+          /* This case can occur if we saw a R_LARCH_SOP_PUSH_PLT_PCREL reloc
+	     in an input file, but the symbol was never referred to by a
+	     dynamic object, or if all references were garbage collected.
+	     In such a case, we don't actually need to build a PLT entry.  */
+          h->plt.offset = MINUS_ONE;
+          h->needs_plt = 0;
+        }
+      else
+        h->needs_plt = 1;
+
+      return true;
+    }
+  else
+    h->plt.offset = MINUS_ONE;
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->is_weakalias)
+    {
+      struct elf_link_hash_entry *def = weakdef (h);
+      BFD_ASSERT (def->root.type == bfd_link_hash_defined);
+      h->root.u.def.section = def->root.u.def.section;
+      h->root.u.def.value = def->root.u.def.value;
+      return true;
+    }
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (bfd_link_dll (info))
+    return true;
+
+  /* If there are no references to this symbol that do not use the
+     GOT, we don't need to generate a copy reloc.  */
+  if (!h->non_got_ref)
+    return true;
+
+  /* If -z nocopyreloc was given, we won't generate them either.  */
+  if (info->nocopyreloc)
+    {
+      h->non_got_ref = 0;
+      return true;
+    }
+
+  /* If we don't find any dynamic relocs in read-only sections, then
+     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
+  if (!readonly_dynrelocs (h))
+    {
+      h->non_got_ref = 0;
+      return true;
+    }
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+  /* We must generate a R_LARCH_COPY reloc to tell the dynamic linker
+     to copy the initial value out of the dynamic object and into the
+     runtime process image.  We need to remember the offset into the
+     .rel.bss section we are going to use.  */
+  eh = (struct loongarch_elf_link_hash_entry *) h;
+  if (eh->tls_type & ~GOT_NORMAL)
+    {
+      s = htab->sdyntdata;
+      srel = htab->elf.srelbss;
+    }
+  else if ((h->root.u.def.section->flags & SEC_READONLY) != 0)
+    {
+      s = htab->elf.sdynrelro;
+      srel = htab->elf.sreldynrelro;
+    }
+  else
+    {
+      s = htab->elf.sdynbss;
+      srel = htab->elf.srelbss;
+    }
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
+    {
+      srel->size += sizeof (ElfNN_External_Rela);
+      h->needs_copy = 1;
+    }
+
+  return _bfd_elf_adjust_dynamic_copy (info, h, s);
+}
+
+/* Allocate space in .plt, .got and associated reloc sections for
+   dynamic relocs.  */
+
+static bool
+allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
+{
+  struct bfd_link_info *info;
+  struct loongarch_elf_link_hash_table *htab;
+  struct loongarch_elf_link_hash_entry *eh;
+  struct elf_dyn_relocs *p;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return true;
+
+  eh = (struct loongarch_elf_link_hash_entry *) h;
+  info = (struct bfd_link_info *) inf;
+  htab = loongarch_elf_hash_table (info);
+  BFD_ASSERT (htab != NULL);
+
+  do
+    {
+      asection *plt, *gotplt, *relplt;
+
+      if (!h->needs_plt)
+        break;
+
+      h->needs_plt = 0;
+
+      if (htab->elf.splt)
+        {
+          if (h->dynindx == -1 && !h->forced_local &&
+              !bfd_elf_link_record_dynamic_symbol (info, h))
+            return false;
+
+          if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, bfd_link_pic (info), h) &&
+              h->type != STT_GNU_IFUNC)
+            break;
+
+          plt = htab->elf.splt;
+          gotplt = htab->elf.sgotplt;
+          relplt = htab->elf.srelplt;
+        }
+      else if (htab->elf.iplt)
+        {
+          /* .iplt only for IFUNC */
+          if (h->type != STT_GNU_IFUNC)
+            break;
+
+          plt = htab->elf.iplt;
+          gotplt = htab->elf.igotplt;
+          relplt = htab->elf.irelplt;
+        }
+      else
+        break;
+
+      if (plt->size == 0)
+        plt->size = PLT_HEADER_SIZE;
+
+      h->plt.offset = plt->size;
+      plt->size += PLT_ENTRY_SIZE;
+      gotplt->size += GOT_ENTRY_SIZE;
+      relplt->size += sizeof (ElfNN_External_Rela);
+
+      h->needs_plt = 1;
+    }
+  while (0);
+
+  if (!h->needs_plt)
+    h->plt.offset = MINUS_ONE;
+
+  if (0 < h->got.refcount)
+    {
+      asection *s;
+      bool dyn;
+      int tls_type = loongarch_elf_hash_entry (h)->tls_type;
+
+      /* Make sure this symbol is output as a dynamic symbol.
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1 && !h->forced_local &&
+          !bfd_elf_link_record_dynamic_symbol (info, h))
+        return false;
+
+      s = htab->elf.sgot;
+      h->got.offset = s->size;
+      dyn = htab->elf.dynamic_sections_created;
+      if (tls_type & (GOT_TLS_GD | GOT_TLS_IE))
+        {
+          /* TLS_GD needs two dynamic relocs and two GOT slots.  */
+          if (tls_type & GOT_TLS_GD)
+            {
+              s->size += 2 * GOT_ENTRY_SIZE;
+              htab->elf.srelgot->size += 2 * sizeof (ElfNN_External_Rela);
+            }
+
+          /* TLS_IE needs one dynamic reloc and one GOT slot.  */
+          if (tls_type & GOT_TLS_IE)
+            {
+              s->size += GOT_ENTRY_SIZE;
+              htab->elf.srelgot->size += sizeof (ElfNN_External_Rela);
+            }
+        }
+      else
+        {
+          s->size += GOT_ENTRY_SIZE;
+          if ((WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, bfd_link_pic (info), h) &&
+               !UNDEFWEAK_NO_DYNAMIC_RELOC (info, h)) ||
+              h->type == STT_GNU_IFUNC)
+            htab->elf.srelgot->size += sizeof (ElfNN_External_Rela);
+        }
+    }
+  else
+    h->got.offset = MINUS_ONE;
+
+  if (eh->dyn_relocs == NULL)
+    return true;
+
+  if (SYMBOL_REFERENCES_LOCAL (info, h))
+    {
+      struct elf_dyn_relocs **pp;
+
+      for (pp = &eh->dyn_relocs; (p = *pp) != NULL;)
+        {
+          p->count -= p->pc_count;
+          p->pc_count = 0;
+          if (p->count == 0)
+            *pp = p->next;
+          else
+            pp = &p->next;
+        }
+    }
+
+  if (h->root.type == bfd_link_hash_undefweak)
+    {
+      if (UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))
+        eh->dyn_relocs = NULL;
+      else if (h->dynindx == -1 &&
+               !h->forced_local
+               /* Make sure this symbol is output as a dynamic symbol.
+		  Undefined weak syms won't yet be marked as dynamic.  */
+               && !bfd_elf_link_record_dynamic_symbol (info, h))
+        return false;
+    }
+
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *sreloc = elf_section_data (p->sec)->sreloc;
+      sreloc->size += p->count * sizeof (ElfNN_External_Rela);
+    }
+
+  return true;
+}
+
+static bool
+elfNN_loongarch_allocate_local_dynrelocs (void **slot, void *inf)
+{
+  struct elf_link_hash_entry *h = (struct elf_link_hash_entry *) *slot;
+
+  if (!h->def_regular || !h->ref_regular || !h->forced_local ||
+      h->root.type != bfd_link_hash_defined)
+    abort ();
+
+  return allocate_dynrelocs (h, inf);
+}
+
+/* Set DF_TEXTREL if we find any dynamic relocs that apply to
+   read-only sections.  */
+
+static bool
+maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
+{
+  asection *sec;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return true;
+
+  sec = readonly_dynrelocs (h);
+  if (sec != NULL)
+    {
+      struct bfd_link_info *info = (struct bfd_link_info *) info_p;
+
+      info->flags |= DF_TEXTREL;
+      info->callbacks->minfo (_ ("%pB: dynamic relocation against `%pT' in "
+                                 "read-only section `%pA'\n"),
+                              sec->owner, h->root.root.string, sec);
+
+      /* Not an error, just cut short the traversal.  */
+      return false;
+    }
+  return true;
+}
+
+static bool
+loongarch_elf_size_dynamic_sections (bfd *output_bfd,
+                                     struct bfd_link_info *info)
+{
+  struct loongarch_elf_link_hash_table *htab;
+  bfd *dynobj;
+  asection *s;
+  bfd *ibfd;
+
+  htab = loongarch_elf_hash_table (info);
+  BFD_ASSERT (htab != NULL);
+  dynobj = htab->elf.dynobj;
+  BFD_ASSERT (dynobj != NULL);
+
+  if (htab->elf.dynamic_sections_created)
+    {
+      /* Set the contents of the .interp section to the interpreter.  */
+      if (bfd_link_executable (info) && !info->nointerp)
+        {
+          const char *interpreter;
+          flagword flags = elf_elfheader (output_bfd)->e_flags;
+          s = bfd_get_linker_section (dynobj, ".interp");
+          BFD_ASSERT (s != NULL);
+          if ((flags & EF_LARCH_ABI) == EF_LARCH_ABI_LP32)
+            interpreter = "/lib32/ld.so.1";
+          else if ((flags & EF_LARCH_ABI) == EF_LARCH_ABI_LP64)
+            interpreter = "/lib64/ld.so.1";
+          else
+            interpreter = "/lib/ld.so.1";
+          s->contents = (unsigned char *) interpreter;
+          s->size = strlen (interpreter) + 1;
+        }
+    }
+
+  /* Set up .got offsets for local syms, and space for local dynamic
+     relocs.  */
+  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link.next)
+    {
+      bfd_signed_vma *local_got;
+      bfd_signed_vma *end_local_got;
+      char *local_tls_type;
+      bfd_size_type locsymcount;
+      Elf_Internal_Shdr *symtab_hdr;
+      asection *srel;
+
+      if (!is_loongarch_elf (ibfd))
+        continue;
+
+      for (s = ibfd->sections; s != NULL; s = s->next)
+        {
+          struct elf_dyn_relocs *p;
+
+          for (p = elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
+            {
+              p->count -= p->pc_count;
+              if (!bfd_is_abs_section (p->sec) &&
+                  bfd_is_abs_section (p->sec->output_section))
+                {
+                  /* Input section has been discarded, either because
+		     it is a copy of a linkonce section or due to
+		     linker script /DISCARD/, so we'll be discarding
+		     the relocs too.  */
+                }
+              else if (0 < p->count)
+                {
+                  srel = elf_section_data (p->sec)->sreloc;
+                  srel->size += p->count * sizeof (ElfNN_External_Rela);
+                  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
+                    info->flags |= DF_TEXTREL;
+                }
+            }
+        }
+
+      local_got = elf_local_got_refcounts (ibfd);
+      if (!local_got)
+        continue;
+
+      symtab_hdr = &elf_symtab_hdr (ibfd);
+      locsymcount = symtab_hdr->sh_info;
+      end_local_got = local_got + locsymcount;
+      local_tls_type = _bfd_loongarch_elf_local_got_tls_type (ibfd);
+      s = htab->elf.sgot;
+      srel = htab->elf.srelgot;
+      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
+        {
+          if (0 < *local_got)
+            {
+              *local_got = s->size;
+              s->size += GOT_ENTRY_SIZE;
+
+              if (*local_tls_type & GOT_TLS_GD)
+                s->size += GOT_ENTRY_SIZE;
+
+              if (bfd_link_pic (info) /* R_LARCH_RELATIVE */
+                  ||
+                  (*local_tls_type & (GOT_TLS_GD /* R_LARCH_TLS_DTPRELNN */
+                                      | GOT_TLS_IE /* R_LARCH_TLS_TPRELNN */)))
+                srel->size += sizeof (ElfNN_External_Rela);
+            }
+          else
+            *local_got = MINUS_ONE;
+        }
+    }
+
+  /* Allocate global sym .plt and .got entries, and space for global
+     sym dynamic relocs.  */
+  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);
+  /* Allocate .plt and .got entries, and space for local ifunc symbols.  */
+  htab_traverse (htab->loc_hash_table,
+                 (void *) elfNN_loongarch_allocate_local_dynrelocs, info);
+
+  /* Don't allocate .got.plt section if there are no PLT.  */
+  if (htab->elf.sgotplt && htab->elf.sgotplt->size == GOTPLT_HEADER_SIZE &&
+      (htab->elf.splt == NULL || htab->elf.splt->size == 0))
+    htab->elf.sgotplt->size = 0;
+
+  /* The check_relocs and adjust_dynamic_symbol entry points have
+     determined the sizes of the various dynamic sections.  Allocate
+     memory for them.  */
+  for (s = dynobj->sections; s != NULL; s = s->next)
+    {
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+        continue;
+
+      if (s == htab->elf.splt || s == htab->elf.iplt || s == htab->elf.sgot ||
+          s == htab->elf.sgotplt || s == htab->elf.igotplt ||
+          s == htab->elf.sdynbss || s == htab->elf.sdynrelro)
+        {
+          /* Strip this section if we don't need it; see the
+	     comment below.  */
+        }
+      else if (strncmp (s->name, ".rela", 5) == 0)
+        {
+          if (s->size != 0)
+            {
+              /* We use the reloc_count field as a counter if we need
+		 to copy relocs into the output file.  */
+              s->reloc_count = 0;
+            }
+        }
+      else
+        {
+          /* It's not one of our sections.  */
+          continue;
+        }
+
+      if (s->size == 0)
+        {
+          /* If we don't need this section, strip it from the
+	     output file.  This is mostly to handle .rela.bss and
+	     .rela.plt.  We must create both sections in
+	     create_dynamic_sections, because they must be created
+	     before the linker maps input sections to output
+	     sections.  The linker does that before
+	     adjust_dynamic_symbol is called, and it is that
+	     function which decides whether anything needs to go
+	     into these sections.  */
+          s->flags |= SEC_EXCLUDE;
+          continue;
+        }
+
+      if ((s->flags & SEC_HAS_CONTENTS) == 0)
+        continue;
+
+      /* Allocate memory for the section contents.  Zero the memory
+	 for the benefit of .rela.plt, which has 4 unused entries
+	 at the beginning, and we don't want garbage.  */
+      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
+      if (s->contents == NULL)
+        return false;
+    }
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+	 values later, in loongarch_elf_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
+#define add_dynamic_entry(TAG, VAL) _bfd_elf_add_dynamic_entry (info, TAG, VAL)
+
+      if (bfd_link_executable (info))
+        {
+          if (!add_dynamic_entry (DT_DEBUG, 0))
+            return false;
+        }
+
+      if (htab->elf.srelplt->size != 0)
+        {
+          if (!add_dynamic_entry (DT_PLTGOT, 0) ||
+              !add_dynamic_entry (DT_PLTRELSZ, 0) ||
+              !add_dynamic_entry (DT_PLTREL, DT_RELA) ||
+              !add_dynamic_entry (DT_JMPREL, 0))
+            return false;
+        }
+
+      if (!add_dynamic_entry (DT_RELA, 0) ||
+          !add_dynamic_entry (DT_RELASZ, 0) ||
+          !add_dynamic_entry (DT_RELAENT, sizeof (ElfNN_External_Rela)))
+        return false;
+
+      /* If any dynamic relocs apply to a read-only section,
+	 then we need a DT_TEXTREL entry.  */
+      if ((info->flags & DF_TEXTREL) == 0)
+        elf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);
+
+      if (info->flags & DF_TEXTREL)
+        {
+          if (!add_dynamic_entry (DT_TEXTREL, 0))
+            return false;
+          /* Clear the DF_TEXTREL flag.  It will be set again if we
+             write out an actual text relocation; we may not, because
+             at this point we do not know whether e.g. any .eh_frame
+             absolute relocations have been converted to PC-relative.  */
+          info->flags &= ~DF_TEXTREL;
+        }
+    }
+#undef add_dynamic_entry
+
+  return true;
+}
+
+#define LARCH_LD_STACK_DEPTH 16
+static int64_t larch_opc_stack[LARCH_LD_STACK_DEPTH];
+static size_t larch_stack_top = 0;
+
+static bfd_reloc_status_type
+loongarch_push (int64_t val)
+{
+  if (LARCH_LD_STACK_DEPTH <= larch_stack_top)
+    return bfd_reloc_outofrange;
+  larch_opc_stack[larch_stack_top++] = val;
+  return bfd_reloc_ok;
+}
+
+static bfd_reloc_status_type
+loongarch_pop (int64_t *val)
+{
+  if (larch_stack_top == 0)
+    return bfd_reloc_outofrange;
+  BFD_ASSERT (val);
+  *val = larch_opc_stack[--larch_stack_top];
+  return bfd_reloc_ok;
+}
+
+static bfd_reloc_status_type
+loongarch_top (int64_t *val)
+{
+  if (larch_stack_top == 0)
+    return bfd_reloc_outofrange;
+  BFD_ASSERT (val);
+  *val = larch_opc_stack[larch_stack_top - 1];
+  return bfd_reloc_ok;
+}
+
+static void
+loongarch_elf_append_rela (bfd *abfd, asection *s, Elf_Internal_Rela *rel)
+{
+  const struct elf_backend_data *bed;
+  bfd_byte *loc;
+
+  bed = get_elf_backend_data (abfd);
+  loc = s->contents + (s->reloc_count++ * bed->s->sizeof_rela);
+  bed->s->swap_reloca_out (abfd, rel, loc);
+}
+
+/* Emplace a static relocation.  */
+
+static bfd_reloc_status_type
+perform_relocation (const Elf_Internal_Rela *rel, bfd_vma value,
+                    bfd *input_bfd, bfd_byte *contents)
+{
+
+  uint32_t insn1;
+  int64_t opr1, opr2, opr3;
+  bfd_reloc_status_type r = bfd_reloc_ok;
+  switch (ELFNN_R_TYPE (rel->r_info))
+    {
+    case R_LARCH_SOP_PUSH_PCREL:
+    case R_LARCH_SOP_PUSH_ABSOLUTE:
+    case R_LARCH_SOP_PUSH_GPREL:
+    case R_LARCH_SOP_PUSH_TLS_TPREL:
+    case R_LARCH_SOP_PUSH_TLS_GOT:
+    case R_LARCH_SOP_PUSH_TLS_GD:
+    case R_LARCH_SOP_PUSH_PLT_PCREL:
+      r = loongarch_push (value);
+      break;
+
+    case R_LARCH_SOP_PUSH_DUP:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr1) != bfd_reloc_ok ||
+          loongarch_push (opr1) != bfd_reloc_ok ||
+          loongarch_push (opr1) != bfd_reloc_ok)
+        break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_ASSERT:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok && opr1 == false)
+        r = bfd_reloc_notsupported;
+      break;
+
+    case R_LARCH_SOP_NOT:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr1) != bfd_reloc_ok ||
+          loongarch_push (!opr1) != bfd_reloc_ok)
+        break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_SUB:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok ||
+          loongarch_pop (&opr1) != bfd_reloc_ok ||
+          loongarch_push (opr1 - opr2) != bfd_reloc_ok)
+        break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_SL:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok ||
+          loongarch_pop (&opr1) != bfd_reloc_ok ||
+          loongarch_push (opr1 << opr2) != bfd_reloc_ok)
+        break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_SR:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok ||
+          loongarch_pop (&opr1) != bfd_reloc_ok ||
+          loongarch_push (opr1 >> opr2) != bfd_reloc_ok)
+        break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_AND:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok ||
+          loongarch_pop (&opr1) != bfd_reloc_ok ||
+          loongarch_push (opr1 & opr2) != bfd_reloc_ok)
+        break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_ADD:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok ||
+          loongarch_pop (&opr1) != bfd_reloc_ok ||
+          loongarch_push (opr1 + opr2) != bfd_reloc_ok)
+        break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_IF_ELSE:
+      r = bfd_reloc_outofrange;
+      if (loongarch_pop (&opr3) != bfd_reloc_ok ||
+          loongarch_pop (&opr2) != bfd_reloc_ok ||
+          loongarch_pop (&opr1) != bfd_reloc_ok ||
+          loongarch_push (opr1 ? opr2 : opr3) != bfd_reloc_ok)
+        break;
+      r = bfd_reloc_ok;
+      break;
+
+    case R_LARCH_SOP_POP_32_S_10_5:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+        break;
+      if ((opr1 & ~(uint64_t) 0xf) != 0x0 &&
+          (opr1 & ~(uint64_t) 0xf) != ~(uint64_t) 0xf)
+        r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+        break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & (~(uint32_t) 0x7c00)) | ((opr1 & 0x1f) << 10);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_U_10_12:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+        break;
+      if (opr1 & ~(uint64_t) 0xfff)
+        r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+        break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & (~(uint32_t) 0x3ffc00)) | ((opr1 & 0xfff) << 10);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_S_10_12:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+        break;
+      if ((opr1 & ~(uint64_t) 0x7ff) != 0x0 &&
+          (opr1 & ~(uint64_t) 0x7ff) != ~(uint64_t) 0x7ff)
+        r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+        break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & (~(uint32_t) 0x3ffc00)) | ((opr1 & 0xfff) << 10);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_S_10_16:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+        break;
+      if ((opr1 & ~(uint64_t) 0x7fff) != 0x0 &&
+          (opr1 & ~(uint64_t) 0x7fff) != ~(uint64_t) 0x7fff)
+        r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+        break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & 0xfc0003ff) | ((opr1 & 0xffff) << 10);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_S_10_16_S2:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+        break;
+      if ((opr1 & 0x3) != 0)
+        r = bfd_reloc_overflow;
+      opr1 >>= 2;
+      if ((opr1 & ~(uint64_t) 0x7fff) != 0x0 &&
+          (opr1 & ~(uint64_t) 0x7fff) != ~(uint64_t) 0x7fff)
+        r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+        break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & 0xfc0003ff) | ((opr1 & 0xffff) << 10);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_S_0_5_10_16_S2:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+        break;
+      if ((opr1 & 0x3) != 0)
+        r = bfd_reloc_overflow;
+      opr1 >>= 2;
+      if ((opr1 & ~(uint64_t) 0xfffff) != 0x0 &&
+          (opr1 & ~(uint64_t) 0xfffff) != ~(uint64_t) 0xfffff)
+        r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+        break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & 0xfc0003e0) | ((opr1 & 0xffff) << 10) |
+              ((opr1 & 0x1f0000) >> 16);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_S_5_20:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+        break;
+      if ((opr1 & ~(uint64_t) 0x7ffff) != 0x0 &&
+          (opr1 & ~(uint64_t) 0x7ffff) != ~(uint64_t) 0x7ffff)
+        r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+        break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & (~(uint32_t) 0x1ffffe0)) | ((opr1 & 0xfffff) << 5);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_S_0_10_10_16_S2:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+        break;
+      if ((opr1 & 0x3) != 0)
+        r = bfd_reloc_overflow;
+      opr1 >>= 2;
+      if ((opr1 & ~(uint64_t) 0x1ffffff) != 0x0 &&
+          (opr1 & ~(uint64_t) 0x1ffffff) != ~(uint64_t) 0x1ffffff)
+        r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+        break;
+      insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      insn1 = (insn1 & 0xfc000000) | ((opr1 & 0xffff) << 10) |
+              ((opr1 & 0x3ff0000) >> 16);
+      bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_SOP_POP_32_U:
+      r = loongarch_pop (&opr1);
+      if (r != bfd_reloc_ok)
+        break;
+      if (opr1 & ~(uint64_t) 0xffffffff)
+        r = bfd_reloc_overflow;
+      if (r != bfd_reloc_ok)
+        break;
+      bfd_put (32, input_bfd, opr1, contents + rel->r_offset);
+      break;
+
+    case R_LARCH_TLS_DTPREL32:
+    case R_LARCH_32:
+      bfd_put (32, input_bfd, value, contents + rel->r_offset);
+      break;
+    case R_LARCH_TLS_DTPREL64:
+    case R_LARCH_64:
+      bfd_put (64, input_bfd, value, contents + rel->r_offset);
+      break;
+    case R_LARCH_ADD8:
+      opr1 = bfd_get (8, input_bfd, contents + rel->r_offset);
+      bfd_put (8, input_bfd, opr1 + value, contents + rel->r_offset);
+      break;
+    case R_LARCH_ADD16:
+      opr1 = bfd_get (16, input_bfd, contents + rel->r_offset);
+      bfd_put (16, input_bfd, opr1 + value, contents + rel->r_offset);
+      break;
+    case R_LARCH_ADD24:
+      opr1 = bfd_get (24, input_bfd, contents + rel->r_offset);
+      bfd_put (24, input_bfd, opr1 + value, contents + rel->r_offset);
+      break;
+    case R_LARCH_ADD32:
+      opr1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      bfd_put (32, input_bfd, opr1 + value, contents + rel->r_offset);
+      break;
+    case R_LARCH_ADD64:
+      opr1 = bfd_get (64, input_bfd, contents + rel->r_offset);
+      bfd_put (64, input_bfd, opr1 + value, contents + rel->r_offset);
+      break;
+    case R_LARCH_SUB8:
+      opr1 = bfd_get (8, input_bfd, contents + rel->r_offset);
+      bfd_put (8, input_bfd, opr1 - value, contents + rel->r_offset);
+      break;
+    case R_LARCH_SUB16:
+      opr1 = bfd_get (16, input_bfd, contents + rel->r_offset);
+      bfd_put (16, input_bfd, opr1 - value, contents + rel->r_offset);
+      break;
+    case R_LARCH_SUB24:
+      opr1 = bfd_get (24, input_bfd, contents + rel->r_offset);
+      bfd_put (24, input_bfd, opr1 - value, contents + rel->r_offset);
+      break;
+    case R_LARCH_SUB32:
+      opr1 = bfd_get (32, input_bfd, contents + rel->r_offset);
+      bfd_put (32, input_bfd, opr1 - value, contents + rel->r_offset);
+      break;
+    case R_LARCH_SUB64:
+      opr1 = bfd_get (64, input_bfd, contents + rel->r_offset);
+      bfd_put (64, input_bfd, opr1 - value, contents + rel->r_offset);
+      break;
+
+    default:
+      r = bfd_reloc_notsupported;
+    }
+  return r;
+}
+
+#define LARCH_RECENT_RELOC_QUEUE_LENGTH 72
+static struct
+{
+  bfd *bfd;
+  asection *section;
+  bfd_vma r_offset;
+  int r_type;
+  bfd_vma relocation;
+  Elf_Internal_Sym *sym;
+  struct elf_link_hash_entry *h;
+  bfd_vma addend;
+  int64_t top_then;
+} larch_reloc_queue[LARCH_RECENT_RELOC_QUEUE_LENGTH];
+static size_t larch_reloc_queue_head = 0;
+static size_t larch_reloc_queue_tail = 0;
+
+static const char *
+loongarch_sym_name (bfd *input_bfd, struct elf_link_hash_entry *h,
+                    Elf_Internal_Sym *sym)
+{
+  const char *ret = NULL;
+  if (sym)
+    ret = bfd_elf_string_from_elf_section (
+      input_bfd, elf_symtab_hdr (input_bfd).sh_link, sym->st_name);
+  else if (h)
+    ret = h->root.root.string;
+
+  if (ret == NULL || *ret == '\0')
+    ret = "<nameless>";
+  return ret;
+}
+
+static void
+loongarch_record_one_reloc (bfd *abfd, asection *section, int r_type,
+                            bfd_vma r_offset, Elf_Internal_Sym *sym,
+                            struct elf_link_hash_entry *h, bfd_vma addend)
+{
+  if ((larch_reloc_queue_head == 0 &&
+       larch_reloc_queue_tail == LARCH_RECENT_RELOC_QUEUE_LENGTH - 1) ||
+      (larch_reloc_queue_head == larch_reloc_queue_tail + 1))
+    larch_reloc_queue_head =
+      (larch_reloc_queue_head + 1) % LARCH_RECENT_RELOC_QUEUE_LENGTH;
+  larch_reloc_queue[larch_reloc_queue_tail].bfd = abfd;
+  larch_reloc_queue[larch_reloc_queue_tail].section = section;
+  larch_reloc_queue[larch_reloc_queue_tail].r_offset = r_offset;
+  larch_reloc_queue[larch_reloc_queue_tail].r_type = r_type;
+  larch_reloc_queue[larch_reloc_queue_tail].sym = sym;
+  larch_reloc_queue[larch_reloc_queue_tail].h = h;
+  larch_reloc_queue[larch_reloc_queue_tail].addend = addend;
+  loongarch_top (&larch_reloc_queue[larch_reloc_queue_tail].top_then);
+  larch_reloc_queue_tail =
+    (larch_reloc_queue_tail + 1) % LARCH_RECENT_RELOC_QUEUE_LENGTH;
+}
+
+static void
+loongarch_dump_reloc_record (void (*p) (const char *fmt, ...))
+{
+  size_t i = larch_reloc_queue_head;
+  bfd *a_bfd = NULL;
+  asection *section = NULL;
+  bfd_vma r_offset = 0;
+  int inited = 0;
+  p ("Dump relocate record:\n");
+  p ("stack top\t\trelocation name\t\tsymbol");
+  while (i != larch_reloc_queue_tail)
+    {
+      if (a_bfd != larch_reloc_queue[i].bfd ||
+          section != larch_reloc_queue[i].section ||
+          r_offset != larch_reloc_queue[i].r_offset)
+        {
+          a_bfd = larch_reloc_queue[i].bfd;
+          section = larch_reloc_queue[i].section;
+          r_offset = larch_reloc_queue[i].r_offset;
+          p ("\nat %pB(%pA+0x%v):\n", larch_reloc_queue[i].bfd,
+             larch_reloc_queue[i].section, larch_reloc_queue[i].r_offset);
+        }
+
+      if (!inited)
+        inited = 1, p ("...\n");
+
+      reloc_howto_type *howto =
+        loongarch_elf_rtype_to_howto (larch_reloc_queue[i].r_type);
+      p ("0x%V %s\t`%s'", (bfd_vma) larch_reloc_queue[i].top_then,
+         howto ? howto->name : "<unknown reloc>",
+         loongarch_sym_name (larch_reloc_queue[i].bfd, larch_reloc_queue[i].h,
+                             larch_reloc_queue[i].sym));
+
+      long addend = larch_reloc_queue[i].addend;
+      if (addend < 0)
+        p (" - %ld", -addend);
+      else if (0 < addend)
+        p (" + %ld(0x%v)", addend, larch_reloc_queue[i].addend);
+
+      p ("\n");
+      i = (i + 1) % LARCH_RECENT_RELOC_QUEUE_LENGTH;
+    }
+  p ("\n"
+     "-- Record dump end --\n\n");
+}
+
+static int
+loongarch_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
+                                bfd *input_bfd, asection *input_section,
+                                bfd_byte *contents, Elf_Internal_Rela *relocs,
+                                Elf_Internal_Sym *local_syms,
+                                asection **local_sections)
+{
+  Elf_Internal_Rela *rel;
+  Elf_Internal_Rela *relend;
+  bool fatal = false;
+  asection *sreloc = elf_section_data (input_section)->sreloc;
+  struct loongarch_elf_link_hash_table *htab = loongarch_elf_hash_table (info);
+  Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (input_bfd);
+  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);
+  bfd_vma *local_got_offsets = elf_local_got_offsets (input_bfd);
+  bool is_pic = bfd_link_pic (info);
+  bool is_dyn = elf_hash_table (info)->dynamic_sections_created;
+  asection *plt = htab->elf.splt ? htab->elf.splt : htab->elf.iplt;
+  asection *got = htab->elf.sgot;
+
+  relend = relocs + input_section->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    {
+      int r_type = ELFNN_R_TYPE (rel->r_info);
+      unsigned long r_symndx = ELFNN_R_SYM (rel->r_info);
+      bfd_vma pc = sec_addr (input_section) + rel->r_offset;
+      reloc_howto_type *howto = loongarch_elf_rtype_to_howto (r_type);
+      asection *sec = NULL;
+      Elf_Internal_Sym *sym = NULL;
+      struct elf_link_hash_entry *h = NULL;
+      const char *name;
+      bfd_reloc_status_type r = bfd_reloc_ok;
+      bool is_ie, is_undefweak, unresolved_reloc, defined_local;
+      bool resolved_local, resolved_dynly, resolved_to_const;
+      char tls_type;
+      bfd_vma relocation;
+      bfd_vma off, ie_off;
+      int i, j;
+
+      if (howto == NULL || r_type == R_LARCH_GNU_VTINHERIT ||
+          r_type == R_LARCH_GNU_VTENTRY)
+        continue;
+
+      /* This is a final link.  */
+      if (r_symndx < symtab_hdr->sh_info)
+        {
+          is_undefweak = false;
+          unresolved_reloc = false;
+          sym = local_syms + r_symndx;
+          sec = local_sections[r_symndx];
+          relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
+
+          /* Relocate against local STT_GNU_IFUNC symbol.  */
+          if (!bfd_link_relocatable (info) &&
+              ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
+            {
+              h = elfNN_loongarch_get_local_sym_hash (htab, input_bfd, rel,
+                                                      false);
+              if (h == NULL)
+                abort ();
+
+              /* Set STT_GNU_IFUNC symbol value.  */
+              h->root.u.def.value = sym->st_value;
+              h->root.u.def.section = sec;
+            }
+          defined_local = true;
+          resolved_local = true;
+          resolved_dynly = false;
+          resolved_to_const = false;
+          if (bfd_link_relocatable (info) &&
+              ELF_ST_TYPE (sym->st_info) == STT_SECTION)
+            {
+              rel->r_addend += sec->output_offset;
+            }
+        }
+      else
+        {
+          bool warned, ignored;
+
+          RELOC_FOR_GLOBAL_SYMBOL (
+            info, input_bfd, input_section, rel, r_symndx, symtab_hdr,
+            sym_hashes, h, sec, relocation, unresolved_reloc, warned, ignored);
+          /* here means symbol isn't local symbol only and 'h != NULL' */
+
+          /* 'unresolved_syms_in_objects' specify how to deal with undefined
+	     symbol. And 'dynamic_undefined_weak' specify what to do when
+	     meeting undefweak.  */
+
+          if ((is_undefweak = h->root.type == bfd_link_hash_undefweak))
+            {
+              defined_local = false;
+              resolved_local = false;
+              resolved_to_const = !is_dyn || h->dynindx == -1 ||
+                                  UNDEFWEAK_NO_DYNAMIC_RELOC (info, h);
+              resolved_dynly = !resolved_local && !resolved_to_const;
+            }
+          else if (warned)
+            {
+              /* Symbol undefined offen means failed already. I don't know why
+		 'warned' here but I guess it want to continue relocating as if
+		 no error occures to find other errors as more as possible. */
+
+              /* To avoid generating warning messages about truncated
+		 relocations, set the relocation's address to be the same as
+		 the start of this section.  */
+              relocation = input_section->output_section
+                             ? input_section->output_section->vma
+                             : 0;
+
+              defined_local = relocation != 0;
+              resolved_local = defined_local;
+              resolved_to_const = !resolved_local;
+              resolved_dynly = false;
+            }
+          else
+            {
+              defined_local = !unresolved_reloc && !ignored;
+              resolved_local =
+                defined_local && SYMBOL_REFERENCES_LOCAL (info, h);
+              resolved_dynly = !resolved_local;
+              resolved_to_const = !resolved_local && !resolved_dynly;
+            }
+        }
+
+      name = loongarch_sym_name (input_bfd, h, sym);
+
+      if (sec != NULL && discarded_section (sec))
+        RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section, rel,
+                                         1, relend, howto, 0, contents);
+
+      if (bfd_link_relocatable (info))
+        continue;
+
+      /* r_symndx will be STN_UNDEF (zero) only for relocs against symbols
+	 from removed linkonce sections, or sections discarded by a linker
+	 script. Also for R_*_SOP_PUSH_ABSOLUTE and PCREL to specify const.  */
+      if (r_symndx == STN_UNDEF || bfd_is_abs_section (sec))
+        resolved_dynly = resolved_local = defined_local = false,
+        resolved_to_const = true;
+
+      if (h && h->type == STT_GNU_IFUNC)
+        {
+          if (h->plt.offset == MINUS_ONE)
+            info->callbacks->info ("%X%pB(%pA+0x%v): error: %s against `%s':\n"
+                                   "STT_GNU_IFUNC must have PLT stub"
+                                   "\n",
+                                   input_bfd, input_section,
+                                   (bfd_vma) rel->r_offset, howto->name, name);
+          defined_local = true;
+          resolved_local = true;
+          resolved_dynly = false;
+          resolved_to_const = false;
+          relocation = sec_addr (plt) + h->plt.offset;
+        }
+
+      unresolved_reloc = resolved_dynly;
+
+      BFD_ASSERT (resolved_local + resolved_dynly + resolved_to_const == 1);
+
+      BFD_ASSERT (!resolved_dynly || (h && h->dynindx != -1));
+
+      BFD_ASSERT (!resolved_local || defined_local);
+
+      is_ie = false;
+      switch (r_type)
+        {
+#define LARCH_ASSERT(cond, bfd_fail_state, message)                           \
+  ({                                                                          \
+    if (!(cond))                                                              \
+      {                                                                       \
+        r = bfd_fail_state;                                                   \
+        switch (r)                                                            \
+          {                                                                   \
+          /* 'dangerous' means we do it but can't promise it's ok		\
+       'unsupport' means out of ability of relocation type		\
+       'undefined' means we can't deal with the undefined symbol  */          \
+          case bfd_reloc_undefined:                                           \
+            info->callbacks->undefined_symbol (                               \
+              info, name, input_bfd, input_section, rel->r_offset, true);     \
+            fatal = true;                                                     \
+            info->callbacks->info (                                           \
+              "%X%pB(%pA+0x%v): error: %s against %s`%s':\n" message "\n",    \
+              input_bfd, input_section, (bfd_vma) rel->r_offset, howto->name, \
+              is_undefweak ? "[undefweak] " : "", name);                      \
+            break;                                                            \
+          default:                                                            \
+            fatal = true;                                                     \
+            info->callbacks->info (                                           \
+              "%X%pB(%pA+0x%v): error: %s against %s`%s':\n" message "\n",    \
+              input_bfd, input_section, (bfd_vma) rel->r_offset, howto->name, \
+              is_undefweak ? "[undefweak] " : "", name);                      \
+            break;                                                            \
+          case bfd_reloc_dangerous:                                           \
+            info->callbacks->info (                                           \
+              "%pB(%pA+0x%v): warning: %s against %s`%s':\n" message "\n",    \
+              input_bfd, input_section, (bfd_vma) rel->r_offset, howto->name, \
+              is_undefweak ? "[undefweak] " : "", name);                      \
+            break;                                                            \
+          case bfd_reloc_ok:                                                  \
+          case bfd_reloc_continue:                                            \
+            info->callbacks->info (                                           \
+              "%pB(%pA+0x%v): message: %s against %s`%s':\n" message "\n",    \
+              input_bfd, input_section, (bfd_vma) rel->r_offset, howto->name, \
+              is_undefweak ? "[undefweak] " : "", name);                      \
+            break;                                                            \
+          }                                                                   \
+        if (fatal)                                                            \
+          break;                                                              \
+      }                                                                       \
+  })
+        case R_LARCH_MARK_PCREL:
+        case R_LARCH_MARK_LA:
+        case R_LARCH_NONE:
+          r = bfd_reloc_continue;
+          unresolved_reloc = false;
+          break;
+
+        case R_LARCH_32:
+        case R_LARCH_64:
+          if (resolved_dynly || (is_pic && resolved_local))
+            {
+              Elf_Internal_Rela outrel;
+
+              /* When generating a shared object, these relocations are copied
+		 into the output file to be resolved at run time.  */
+
+              outrel.r_offset = _bfd_elf_section_offset (
+                output_bfd, info, input_section, rel->r_offset);
+
+              unresolved_reloc = !((bfd_vma) -2 <= outrel.r_offset) &&
+                                 (input_section->flags & SEC_ALLOC);
+
+              outrel.r_offset += sec_addr (input_section);
+              if (resolved_dynly)
+                {
+                  outrel.r_info = ELFNN_R_INFO (h->dynindx, r_type);
+                  outrel.r_addend = rel->r_addend;
+                }
+              else
+                {
+                  outrel.r_info = ELFNN_R_INFO (0, R_LARCH_RELATIVE);
+                  outrel.r_addend = relocation + rel->r_addend;
+                }
+
+              if (unresolved_reloc)
+                loongarch_elf_append_rela (output_bfd, sreloc, &outrel);
+            }
+
+          relocation += rel->r_addend;
+          break;
+
+        case R_LARCH_ADD8:
+        case R_LARCH_ADD16:
+        case R_LARCH_ADD24:
+        case R_LARCH_ADD32:
+        case R_LARCH_ADD64:
+        case R_LARCH_SUB8:
+        case R_LARCH_SUB16:
+        case R_LARCH_SUB24:
+        case R_LARCH_SUB32:
+        case R_LARCH_SUB64:
+          LARCH_ASSERT (
+            !resolved_dynly, bfd_reloc_undefined,
+            "Can't be resolved dynamically. If this procedure is hand-writing "
+            "assemble,\n"
+            "there must be something like '.dword sym1 - sym2' to generate "
+            "these relocs\n"
+            "and we can't get known link-time address of these symbols.");
+          relocation += rel->r_addend;
+          break;
+
+        case R_LARCH_TLS_DTPREL32:
+        case R_LARCH_TLS_DTPREL64:
+          if (resolved_dynly)
+            {
+              Elf_Internal_Rela outrel;
+
+              outrel.r_offset = _bfd_elf_section_offset (
+                output_bfd, info, input_section, rel->r_offset);
+
+              unresolved_reloc = !((bfd_vma) -2 <= outrel.r_offset) &&
+                                 (input_section->flags & SEC_ALLOC);
+              outrel.r_info = ELFNN_R_INFO (h->dynindx, r_type);
+              outrel.r_offset += sec_addr (input_section);
+              outrel.r_addend = rel->r_addend;
+              if (unresolved_reloc)
+                loongarch_elf_append_rela (output_bfd, sreloc, &outrel);
+              break;
+            }
+
+          LARCH_ASSERT (!resolved_to_const, bfd_reloc_notsupported,
+                        "Internal:");
+          break;
+        case R_LARCH_SOP_PUSH_TLS_TPREL:
+          if (resolved_local)
+            {
+              LARCH_ASSERT (elf_hash_table (info)->tls_sec,
+                            bfd_reloc_notsupported,
+                            "TLS section not be created");
+              relocation -= elf_hash_table (info)->tls_sec->vma;
+            }
+
+          LARCH_ASSERT (resolved_local, bfd_reloc_undefined,
+                        "TLS LE just can be resolved local only.");
+          break;
+
+        case R_LARCH_SOP_PUSH_ABSOLUTE:
+          if (is_undefweak)
+            {
+              LARCH_ASSERT (
+                !resolved_dynly, bfd_reloc_dangerous,
+                "Someone require us to resolve undefweak symbol dynamically.\n"
+                "But this reloc can't be done. I think I can't throw error "
+                "for this\n"
+                "so I resolved it to 0. I suggest to re-compile with "
+                "'-fpic'.");
+              relocation = 0;
+              unresolved_reloc = false;
+              break;
+            }
+
+          if (resolved_to_const)
+            {
+              relocation += rel->r_addend;
+              break;
+            }
+
+          LARCH_ASSERT (!is_pic, bfd_reloc_notsupported,
+                        "Under PIC we don't know load address. Re-compile src "
+                        "with '-fpic'?");
+
+          if (resolved_dynly)
+            {
+              LARCH_ASSERT (plt && h && h->plt.offset != MINUS_ONE,
+                            bfd_reloc_undefined,
+                            "Can't be resolved dynamically. Try to re-compile "
+                            "src with '-fpic'?");
+
+              LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
+                            "Shouldn't be with r_addend.");
+
+              relocation = sec_addr (plt) + h->plt.offset;
+              unresolved_reloc = false;
+              break;
+            }
+
+          if (resolved_local)
+            {
+              relocation += rel->r_addend;
+              break;
+            }
+
+          break;
+
+        case R_LARCH_SOP_PUSH_PCREL:
+        case R_LARCH_SOP_PUSH_PLT_PCREL:
+          unresolved_reloc = false;
+
+          if (resolved_to_const)
+            {
+              relocation += rel->r_addend;
+              break;
+            }
+          else if (is_undefweak)
+            {
+              i = 0, j = 0;
+              relocation = 0;
+              if (resolved_dynly)
+                {
+                  if (h && h->plt.offset != MINUS_ONE)
+                    i = 1, j = 2;
+                  else
+                    LARCH_ASSERT (0, bfd_reloc_dangerous,
+                                  "Undefweak need to be resolved dynamically, "
+                                  "but PLT stub doesn't represent.");
+                }
+            }
+          else
+            {
+              LARCH_ASSERT (
+                defined_local || (h && h->plt.offset != MINUS_ONE),
+                bfd_reloc_undefined,
+                "PLT stub does not represent and symbol not defined.");
+
+              if (resolved_local)
+                i = 0, j = 2;
+              else /* if (resolved_dynly) */
+                {
+                  LARCH_ASSERT (h && h->plt.offset != MINUS_ONE,
+                                bfd_reloc_dangerous,
+                                "Internal: PLT stub doesn't represent. "
+                                "Resolve it with pcrel");
+                  i = 1, j = 3;
+                }
+            }
+
+          for (; i < j; i++)
+            {
+              if ((i & 1) == 0 && defined_local)
+                {
+                  relocation -= pc;
+                  relocation += rel->r_addend;
+                  break;
+                }
+
+              if ((i & 1) && h && h->plt.offset != MINUS_ONE)
+                {
+                  LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
+                                "PLT shouldn't be with r_addend.");
+                  relocation = sec_addr (plt) + h->plt.offset - pc;
+                  break;
+                }
+            }
+          break;
+
+        case R_LARCH_SOP_PUSH_GPREL:
+          unresolved_reloc = false;
+
+          LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
+                        "Shouldn't be with r_addend.");
+
+          if (h != NULL)
+            {
+              off = h->got.offset;
+
+              LARCH_ASSERT (off != MINUS_ONE, bfd_reloc_notsupported,
+                            "Internal: GOT entry doesn't represent.");
+
+              if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (is_dyn, is_pic, h) ||
+                  (is_pic && SYMBOL_REFERENCES_LOCAL (info, h)))
+                {
+                  /* This is actually a static link, or it is a
+		     -Bsymbolic link and the symbol is defined
+		     locally, or the symbol was forced to be local
+		     because of a version file.  We must initialize
+		     this entry in the global offset table.  Since the
+		     offset must always be a multiple of the word size,
+		     we use the least significant bit to record whether
+		     we have initialized it already.
+
+		     When doing a dynamic link, we create a .rela.got
+		     relocation entry to initialize the value.  This
+		     is done in the finish_dynamic_symbol routine.  */
+
+                  LARCH_ASSERT (!resolved_dynly, bfd_reloc_dangerous,
+                                "Internal: here shouldn't dynamic.");
+                  LARCH_ASSERT (defined_local || resolved_to_const,
+                                bfd_reloc_undefined, "Internal: ");
+
+                  if ((off & 1) != 0)
+                    off &= ~1;
+                  else
+                    {
+                      bfd_put_NN (output_bfd, relocation, got->contents + off);
+                      h->got.offset |= 1;
+                    }
+                }
+            }
+          else
+            {
+              LARCH_ASSERT (local_got_offsets, bfd_reloc_notsupported,
+                            "Internal: local got offsets not reporesent.");
+
+              off = local_got_offsets[r_symndx];
+
+              LARCH_ASSERT (off != MINUS_ONE, bfd_reloc_notsupported,
+                            "Internal: GOT entry doesn't represent.");
+
+              /* The offset must always be a multiple of the word size.
+		 So, we can use the least significant bit to record
+		 whether we have already processed this entry.  */
+              if ((off & 1) != 0)
+                off &= ~1;
+              else
+                {
+                  if (is_pic)
+                    {
+                      asection *s;
+                      Elf_Internal_Rela outrel;
+                      /* We need to generate a R_LARCH_RELATIVE reloc
+			 for the dynamic linker.  */
+                      s = htab->elf.srelgot;
+                      LARCH_ASSERT (s, bfd_reloc_notsupported,
+                                    "Internal: '.rel.got' not represent");
+
+                      outrel.r_offset = sec_addr (got) + off;
+                      outrel.r_info = ELFNN_R_INFO (0, R_LARCH_RELATIVE);
+                      outrel.r_addend = relocation; /* link-time addr */
+                      loongarch_elf_append_rela (output_bfd, s, &outrel);
+                    }
+
+                  bfd_put_NN (output_bfd, relocation, got->contents + off);
+                  local_got_offsets[r_symndx] |= 1;
+                }
+            }
+          relocation = off;
+          break;
+
+        case R_LARCH_SOP_PUSH_TLS_GOT:
+        case R_LARCH_SOP_PUSH_TLS_GD:
+          if (r_type == R_LARCH_SOP_PUSH_TLS_GOT)
+            is_ie = true;
+          unresolved_reloc = false;
+
+          LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
+                        "Shouldn't be with r_addend.");
+
+          if (resolved_to_const && is_undefweak && h->dynindx != -1)
+            {
+              /* What if undefweak? Let rtld make a decision. */
+              resolved_to_const = resolved_local = false;
+              resolved_dynly = true;
+            }
+
+          LARCH_ASSERT (!resolved_to_const, bfd_reloc_notsupported,
+                        "Internal: Shouldn't be resolved to const.");
+
+          if (h != NULL)
+            {
+              off = h->got.offset;
+              h->got.offset |= 1;
+            }
+          else
+            {
+              off = local_got_offsets[r_symndx];
+              local_got_offsets[r_symndx] |= 1;
+            }
+
+          LARCH_ASSERT (off != MINUS_ONE, bfd_reloc_notsupported,
+                        "Internal: TLS GOT entry doesn't represent.");
+
+          tls_type = _bfd_loongarch_elf_tls_type (input_bfd, h, r_symndx);
+
+          /* If this symbol is referenced by both GD and IE TLS, the IE
+	     reference's GOT slot follows the GD reference's slots.  */
+          ie_off = 0;
+          if ((tls_type & GOT_TLS_GD) && (tls_type & GOT_TLS_IE))
+            ie_off = 2 * GOT_ENTRY_SIZE;
+
+          if ((off & 1) != 0)
+            off &= ~1;
+          else
+            {
+              bfd_vma tls_block_off = 0;
+              Elf_Internal_Rela outrel;
+
+              if (resolved_local)
+                {
+                  LARCH_ASSERT (elf_hash_table (info)->tls_sec,
+                                bfd_reloc_notsupported,
+                                "Internal: TLS sec not represent.");
+                  tls_block_off =
+                    relocation - elf_hash_table (info)->tls_sec->vma;
+                }
+
+              if (tls_type & GOT_TLS_GD)
+                {
+                  outrel.r_offset = sec_addr (got) + off;
+                  outrel.r_addend = 0;
+                  bfd_put_NN (output_bfd, 0, got->contents + off);
+                  if (resolved_local && bfd_link_executable (info))
+                    bfd_put_NN (output_bfd, 1, got->contents + off);
+                  else if (resolved_local /* && !bfd_link_executable (info) */)
+                    {
+                      outrel.r_info = ELFNN_R_INFO (0, R_LARCH_TLS_DTPMODNN);
+                      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
+                                                 &outrel);
+                    }
+                  else /* if (resolved_dynly) */
+                    {
+                      outrel.r_info =
+                        ELFNN_R_INFO (h->dynindx, R_LARCH_TLS_DTPMODNN);
+                      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
+                                                 &outrel);
+                    }
+
+                  outrel.r_offset += GOT_ENTRY_SIZE;
+                  bfd_put_NN (output_bfd, tls_block_off,
+                              got->contents + off + GOT_ENTRY_SIZE);
+                  if (resolved_local)
+                    /* DTPREL known */;
+                  else /* if (resolved_dynly) */
+                    {
+                      outrel.r_info =
+                        ELFNN_R_INFO (h->dynindx, R_LARCH_TLS_DTPRELNN);
+                      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
+                                                 &outrel);
+                    }
+                }
+
+              if (tls_type & GOT_TLS_IE)
+                {
+                  outrel.r_offset = sec_addr (got) + off + ie_off;
+                  bfd_put_NN (output_bfd, tls_block_off,
+                              got->contents + off + ie_off);
+                  if (resolved_local && bfd_link_executable (info))
+                    /* TPREL known */;
+                  else if (resolved_local /* && !bfd_link_executable (info) */)
+                    {
+                      outrel.r_info = ELFNN_R_INFO (0, R_LARCH_TLS_TPRELNN);
+                      outrel.r_addend = tls_block_off;
+                      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
+                                                 &outrel);
+                    }
+                  else /* if (resolved_dynly) */
+                    {
+                      outrel.r_info =
+                        ELFNN_R_INFO (h->dynindx, R_LARCH_TLS_TPRELNN);
+                      outrel.r_addend = 0;
+                      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
+                                                 &outrel);
+                    }
+                }
+            }
+
+          relocation = off + (is_ie ? ie_off : 0);
+          break;
+
+        default:
+          break;
+        }
+
+      if (fatal)
+        break;
+
+      do
+        {
+          /* 'unresolved_reloc' means we haven't done it yet.
+	     We need help of dynamic linker to fix this memory location up. */
+          if (!unresolved_reloc)
+            break;
+
+          if (_bfd_elf_section_offset (output_bfd, info, input_section,
+                                       rel->r_offset) == MINUS_ONE)
+            /* WHY? May because it's invalid so skip checking.
+	       But why dynamic reloc a invalid section? */
+            break;
+
+          if (input_section->output_section->flags & SEC_DEBUGGING)
+            {
+              LARCH_ASSERT (
+                0, bfd_reloc_dangerous,
+                "Seems dynamic linker not process sections 'SEC_DEBUGGING'.");
+              break;
+            }
+          if (!is_dyn)
+            break;
+
+          if ((info->flags & DF_TEXTREL) == 0)
+            if (input_section->output_section->flags & SEC_READONLY)
+              info->flags |= DF_TEXTREL;
+        }
+      while (0);
+#undef LARCH_ASSERT
+
+      if (fatal)
+        break;
+
+      loongarch_record_one_reloc (input_bfd, input_section, r_type,
+                                  rel->r_offset, sym, h, rel->r_addend);
+
+      if (r != bfd_reloc_continue)
+        r = perform_relocation (rel, relocation, input_bfd, contents);
+
+      switch (r)
+        {
+        case bfd_reloc_dangerous:
+        case bfd_reloc_continue:
+        case bfd_reloc_ok:
+          continue;
+
+        case bfd_reloc_overflow:
+          /* Overflow value can't be filled in */
+          loongarch_dump_reloc_record (info->callbacks->info);
+          info->callbacks->reloc_overflow (
+            info, (h ? &h->root : NULL), name, howto->name, rel->r_addend,
+            input_bfd, input_section, rel->r_offset);
+          break;
+
+        case bfd_reloc_outofrange:
+          /* Stack state incorrect */
+          loongarch_dump_reloc_record (info->callbacks->info);
+          info->callbacks->info (
+            "%X%H: Internal stack state is incorrect.\n"
+            "Want to push to full stack or pop from empty stack?\n",
+            input_bfd, input_section, rel->r_offset);
+          break;
+
+        case bfd_reloc_notsupported:
+          info->callbacks->info ("%X%H: Unknown relocation type.\n", input_bfd,
+                                 input_section, rel->r_offset);
+          break;
+
+        default:
+          info->callbacks->info ("%X%H: Internal: unknown error.\n", input_bfd,
+                                 input_section, rel->r_offset);
+          break;
+        }
+
+      fatal = true;
+      break;
+    }
+
+  return !fatal;
+}
+
+/* Finish up dynamic symbol handling.  We set the contents of various
+   dynamic sections here.  */
+
+static bool
+loongarch_elf_finish_dynamic_symbol (bfd *output_bfd,
+                                     struct bfd_link_info *info,
+                                     struct elf_link_hash_entry *h,
+                                     Elf_Internal_Sym *sym)
+{
+  struct loongarch_elf_link_hash_table *htab = loongarch_elf_hash_table (info);
+  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
+  asection *plt = NULL;
+
+  if (h->plt.offset != MINUS_ONE)
+    {
+      size_t i, plt_idx;
+      asection *gotplt, *relplt;
+      bfd_vma got_address;
+      uint32_t plt_entry[PLT_ENTRY_INSNS];
+      bfd_byte *loc;
+      Elf_Internal_Rela rela;
+
+      plt_idx = (h->plt.offset - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
+
+      /* one of '.plt' and '.iplt' represents */
+      BFD_ASSERT (!!htab->elf.splt ^ !!htab->elf.iplt);
+
+      if (htab->elf.splt)
+        {
+          BFD_ASSERT (
+            (h->type == STT_GNU_IFUNC && SYMBOL_REFERENCES_LOCAL (info, h)) ||
+            h->dynindx != -1);
+
+          plt = htab->elf.splt;
+          gotplt = htab->elf.sgotplt;
+          relplt = htab->elf.srelplt;
+          got_address =
+            sec_addr (gotplt) + GOTPLT_HEADER_SIZE + plt_idx * GOT_ENTRY_SIZE;
+        }
+      else /* if (htab->elf.iplt) */
+        {
+          BFD_ASSERT (h->type == STT_GNU_IFUNC &&
+                      SYMBOL_REFERENCES_LOCAL (info, h));
+
+          plt = htab->elf.iplt;
+          gotplt = htab->elf.igotplt;
+          relplt = htab->elf.irelplt;
+          got_address = sec_addr (gotplt) + plt_idx * GOT_ENTRY_SIZE;
+        }
+
+      /* Find out where the .plt entry should go.  */
+      loc = plt->contents + h->plt.offset;
+
+      /* Fill in the PLT entry itself.  */
+      loongarch_make_plt_entry (got_address, sec_addr (plt) + h->plt.offset,
+                                plt_entry);
+      for (i = 0; i < PLT_ENTRY_INSNS; i++)
+        bfd_put_32 (output_bfd, plt_entry[i], loc + 4 * i);
+
+      /* Fill in the initial value of the .got.plt entry.  */
+      loc = gotplt->contents + (got_address - sec_addr (gotplt));
+      bfd_put_NN (output_bfd, sec_addr (plt), loc);
+
+      rela.r_offset = got_address;
+      if (h->type == STT_GNU_IFUNC && SYMBOL_REFERENCES_LOCAL (info, h))
+        {
+          rela.r_info = ELFNN_R_INFO (0, R_LARCH_IRELATIVE);
+          rela.r_addend = h->root.u.def.value +
+                          h->root.u.def.section->output_section->vma +
+                          h->root.u.def.section->output_offset;
+        }
+      else
+        {
+          /* Fill in the entry in the .rela.plt section.  */
+          rela.r_info = ELFNN_R_INFO (h->dynindx, R_LARCH_JUMP_SLOT);
+          rela.r_addend = 0;
+        }
+
+      loc = relplt->contents + plt_idx * sizeof (ElfNN_External_Rela);
+      bed->s->swap_reloca_out (output_bfd, &rela, loc);
+
+      if (!h->def_regular)
+        {
+          /* Mark the symbol as undefined, rather than as defined in
+	     the .plt section.  Leave the value alone.  */
+          sym->st_shndx = SHN_UNDEF;
+          /* If the symbol is weak, we do need to clear the value.
+	     Otherwise, the PLT entry would provide a definition for
+	     the symbol even if the symbol wasn't defined anywhere,
+	     and so the symbol would never be NULL.  */
+          if (!h->ref_regular_nonweak)
+            sym->st_value = 0;
+        }
+    }
+
+  if (h->got.offset != MINUS_ONE
+
+      && /* TLS got entry have been handled in elf_relocate_section */
+      !(loongarch_elf_hash_entry (h)->tls_type & (GOT_TLS_GD | GOT_TLS_IE))
+
+      && /* have allocated got entry but not allocated rela before */
+      !UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))
+    {
+      asection *sgot, *srela;
+      Elf_Internal_Rela rela;
+      bfd_vma off = h->got.offset & ~(bfd_vma) 1;
+
+      /* This symbol has an entry in the GOT.  Set it up.  */
+
+      sgot = htab->elf.sgot;
+      srela = htab->elf.srelgot;
+      BFD_ASSERT (sgot && srela);
+
+      rela.r_offset = sec_addr (sgot) + off;
+
+      if (h->type == STT_GNU_IFUNC)
+        {
+          if (elf_hash_table (info)->dynamic_sections_created &&
+              SYMBOL_REFERENCES_LOCAL (info, h))
+            {
+              asection *sec = h->root.u.def.section;
+              rela.r_info = ELFNN_R_INFO (0, R_LARCH_IRELATIVE);
+              rela.r_addend = h->root.u.def.value + sec->output_section->vma +
+                              sec->output_offset;
+              bfd_put_NN (output_bfd, 0, sgot->contents + off);
+            }
+          else
+            {
+              BFD_ASSERT (plt);
+              rela.r_info = ELFNN_R_INFO (
+                0, bfd_link_pic (info) ? R_LARCH_RELATIVE : R_LARCH_NONE);
+              rela.r_addend =
+                plt->output_section->vma + plt->output_offset + h->plt.offset;
+              bfd_put_NN (output_bfd, rela.r_addend, sgot->contents + off);
+            }
+        }
+      else if (bfd_link_pic (info) && SYMBOL_REFERENCES_LOCAL (info, h))
+        {
+          BFD_ASSERT (h->got.offset & 1 /* has been filled in addr */);
+          asection *sec = h->root.u.def.section;
+          rela.r_info = ELFNN_R_INFO (0, R_LARCH_RELATIVE);
+          rela.r_addend = h->root.u.def.value + sec->output_section->vma +
+                          sec->output_offset;
+        }
+      else
+        {
+          BFD_ASSERT ((h->got.offset & 1) == 0);
+          BFD_ASSERT (h->dynindx != -1);
+          rela.r_info = ELFNN_R_INFO (h->dynindx, R_LARCH_NN);
+          rela.r_addend = 0;
+        }
+
+      loongarch_elf_append_rela (output_bfd, srela, &rela);
+    }
+
+  if (h->needs_copy)
+    {
+      Elf_Internal_Rela rela;
+      asection *s;
+
+      /* This symbols needs a copy reloc.  Set it up.  */
+      BFD_ASSERT (h->dynindx != -1);
+
+      rela.r_offset = sec_addr (h->root.u.def.section) + h->root.u.def.value;
+      rela.r_info = ELFNN_R_INFO (h->dynindx, R_LARCH_COPY);
+      rela.r_addend = 0;
+      if (h->root.u.def.section == htab->elf.sdynrelro)
+        s = htab->elf.sreldynrelro;
+      else
+        s = htab->elf.srelbss;
+      loongarch_elf_append_rela (output_bfd, s, &rela);
+    }
+
+  /* Mark some specially defined symbols as absolute.  */
+  if (h == htab->elf.hdynamic || h == htab->elf.hgot || h == htab->elf.hplt)
+    sym->st_shndx = SHN_ABS;
+
+  return true;
+}
+
+/* Finish up the dynamic sections.  */
+
+static bool
+loongarch_finish_dyn (bfd *output_bfd, struct bfd_link_info *info, bfd *dynobj,
+                      asection *sdyn)
+{
+  struct loongarch_elf_link_hash_table *htab = loongarch_elf_hash_table (info);
+  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
+  size_t dynsize = bed->s->sizeof_dyn, skipped_size = 0;
+  bfd_byte *dyncon, *dynconend;
+
+  dynconend = sdyn->contents + sdyn->size;
+  for (dyncon = sdyn->contents; dyncon < dynconend; dyncon += dynsize)
+    {
+      Elf_Internal_Dyn dyn;
+      asection *s;
+      int skipped = 0;
+
+      bed->s->swap_dyn_in (dynobj, dyncon, &dyn);
+
+      switch (dyn.d_tag)
+        {
+        case DT_PLTGOT:
+          s = htab->elf.sgotplt;
+          dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+          break;
+        case DT_JMPREL:
+          s = htab->elf.srelplt;
+          dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+          break;
+        case DT_PLTRELSZ:
+          s = htab->elf.srelplt;
+          dyn.d_un.d_val = s->size;
+          break;
+        case DT_TEXTREL:
+          if ((info->flags & DF_TEXTREL) == 0)
+            skipped = 1;
+          break;
+        case DT_FLAGS:
+          if ((info->flags & DF_TEXTREL) == 0)
+            dyn.d_un.d_val &= ~DF_TEXTREL;
+          break;
+        }
+      if (skipped)
+        skipped_size += dynsize;
+      else
+        bed->s->swap_dyn_out (output_bfd, &dyn, dyncon - skipped_size);
+    }
+  /* Wipe out any trailing entries if we shifted down a dynamic tag.  */
+  memset (dyncon - skipped_size, 0, skipped_size);
+  return true;
+}
+
+/* Finish up local dynamic symbol handling.  We set the contents of
+   various dynamic sections here.  */
+
+static bool
+elfNN_loongarch_finish_local_dynamic_symbol (void **slot, void *inf)
+{
+  struct elf_link_hash_entry *h = (struct elf_link_hash_entry *) *slot;
+  struct bfd_link_info *info = (struct bfd_link_info *) inf;
+
+  return loongarch_elf_finish_dynamic_symbol (info->output_bfd, info, h, NULL);
+}
+
+static bool
+loongarch_elf_finish_dynamic_sections (bfd *output_bfd,
+                                       struct bfd_link_info *info)
+{
+  bfd *dynobj;
+  asection *sdyn, *plt, *gotplt;
+  struct loongarch_elf_link_hash_table *htab;
+
+  htab = loongarch_elf_hash_table (info);
+  BFD_ASSERT (htab);
+  dynobj = htab->elf.dynobj;
+  sdyn = bfd_get_linker_section (dynobj, ".dynamic");
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      BFD_ASSERT (htab->elf.splt && sdyn);
+
+      if (!loongarch_finish_dyn (output_bfd, info, dynobj, sdyn))
+        return false;
+    }
+
+  if ((plt = htab->elf.splt))
+    gotplt = htab->elf.sgotplt;
+  else if ((plt = htab->elf.iplt))
+    gotplt = htab->elf.igotplt;
+
+  if (plt && 0 < plt->size)
+    {
+      size_t i;
+      uint32_t plt_header[PLT_HEADER_INSNS];
+      loongarch_make_plt_header (sec_addr (gotplt), sec_addr (plt),
+                                 plt_header);
+      for (i = 0; i < PLT_HEADER_INSNS; i++)
+        bfd_put_32 (output_bfd, plt_header[i], plt->contents + 4 * i);
+
+      elf_section_data (plt->output_section)->this_hdr.sh_entsize =
+        PLT_ENTRY_SIZE;
+    }
+
+  if (htab->elf.sgotplt)
+    {
+      asection *output_section = htab->elf.sgotplt->output_section;
+
+      if (bfd_is_abs_section (output_section))
+        {
+          _bfd_error_handler (_ ("discarded output section: `%pA'"),
+                              htab->elf.sgotplt);
+          return false;
+        }
+
+      if (0 < htab->elf.sgotplt->size)
+        {
+          /* Write the first two entries in .got.plt, needed for the dynamic
+	     linker.  */
+          bfd_put_NN (output_bfd, MINUS_ONE, htab->elf.sgotplt->contents);
+
+          bfd_put_NN (output_bfd, (bfd_vma) 0,
+                      htab->elf.sgotplt->contents + GOT_ENTRY_SIZE);
+        }
+
+      elf_section_data (output_section)->this_hdr.sh_entsize = GOT_ENTRY_SIZE;
+    }
+
+  if (htab->elf.sgot)
+    {
+      asection *output_section = htab->elf.sgot->output_section;
+
+      if (0 < htab->elf.sgot->size)
+        {
+          /* Set the first entry in the global offset table to the address of
+	     the dynamic section.  */
+          bfd_vma val = sdyn ? sec_addr (sdyn) : 0;
+          bfd_put_NN (output_bfd, val, htab->elf.sgot->contents);
+        }
+
+      elf_section_data (output_section)->this_hdr.sh_entsize = GOT_ENTRY_SIZE;
+    }
+
+  /* Fill PLT and GOT entries for local STT_GNU_IFUNC symbols.  */
+  htab_traverse (htab->loc_hash_table,
+                 (void *) elfNN_loongarch_finish_local_dynamic_symbol, info);
+
+  return true;
+}
+
+/* Return address for Ith PLT stub in section PLT, for relocation REL
+   or (bfd_vma) -1 if it should not be included.  */
+
+static bfd_vma
+loongarch_elf_plt_sym_val (bfd_vma i, const asection *plt,
+                           const arelent *rel ATTRIBUTE_UNUSED)
+{
+  return plt->vma + PLT_HEADER_SIZE + i * PLT_ENTRY_SIZE;
+}
+
+static enum elf_reloc_type_class
+loongarch_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
+                            const asection *rel_sec ATTRIBUTE_UNUSED,
+                            const Elf_Internal_Rela *rela)
+{
+  struct loongarch_elf_link_hash_table *htab;
+  htab = loongarch_elf_hash_table (info);
+
+  if (htab->elf.dynsym != NULL && htab->elf.dynsym->contents != NULL)
+    {
+      /* Check relocation against STT_GNU_IFUNC symbol if there are
+	 dynamic symbols. */
+      bfd *abfd = info->output_bfd;
+      const struct elf_backend_data *bed = get_elf_backend_data (abfd);
+      unsigned long r_symndx = ELFNN_R_SYM (rela->r_info);
+      if (r_symndx != STN_UNDEF)
+        {
+          Elf_Internal_Sym sym;
+          if (!bed->s->swap_symbol_in (abfd,
+                                       htab->elf.dynsym->contents +
+                                         r_symndx * bed->s->sizeof_sym,
+                                       0, &sym))
+            {
+              /* xgettext:c-format */
+              _bfd_error_handler (_ ("%pB symbol number %lu references"
+                                     " nonexistent SHT_SYMTAB_SHNDX section"),
+                                  abfd, r_symndx);
+              /* Ideally an error class should be returned here.  */
+            }
+          else if (ELF_ST_TYPE (sym.st_info) == STT_GNU_IFUNC)
+            return reloc_class_ifunc;
+        }
+    }
+
+  switch (ELFNN_R_TYPE (rela->r_info))
+    {
+    case R_LARCH_IRELATIVE:
+      return reloc_class_ifunc;
+    case R_LARCH_RELATIVE:
+      return reloc_class_relative;
+    case R_LARCH_JUMP_SLOT:
+      return reloc_class_plt;
+    case R_LARCH_COPY:
+      return reloc_class_copy;
+    default:
+      return reloc_class_normal;
+    }
+}
+
+/* Copy the extra info we tack onto an elf_link_hash_entry.  */
+
+static void
+loongarch_elf_copy_indirect_symbol (struct bfd_link_info *info,
+                                    struct elf_link_hash_entry *dir,
+                                    struct elf_link_hash_entry *ind)
+{
+  struct loongarch_elf_link_hash_entry *edir, *eind;
+
+  edir = (struct loongarch_elf_link_hash_entry *) dir;
+  eind = (struct loongarch_elf_link_hash_entry *) ind;
+
+  if (eind->dyn_relocs != NULL)
+    {
+      if (edir->dyn_relocs != NULL)
+        {
+          struct elf_dyn_relocs **pp;
+          struct elf_dyn_relocs *p;
+
+          /* Add reloc counts against the indirect sym to the direct sym
+	     list.  Merge any entries against the same section.  */
+          for (pp = &eind->dyn_relocs; (p = *pp) != NULL;)
+            {
+              struct elf_dyn_relocs *q;
+
+              for (q = edir->dyn_relocs; q != NULL; q = q->next)
+                if (q->sec == p->sec)
+                  {
+                    q->pc_count += p->pc_count;
+                    q->count += p->count;
+                    *pp = p->next;
+                    break;
+                  }
+              if (q == NULL)
+                pp = &p->next;
+            }
+          *pp = edir->dyn_relocs;
+        }
+
+      edir->dyn_relocs = eind->dyn_relocs;
+      eind->dyn_relocs = NULL;
+    }
+
+  if (ind->root.type == bfd_link_hash_indirect && dir->got.refcount < 0)
+    {
+      edir->tls_type = eind->tls_type;
+      eind->tls_type = GOT_UNKNOWN;
+    }
+  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
+}
+
+/* Support for core dump NOTE sections.  */
+
+static bool
+loongarch_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
+{
+  switch (note->descsz)
+    {
+    default:
+      return false;
+
+    case sizeof (
+      prstatus_t): /* sizeof(struct elf_prstatus) on Linux/Loongarch.  */
+      /* pr_cursig */
+      elf_tdata (abfd)->core->signal =
+        bfd_get_16 (abfd, note->descdata + offsetof (prstatus_t, pr_cursig));
+
+      /* pr_pid */
+      elf_tdata (abfd)->core->lwpid =
+        bfd_get_32 (abfd, note->descdata + offsetof (prstatus_t, pr_pid));
+      break;
+    }
+
+  /* Make a ".reg/999" section.  */
+  return _bfd_elfcore_make_pseudosection (abfd, ".reg", sizeof (elf_gregset_t),
+                                          note->descpos +
+                                            offsetof (prstatus_t, pr_reg));
+}
+
+static bool
+loongarch_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
+{
+  switch (note->descsz)
+    {
+    default:
+      return false;
+
+    case sizeof (
+      prpsinfo_t): /* sizeof(struct elf_prpsinfo) on Linux/Loongarch.  */
+      /* pr_pid */
+      elf_tdata (abfd)->core->pid =
+        bfd_get_32 (abfd, note->descdata + offsetof (prpsinfo_t, pr_pid));
+
+      /* pr_fname */
+      elf_tdata (abfd)->core->program = _bfd_elfcore_strndup (
+        abfd, note->descdata + offsetof (prpsinfo_t, pr_fname),
+        sizeof (((prpsinfo_t *) 0)->pr_fname));
+
+      /* pr_psargs */
+      elf_tdata (abfd)->core->command = _bfd_elfcore_strndup (
+        abfd, note->descdata + offsetof (prpsinfo_t, pr_psargs),
+        sizeof (((prpsinfo_t *) 0)->pr_psargs));
+      break;
+    }
+
+  /* Note that for some reason, a spurious space is tacked
+     onto the end of the args in some (at least one anyway)
+     implementations, so strip it off if it exists.  */
+
+  {
+    char *command = elf_tdata (abfd)->core->command;
+    int n = strlen (command);
+
+    if (0 < n && command[n - 1] == ' ')
+      command[n - 1] = '\0';
+  }
+
+  return true;
+}
+
+/* Set the right mach type.  */
+static bool
+loongarch_elf_object_p (bfd *abfd)
+{
+  /* There are only two mach types in Loongarch currently.  */
+  if (strcmp (abfd->xvec->name, "elf64-loongarch") == 0)
+    bfd_default_set_arch_mach (abfd, bfd_arch_loongarch, bfd_mach_loongarch64);
+  else
+    bfd_default_set_arch_mach (abfd, bfd_arch_loongarch, bfd_mach_loongarch32);
+  return true;
+}
+
+static asection *
+loongarch_elf_gc_mark_hook (asection *sec, struct bfd_link_info *info,
+                            Elf_Internal_Rela *rel,
+                            struct elf_link_hash_entry *h,
+                            Elf_Internal_Sym *sym)
+{
+  if (h != NULL)
+    switch (ELFNN_R_TYPE (rel->r_info))
+      {
+      case R_LARCH_GNU_VTINHERIT:
+      case R_LARCH_GNU_VTENTRY:
+        return NULL;
+      }
+
+  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
+}
+
+static bool
+_loongarch_bfd_set_section_contents (bfd *abfd, sec_ptr section,
+                                     const void *location, file_ptr offset,
+                                     bfd_size_type conut)
+
+{
+  if (elf_elfheader (abfd)->e_flags == 0)
+    {
+      if (abfd->arch_info->arch == bfd_arch_loongarch)
+        {
+          if (abfd->arch_info->mach == bfd_mach_loongarch32)
+            elf_elfheader (abfd)->e_flags = EF_LARCH_ABI_LP32;
+          else if (abfd->arch_info->mach == bfd_mach_loongarch64)
+            elf_elfheader (abfd)->e_flags = EF_LARCH_ABI_LP64;
+          else
+            return false;
+        }
+    }
+  return _bfd_elf_set_section_contents (abfd, section, location, offset,
+                                        conut);
+}
+
+#define TARGET_LITTLE_SYM loongarch_elfNN_vec
+#define TARGET_LITTLE_NAME "elfNN-loongarch"
+#define ELF_ARCH bfd_arch_loongarch
+#define ELF_TARGET_ID LARCH_ELF_DATA
+#define ELF_MACHINE_CODE EM_LOONGARCH
+#define ELF_MAXPAGESIZE 0x4000
+#define bfd_elfNN_bfd_reloc_type_lookup loongarch_reloc_type_lookup
+#define bfd_elfNN_bfd_link_hash_table_create                                  \
+  loongarch_elf_link_hash_table_create
+#define bfd_elfNN_bfd_reloc_name_lookup loongarch_reloc_name_lookup
+#define elf_info_to_howto_rel NULL /* fall through to elf_info_to_howto */
+#define elf_info_to_howto loongarch_info_to_howto_rela
+#define bfd_elfNN_bfd_merge_private_bfd_data                                  \
+  elfNN_loongarch_merge_private_bfd_data
+
+#define bfd_elfNN_set_section_contents _loongarch_bfd_set_section_contents
+
+#define elf_backend_reloc_type_class loongarch_reloc_type_class
+#define elf_backend_copy_indirect_symbol loongarch_elf_copy_indirect_symbol
+#define elf_backend_create_dynamic_sections                                   \
+  loongarch_elf_create_dynamic_sections
+#define elf_backend_check_relocs loongarch_elf_check_relocs
+#define elf_backend_adjust_dynamic_symbol loongarch_elf_adjust_dynamic_symbol
+#define elf_backend_size_dynamic_sections loongarch_elf_size_dynamic_sections
+#define elf_backend_relocate_section loongarch_elf_relocate_section
+#define elf_backend_finish_dynamic_symbol loongarch_elf_finish_dynamic_symbol
+#define elf_backend_finish_dynamic_sections                                   \
+  loongarch_elf_finish_dynamic_sections
+#define elf_backend_object_p loongarch_elf_object_p
+#define elf_backend_gc_mark_hook loongarch_elf_gc_mark_hook
+#define elf_backend_plt_sym_val loongarch_elf_plt_sym_val
+#define elf_backend_grok_prstatus loongarch_elf_grok_prstatus
+#define elf_backend_grok_psinfo loongarch_elf_grok_psinfo
+
+#include "elfNN-target.h"
diff --git a/bfd/elfxx-loongarch.c b/bfd/elfxx-loongarch.c
new file mode 100644
index 00000000000..16079edce28
--- /dev/null
+++ b/bfd/elfxx-loongarch.c
@@ -0,0 +1,195 @@
+/* Loongarch-specific support for ELF.
+   Copyright (C) 2021-2021 Free Software Foundation, Inc.
+   Contributed by Loongson Ltd.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/loongarch.h"
+#include "elfxx-loongarch.h"
+
+/* This does not include any relocation information, but should be
+   good enough for GDB or objdump to read the file.  */
+
+static reloc_howto_type howto_table[] = 
+{
+#define LOONGARCH_HOWTO(r_name)                                               \
+  HOWTO (R_LARCH_##r_name, 0, 3, 32, false, 0, complain_overflow_signed,      \
+         bfd_elf_generic_reloc, "R_LARCH_" #r_name, false, 0, 0, false)
+  LOONGARCH_HOWTO (NONE),
+  LOONGARCH_HOWTO (32),
+  LOONGARCH_HOWTO (64),
+  LOONGARCH_HOWTO (RELATIVE),
+  LOONGARCH_HOWTO (COPY),
+  LOONGARCH_HOWTO (JUMP_SLOT),
+  LOONGARCH_HOWTO (TLS_DTPMOD32),
+  LOONGARCH_HOWTO (TLS_DTPMOD64),
+  LOONGARCH_HOWTO (TLS_DTPREL32),
+  LOONGARCH_HOWTO (TLS_DTPREL64),
+  LOONGARCH_HOWTO (TLS_TPREL32),
+  LOONGARCH_HOWTO (TLS_TPREL64),
+  LOONGARCH_HOWTO (IRELATIVE),
+
+  LOONGARCH_HOWTO (MARK_LA),
+  LOONGARCH_HOWTO (MARK_PCREL),
+  HOWTO (R_LARCH_SOP_PUSH_PCREL,              /* type */
+         2,                                   /* rightshift */
+         3,                                   /* size */
+         32,                                  /* bitsize */
+         true /* FIXME: somewhat use this */, /* pc_relative */
+         0,                                   /* bitpos */
+         complain_overflow_signed,            /* complain_on_overflow */
+         bfd_elf_generic_reloc,               /* special_function */
+         "R_LARCH_SOP_PUSH_PCREL",            /* name */
+         false,                               /* partial_inplace */
+         0x03ffffff,                          /* src_mask */
+         0x03ffffff,                          /* dst_mask */
+         false),                              /* pcrel_offset */
+  LOONGARCH_HOWTO (SOP_PUSH_ABSOLUTE),
+  LOONGARCH_HOWTO (SOP_PUSH_DUP),
+  LOONGARCH_HOWTO (SOP_PUSH_GPREL),
+  LOONGARCH_HOWTO (SOP_PUSH_TLS_TPREL),
+  LOONGARCH_HOWTO (SOP_PUSH_TLS_GOT),
+  LOONGARCH_HOWTO (SOP_PUSH_TLS_GD),
+  LOONGARCH_HOWTO (SOP_PUSH_PLT_PCREL),
+  LOONGARCH_HOWTO (SOP_ASSERT),
+  LOONGARCH_HOWTO (SOP_NOT),
+  LOONGARCH_HOWTO (SOP_SUB),
+  LOONGARCH_HOWTO (SOP_SL),
+  LOONGARCH_HOWTO (SOP_SR),
+  LOONGARCH_HOWTO (SOP_ADD),
+  LOONGARCH_HOWTO (SOP_AND),
+  LOONGARCH_HOWTO (SOP_IF_ELSE),
+  LOONGARCH_HOWTO (SOP_POP_32_S_10_5),
+  LOONGARCH_HOWTO (SOP_POP_32_U_10_12),
+  LOONGARCH_HOWTO (SOP_POP_32_S_10_12),
+  LOONGARCH_HOWTO (SOP_POP_32_S_10_16),
+  LOONGARCH_HOWTO (SOP_POP_32_S_10_16_S2),
+  LOONGARCH_HOWTO (SOP_POP_32_S_5_20),
+  LOONGARCH_HOWTO (SOP_POP_32_S_0_5_10_16_S2),
+  LOONGARCH_HOWTO (SOP_POP_32_S_0_10_10_16_S2),
+  LOONGARCH_HOWTO (SOP_POP_32_U),
+  LOONGARCH_HOWTO (ADD8),
+  LOONGARCH_HOWTO (ADD16),
+  LOONGARCH_HOWTO (ADD24),
+  LOONGARCH_HOWTO (ADD32),
+  LOONGARCH_HOWTO (ADD64),
+  LOONGARCH_HOWTO (SUB8),
+  LOONGARCH_HOWTO (SUB16),
+  LOONGARCH_HOWTO (SUB24),
+  LOONGARCH_HOWTO (SUB32),
+  LOONGARCH_HOWTO (SUB64),
+};
+
+struct elf_reloc_map
+{
+  bfd_reloc_code_real_type bfd_val;
+  enum elf_loongarch_reloc_type elf_val;
+};
+
+static const struct elf_reloc_map loong_reloc_map[] = 
+{
+  { BFD_RELOC_NONE, R_LARCH_NONE },
+  { BFD_RELOC_32, R_LARCH_32 },
+  { BFD_RELOC_64, R_LARCH_64 },
+
+#define LOONGARCH_reloc_map(r_name)                                           \
+  {                                                                           \
+    BFD_RELOC_LARCH_##r_name, R_LARCH_##r_name                                \
+  }
+  LOONGARCH_reloc_map (TLS_DTPMOD32),
+  LOONGARCH_reloc_map (TLS_DTPMOD64),
+  LOONGARCH_reloc_map (TLS_DTPREL32),
+  LOONGARCH_reloc_map (TLS_DTPREL64),
+  LOONGARCH_reloc_map (TLS_TPREL32),
+  LOONGARCH_reloc_map (TLS_TPREL64),
+
+  LOONGARCH_reloc_map (MARK_LA),
+  LOONGARCH_reloc_map (MARK_PCREL),
+  LOONGARCH_reloc_map (SOP_PUSH_PCREL),
+  LOONGARCH_reloc_map (SOP_PUSH_ABSOLUTE),
+  LOONGARCH_reloc_map (SOP_PUSH_DUP),
+  LOONGARCH_reloc_map (SOP_PUSH_GPREL),
+  LOONGARCH_reloc_map (SOP_PUSH_TLS_TPREL),
+  LOONGARCH_reloc_map (SOP_PUSH_TLS_GOT),
+  LOONGARCH_reloc_map (SOP_PUSH_TLS_GD),
+  LOONGARCH_reloc_map (SOP_PUSH_PLT_PCREL),
+  LOONGARCH_reloc_map (SOP_ASSERT),
+  LOONGARCH_reloc_map (SOP_NOT),
+  LOONGARCH_reloc_map (SOP_SUB),
+  LOONGARCH_reloc_map (SOP_SL),
+  LOONGARCH_reloc_map (SOP_SR),
+  LOONGARCH_reloc_map (SOP_ADD),
+  LOONGARCH_reloc_map (SOP_AND),
+  LOONGARCH_reloc_map (SOP_IF_ELSE),
+  LOONGARCH_reloc_map (SOP_POP_32_S_10_5),
+  LOONGARCH_reloc_map (SOP_POP_32_U_10_12),
+  LOONGARCH_reloc_map (SOP_POP_32_S_10_12),
+  LOONGARCH_reloc_map (SOP_POP_32_S_10_16),
+  LOONGARCH_reloc_map (SOP_POP_32_S_10_16_S2),
+  LOONGARCH_reloc_map (SOP_POP_32_S_5_20),
+  LOONGARCH_reloc_map (SOP_POP_32_S_0_5_10_16_S2),
+  LOONGARCH_reloc_map (SOP_POP_32_S_0_10_10_16_S2),
+  LOONGARCH_reloc_map (SOP_POP_32_U),
+  LOONGARCH_reloc_map (ADD8),
+  LOONGARCH_reloc_map (ADD16),
+  LOONGARCH_reloc_map (ADD24),
+  LOONGARCH_reloc_map (ADD32),
+  LOONGARCH_reloc_map (ADD64),
+  LOONGARCH_reloc_map (SUB8),
+  LOONGARCH_reloc_map (SUB16),
+  LOONGARCH_reloc_map (SUB24),
+  LOONGARCH_reloc_map (SUB32),
+  LOONGARCH_reloc_map (SUB64),
+};
+
+reloc_howto_type *
+loongarch_elf_rtype_to_howto (unsigned int r_type)
+{
+  size_t i;
+  for (i = 0; i < ARRAY_SIZE (howto_table); i++)
+    if (howto_table[i].type == r_type)
+      return &howto_table[i];
+  return NULL;
+}
+
+reloc_howto_type *
+loongarch_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+                             bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+  for (i = 0; i < ARRAY_SIZE (loong_reloc_map); i++)
+    if (loong_reloc_map[i].bfd_val == code)
+      return loongarch_elf_rtype_to_howto ((int) loong_reloc_map[i].elf_val);
+
+  return NULL;
+}
+
+reloc_howto_type *
+loongarch_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED, const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0; i < ARRAY_SIZE (howto_table); i++)
+    if (howto_table[i].name && strcasecmp (howto_table[i].name, r_name) == 0)
+      return &howto_table[i];
+
+  return NULL;
+}
diff --git a/bfd/elfxx-loongarch.h b/bfd/elfxx-loongarch.h
new file mode 100644
index 00000000000..c47c57fa514
--- /dev/null
+++ b/bfd/elfxx-loongarch.h
@@ -0,0 +1,30 @@
+/* Loonarch-specific backend routines.
+   Copyright (C) 2021-2021 Free Software Foundation, Inc.
+   Contributed by Loongson Ltd.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+
+#include "elf/common.h"
+#include "elf/internal.h"
+
+extern reloc_howto_type *loongarch_elf_rtype_to_howto (unsigned int r_type);
+
+extern reloc_howto_type *
+loongarch_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code);
+
+extern reloc_howto_type *
+loongarch_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED, const char *r_name);
diff --git a/bfd/libbfd.h b/bfd/libbfd.h
index 69496411622..41ecd3bc644 100644
--- a/bfd/libbfd.h
+++ b/bfd/libbfd.h
@@ -3416,6 +3416,49 @@ static const char *const bfd_reloc_code_real_names[] = { "@@uninitialized@@",
   "BFD_RELOC_CKCORE_PCREL_BLOOP_IMM4BY4",
   "BFD_RELOC_CKCORE_PCREL_BLOOP_IMM12BY4",
   "BFD_RELOC_S12Z_OPR",
+  "BFD_RELOC_LARCH_TLS_DTPMOD32",
+  "BFD_RELOC_LARCH_TLS_DTPREL32",
+  "BFD_RELOC_LARCH_TLS_DTPMOD64",
+  "BFD_RELOC_LARCH_TLS_DTPREL64",
+  "BFD_RELOC_LARCH_TLS_TPREL32",
+  "BFD_RELOC_LARCH_TLS_TPREL64",
+  "BFD_RELOC_LARCH_MARK_LA",
+  "BFD_RELOC_LARCH_MARK_PCREL",
+  "BFD_RELOC_LARCH_SOP_PUSH_PCREL",
+  "BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE",
+  "BFD_RELOC_LARCH_SOP_PUSH_DUP",
+  "BFD_RELOC_LARCH_SOP_PUSH_GPREL",
+  "BFD_RELOC_LARCH_SOP_PUSH_TLS_TPREL",
+  "BFD_RELOC_LARCH_SOP_PUSH_TLS_GOT",
+  "BFD_RELOC_LARCH_SOP_PUSH_TLS_GD",
+  "BFD_RELOC_LARCH_SOP_PUSH_PLT_PCREL",
+  "BFD_RELOC_LARCH_SOP_ASSERT",
+  "BFD_RELOC_LARCH_SOP_NOT",
+  "BFD_RELOC_LARCH_SOP_SUB",
+  "BFD_RELOC_LARCH_SOP_SL",
+  "BFD_RELOC_LARCH_SOP_SR",
+  "BFD_RELOC_LARCH_SOP_ADD",
+  "BFD_RELOC_LARCH_SOP_AND",
+  "BFD_RELOC_LARCH_SOP_IF_ELSE",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_10_5",
+  "BFD_RELOC_LARCH_SOP_POP_32_U_10_12",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_10_12",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_10_16",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_5_20",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2",
+  "BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2",
+  "BFD_RELOC_LARCH_SOP_POP_32_U",
+  "BFD_RELOC_LARCH_ADD8",
+  "BFD_RELOC_LARCH_ADD16",
+  "BFD_RELOC_LARCH_ADD24",
+  "BFD_RELOC_LARCH_ADD32",
+  "BFD_RELOC_LARCH_ADD64",
+  "BFD_RELOC_LARCH_SUB8",
+  "BFD_RELOC_LARCH_SUB16",
+  "BFD_RELOC_LARCH_SUB24",
+  "BFD_RELOC_LARCH_SUB32",
+  "BFD_RELOC_LARCH_SUB64",
  "@@overflow: BFD_RELOC_UNUSED@@",
 };
 #endif
diff --git a/bfd/reloc.c b/bfd/reloc.c
index 6d920e1df06..30826fe7e0f 100644
--- a/bfd/reloc.c
+++ b/bfd/reloc.c
@@ -8171,6 +8171,95 @@ ENUM
 ENUMDOC
   S12Z relocations.
 
+ENUM
+  BFD_RELOC_LARCH_TLS_DTPMOD32
+ENUMX
+  BFD_RELOC_LARCH_TLS_DTPREL32
+ENUMX
+  BFD_RELOC_LARCH_TLS_DTPMOD64
+ENUMX
+  BFD_RELOC_LARCH_TLS_DTPREL64
+ENUMX
+  BFD_RELOC_LARCH_TLS_TPREL32
+ENUMX
+  BFD_RELOC_LARCH_TLS_TPREL64
+ENUMX
+  BFD_RELOC_LARCH_MARK_LA
+ENUMX
+  BFD_RELOC_LARCH_MARK_PCREL
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_PCREL
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_DUP
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_GPREL
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_TLS_TPREL
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_TLS_GOT
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_TLS_GD
+ENUMX
+  BFD_RELOC_LARCH_SOP_PUSH_PLT_PCREL
+ENUMX
+  BFD_RELOC_LARCH_SOP_ASSERT
+ENUMX
+  BFD_RELOC_LARCH_SOP_NOT
+ENUMX
+  BFD_RELOC_LARCH_SOP_SUB
+ENUMX
+  BFD_RELOC_LARCH_SOP_SL
+ENUMX
+  BFD_RELOC_LARCH_SOP_SR
+ENUMX
+  BFD_RELOC_LARCH_SOP_ADD
+ENUMX
+  BFD_RELOC_LARCH_SOP_AND
+ENUMX
+  BFD_RELOC_LARCH_SOP_IF_ELSE
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_5
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_U_10_12
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_12
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_16
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_5_20
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2
+ENUMX
+  BFD_RELOC_LARCH_SOP_POP_32_U
+ENUMX
+  BFD_RELOC_LARCH_ADD8
+ENUMX
+  BFD_RELOC_LARCH_ADD16
+ENUMX
+  BFD_RELOC_LARCH_ADD24
+ENUMX
+  BFD_RELOC_LARCH_ADD32
+ENUMX
+  BFD_RELOC_LARCH_ADD64
+ENUMX
+  BFD_RELOC_LARCH_SUB8
+ENUMX
+  BFD_RELOC_LARCH_SUB16
+ENUMX
+  BFD_RELOC_LARCH_SUB24
+ENUMX
+  BFD_RELOC_LARCH_SUB32
+ENUMX
+  BFD_RELOC_LARCH_SUB64
+ENUMDOC
+  LARCH relocations.
+
 ENDSENUM
   BFD_RELOC_UNUSED
 CODE_FRAGMENT
diff --git a/bfd/targets.c b/bfd/targets.c
index 89b49e721b4..8f5abb174e2 100644
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -768,6 +768,8 @@ extern const bfd_target l1om_elf64_vec;
 extern const bfd_target l1om_elf64_fbsd_vec;
 extern const bfd_target lm32_elf32_vec;
 extern const bfd_target lm32_elf32_fdpic_vec;
+extern const bfd_target loongarch_elf64_vec;
+extern const bfd_target loongarch_elf32_vec;
 extern const bfd_target m32c_elf32_vec;
 extern const bfd_target m32r_elf32_vec;
 extern const bfd_target m32r_elf32_le_vec;
@@ -1359,6 +1361,12 @@ static const bfd_target * const _bfd_target_vector[] =
 	&z80_elf32_vec,
 
 	&z8k_coff_vec,
+
+#ifdef BFD64
+	&loongarch_elf32_vec,
+	&loongarch_elf64_vec,
+#endif
+
 #endif /* not SELECT_VECS */
 
 /* Always support S-records, for convenience.  */
diff --git a/binutils/readelf.c b/binutils/readelf.c
index 5682837ed7b..7772d048b0d 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -162,6 +162,7 @@
 #include "elf/xstormy16.h"
 #include "elf/xtensa.h"
 #include "elf/z80.h"
+#include "elf/loongarch.h"
 
 #include "getopt.h"
 #include "libiberty.h"
@@ -1653,6 +1654,9 @@ dump_relocations (Filedata *          filedata,
 	case EM_Z80:
 	  rtype = elf_z80_reloc_type (type);
 	  break;
+    case EM_LOONGARCH:
+      rtype = elf_loongarch_reloc_type (type);
+      break;
 	}
 
       if (rtype == NULL)
@@ -13673,6 +13677,8 @@ is_32bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
       return reloc_type == 2; /* R_IQ2000_32.  */
     case EM_LATTICEMICO32:
       return reloc_type == 3; /* R_LM32_32.  */
+    case EM_LOONGARCH:
+      return reloc_type == 1; /* R_LARCH_32. */
     case EM_M32C_OLD:
     case EM_M32C:
       return reloc_type == 3; /* R_M32C_32.  */
@@ -13890,6 +13896,8 @@ is_64bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
     case EM_IA_64:
       return (reloc_type == 0x26    /* R_IA64_DIR64MSB.  */
 	      || reloc_type == 0x27 /* R_IA64_DIR64LSB.  */);
+    case EM_LOONGARCH:
+      return reloc_type == 2;      /* R_LARCH_64 */
     case EM_PARISC:
       return reloc_type == 80; /* R_PARISC_DIR64.  */
     case EM_PPC64:
diff --git a/binutils/testsuite/binutils-all/objdump.exp b/binutils/testsuite/binutils-all/objdump.exp
index c9a7eec75ec..5b59ae30fb1 100644
--- a/binutils/testsuite/binutils-all/objdump.exp
+++ b/binutils/testsuite/binutils-all/objdump.exp
@@ -40,7 +40,7 @@ lappend cpus_expected m16c m32c m32r m68hc11 m68hc12 m68k MCore mep c5 h1 MicroB
 lappend cpus_expected mips mn10200 mn10300 ms1 msp MSP430 nds32 n1h_v3 ns32k
 lappend cpus_expected or1k or1knd pj powerpc pyramid riscv romp rs6000 s390 sh sparc
 lappend cpus_expected tic54x tilegx tms320c30 tms320c4x tms320c54x
-lappend cpus_expected v850 vax x86-64 xscale xtensa z8k z8001 z8002
+lappend cpus_expected v850 vax x86-64 xscale xtensa z8k z8001 z8002 Loongarch64
 
 # Make sure the target CPU shows up in the list.
 lappend cpus_expected ${target_cpu}
diff --git a/gas/Makefile.am b/gas/Makefile.am
index 34190e78b8c..bf4904a653f 100644
--- a/gas/Makefile.am
+++ b/gas/Makefile.am
@@ -154,6 +154,7 @@ TARGET_CPU_CFILES = \
 	config/tc-ip2k.c \
 	config/tc-iq2000.c \
 	config/tc-lm32.c \
+	config/tc-loongarch.c \
 	config/tc-m32c.c \
 	config/tc-m32r.c \
 	config/tc-m68hc11.c \
@@ -374,7 +375,8 @@ EXTRA_SCRIPTS = .gdbinit
 EXTRA_DIST = config/m68k-parse.c itbl-parse.c itbl-parse.h itbl-lex.c \
 	config/bfin-parse.c config/bfin-parse.h config/bfin-lex.c \
 	config/rl78-parse.c config/rl78-parse.h \
-	config/rx-parse.c config/rx-parse.h
+	config/rx-parse.c config/rx-parse.h \
+	config/loongarch-parse.c config/loongarch-parse.h config/loongarch-lex.c
 
 diststuff: $(EXTRA_DIST) info
 
@@ -471,6 +473,28 @@ config/rx-parse.c: $(srcdir)/config/rx-parse.y
 config/rx-parse.h: config/rx-parse.c
 	@true
 
+# The loongarch lexical analyzer and parser.
+EXTRA_as_new_SOURCES += config/loongarch-parse.y
+loongarch-parse.c: $(srcdir)/config/loongarch-parse.y
+	$(SHELL) $(YLWRAP) $(srcdir)/config/loongarch-parse.y y.tab.c loongarch-parse.c y.tab.h loongarch-parse.h -- $(YACCCOMPILE) -d ;
+loongarch-parse.h: loongarch-parse.c
+loongarch-parse.h: ; @true
+$(srcdir)/config/loongarch-parse.h: ; @true
+
+loongarch-lex.c: $(srcdir)/config/loongarch-lex.l
+	$(SHELL) $(YLWRAP) $(srcdir)/config/loongarch-lex.l lex.yy.c loongarch-lex.c -- $(LEXCOMPILE)
+loongarch-lex-wrapper.@OBJEXT@: $(srcdir)/config/loongarch-lex-wrapper.c loongarch-lex.c loongarch-parse.h
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $(srcdir)/config/loongarch-lex-wrapper.c $(NO_WERROR)
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='loongarch-lex-wrapper.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c $(srcdir)/config/loongarch-lex-wrapper.c $(NO_WERROR)
+endif
+
 # The mips instruction table specification lexical analyzer and parser.
 
 itbl-lex-wrapper.@OBJEXT@: itbl-lex.c itbl-parse.h
diff --git a/gas/Makefile.in b/gas/Makefile.in
index f3d66b8e8b6..97100334644 100644
--- a/gas/Makefile.in
+++ b/gas/Makefile.in
@@ -544,6 +544,7 @@ TARGET_CPU_CFILES = \
 	config/tc-ip2k.c \
 	config/tc-iq2000.c \
 	config/tc-lm32.c \
+	config/tc-loongarch.c \
 	config/tc-m32c.c \
 	config/tc-m32r.c \
 	config/tc-m68hc11.c \
@@ -757,7 +758,8 @@ EXTRA_SCRIPTS = .gdbinit
 EXTRA_DIST = config/m68k-parse.c itbl-parse.c itbl-parse.h itbl-lex.c \
 	config/bfin-parse.c config/bfin-parse.h config/bfin-lex.c \
 	config/rl78-parse.c config/rl78-parse.h \
-	config/rx-parse.c config/rx-parse.h
+	config/rx-parse.c config/rx-parse.h \
+	config/loongarch-parse.c config/loongarch-parse.h config/loongarch-lex.c
 
 DISTCLEANFILES = targ-cpu.h obj-format.h targ-env.h itbl-cpu.h cgen-desc.h
 
@@ -789,12 +791,14 @@ as_new_LDADD = $(TARG_CPU_O) $(OBJ_FORMAT_O) $(ATOF_TARG_O) \
 as_new_DEPENDENCIES = $(TARG_CPU_O) $(OBJ_FORMAT_O) $(ATOF_TARG_O) \
 	$(extra_objects) $(GASLIBS) $(LIBINTL_DEP)
 
+
+# The loongarch lexical analyzer and parser.
 EXTRA_as_new_SOURCES = $(CFILES) $(HFILES) $(TARGET_CPU_CFILES) \
 	$(TARGET_CPU_HFILES) $(TARGET_EXTRA_FILES) $(TARG_ENV_CFILES) \
 	$(OBJ_FORMAT_CFILES) $(OBJ_FORMAT_HFILES) \
 	$(CONFIG_ATOF_CFILES) $(MULTI_CFILES) config/m68k-parse.y \
 	config/bfin-parse.y config/bfin-lex.l config/rl78-parse.y \
-	config/rx-parse.y
+	config/rx-parse.y config/loongarch-parse.y
 EXPECT = expect
 RUNTEST = runtest
 RUNTESTFLAGS = 
@@ -939,6 +943,8 @@ config/tc-iq2000.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-lm32.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
+config/tc-loongarch.$(OBJEXT): config/$(am__dirstamp) \
+	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-m32c.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-m32r.$(OBJEXT): config/$(am__dirstamp) \
@@ -1085,6 +1091,8 @@ config/rl78-parse.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
 config/rx-parse.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
+config/loongarch-parse.$(OBJEXT): config/$(am__dirstamp) \
+	config/$(DEPDIR)/$(am__dirstamp)
 
 as-new$(EXEEXT): $(as_new_OBJECTS) $(as_new_DEPENDENCIES) $(EXTRA_as_new_DEPENDENCIES) 
 	@rm -f as-new$(EXEEXT)
@@ -1146,6 +1154,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/e-i386coff.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/e-i386elf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/e-mipself.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/loongarch-parse.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/m68k-parse.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/obj-aout.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/obj-coff.Po@am__quote@
@@ -1183,6 +1192,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-ip2k.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-iq2000.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-lm32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-loongarch.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-m32c.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-m32r.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-m68hc11.Po@am__quote@
@@ -1452,6 +1462,7 @@ maintainer-clean-generic:
 	@echo "it deletes files that may require special tools to rebuild."
 	-rm -f config/bfin-lex.c
 	-rm -f config/bfin-parse.c
+	-rm -f config/loongarch-parse.c
 	-rm -f config/m68k-parse.c
 	-rm -f config/rl78-parse.c
 	-rm -f config/rx-parse.c
@@ -1601,6 +1612,20 @@ config/rx-parse.c: $(srcdir)/config/rx-parse.y
 	$(SHELL) $(YLWRAP) $(srcdir)/config/rx-parse.y y.tab.c $@ y.tab.h config/rx-parse.h -- $(YACCCOMPILE) -d ;
 config/rx-parse.h: config/rx-parse.c
 	@true
+loongarch-parse.c: $(srcdir)/config/loongarch-parse.y
+	$(SHELL) $(YLWRAP) $(srcdir)/config/loongarch-parse.y y.tab.c loongarch-parse.c y.tab.h loongarch-parse.h -- $(YACCCOMPILE) -d ;
+loongarch-parse.h: loongarch-parse.c
+loongarch-parse.h: ; @true
+$(srcdir)/config/loongarch-parse.h: ; @true
+
+loongarch-lex.c: $(srcdir)/config/loongarch-lex.l
+	$(SHELL) $(YLWRAP) $(srcdir)/config/loongarch-lex.l lex.yy.c loongarch-lex.c -- $(LEXCOMPILE)
+loongarch-lex-wrapper.@OBJEXT@: $(srcdir)/config/loongarch-lex-wrapper.c loongarch-lex.c loongarch-parse.h
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $(srcdir)/config/loongarch-lex-wrapper.c $(NO_WERROR)
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='loongarch-lex-wrapper.c' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $(srcdir)/config/loongarch-lex-wrapper.c $(NO_WERROR)
 
 # The mips instruction table specification lexical analyzer and parser.
 
diff --git a/gas/config/loongarch-lex-wrapper.c b/gas/config/loongarch-lex-wrapper.c
new file mode 100644
index 00000000000..e11a3d1e844
--- /dev/null
+++ b/gas/config/loongarch-lex-wrapper.c
@@ -0,0 +1,20 @@
+/* Copyright (C) 2021-2021 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+
+#include "sysdep.h"
+#include "loongarch-lex.c"
diff --git a/gas/config/loongarch-lex.l b/gas/config/loongarch-lex.l
new file mode 100644
index 00000000000..3adda5eeec3
--- /dev/null
+++ b/gas/config/loongarch-lex.l
@@ -0,0 +1,55 @@
+%option noyywrap
+/*
+   Copyright (C) 2021-2021 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+%{
+#include "as.h"
+#include "loongarch-parse.h"
+%}
+
+D	[0-9]
+L	[a-zA-Z_\.\$]
+H	[0-9A-Fa-f]
+
+hex	0[xX]{H}+
+oct	0[0-7]+
+bin	0[bB][01]+
+dec	([1-9]{D}*)|0
+id	({D}+[fb])|({L}({D}|{L})*)|(:{dec}[bf])
+ws	[ \t\v\f]+
+
+%%
+
+{dec}	{ yylval.imm = strtoull (yytext, 0, 0); return INTEGER; }
+{hex}	{ yylval.imm = strtoull (yytext + 2, 0, 16); return INTEGER; }
+{bin}	{ yylval.imm = strtoull (yytext + 2, 0, 2); return INTEGER; }
+{oct}	{ yylval.imm = strtoull (yytext + 1, 0, 8); return INTEGER; }
+{id}	{ yylval.c_str = strdup (yytext);return IDENTIFIER; }
+{ws}	{ }
+
+">>"	{ return RIGHT_OP; }
+"<<"	{ return LEFT_OP; }
+"&&"	{ return AND_OP; }
+"||"	{ return OR_OP; }
+"<="	{ return LE_OP; }
+">="	{ return GE_OP; }
+"=="	{ return EQ_OP; }
+"!="	{ return NE_OP; }
+.	{ return yytext[0];}
+
+%%
diff --git a/gas/config/loongarch-parse.y b/gas/config/loongarch-parse.y
new file mode 100644
index 00000000000..561a152f778
--- /dev/null
+++ b/gas/config/loongarch-parse.y
@@ -0,0 +1,448 @@
+/*
+   Copyright (C) 2021-2021 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+%{
+#include "as.h"
+#include "loongarch-parse.h"
+static void yyerror (const char *s ATTRIBUTE_UNUSED){};
+extern int yylex (void);
+extern void yy_scan_string (const char *);
+extern void
+get_internal_label (expressionS *label_expr,
+		    unsigned long label,
+		    int augend);
+
+
+static struct reloc_info *top, *end;
+
+static expressionS const_0 =
+{
+  .X_op = O_constant,
+  .X_add_number = 0
+};
+
+static int
+is_const (struct reloc_info *info)
+{
+  return info->type == BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE
+	 && info->value.X_op == O_constant;
+}
+
+int
+loongarch_parse_expr (const char *expr,
+                      struct reloc_info *reloc_stack_top,
+                      size_t max_reloc_num,
+                      size_t *reloc_num,
+                      offsetT *imm);
+
+int
+loongarch_parse_expr (const char *expr,
+		      struct reloc_info *reloc_stack_top,
+		      size_t max_reloc_num,
+		      size_t *reloc_num,
+		      offsetT *imm)
+{
+  int ret;
+  top = reloc_stack_top;
+  end = top + max_reloc_num;
+  yy_scan_string (expr);
+  ret = yyparse ();
+  if (ret == 0)
+    {
+      if (is_const (top - 1))
+	*imm = (--top)->value.X_add_number;
+      else
+	*imm = 0;
+      *reloc_num = top - reloc_stack_top;
+    }
+  return ret;
+}
+
+static void
+emit_const (offsetT imm)
+{
+  if (end <= top)
+    as_fatal (_("expr too huge"));
+  top->type = BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE;
+  top->value.X_op = O_constant;
+  top->value.X_add_number = imm;
+  top++;
+}
+
+static const char *
+my_getExpression (expressionS *ep, const char *str)
+{
+  char *save_in, *ret;
+  if (*str == ':')
+    {
+      unsigned long j;
+      char *str_1 = (char *) str;
+      str_1++;
+      j = strtol (str_1, &str_1, 10);
+      get_internal_label (ep, j, *str_1 == 'f');
+      return NULL;
+    }
+  save_in = input_line_pointer;
+  input_line_pointer = (char *)str;
+  expression (ep);
+  ret = input_line_pointer;
+  input_line_pointer = save_in;
+  return ret;
+}
+
+static void
+reloc (const char *op_c_str, const char *id_c_str, offsetT addend)
+{
+  expressionS id_sym_expr;
+
+  if (end <= top)
+    as_fatal (_("expr too huge"));
+
+  if (id_c_str)
+    {
+      my_getExpression (&id_sym_expr, id_c_str);
+      id_sym_expr.X_add_number += addend;
+    }
+  else
+    {
+      id_sym_expr.X_op = O_constant;
+      id_sym_expr.X_add_number = addend;
+    }
+
+  if (strcmp (op_c_str, "abs") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE;
+      top++;
+    }
+  else if (strcmp (op_c_str, "pcrel") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_PCREL;
+      top++;
+    }
+  else if (strcmp (op_c_str, "gprel") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_GPREL;
+      top++;
+    }
+  else if (strcmp (op_c_str, "tprel") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_TLS_TPREL;
+      top++;
+    }
+  else if (strcmp (op_c_str, "tlsgot") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_TLS_GOT;
+      top++;
+    }
+  else if (strcmp (op_c_str, "tlsgd") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_TLS_GD;
+      top++;
+    }
+  else if (strcmp (op_c_str, "plt") == 0)
+    {
+      top->value = id_sym_expr;
+      top->type = BFD_RELOC_LARCH_SOP_PUSH_PLT_PCREL;
+      top++;
+    }
+  else
+    as_fatal (_("unknown reloc hint: %s"), op_c_str);
+}
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wimplicit-fallthrough="
+static void
+emit_unary (char op)
+{
+  struct reloc_info *s_top = top - 1;
+  if (is_const (s_top))
+    {
+      offsetT opr = s_top->value.X_add_number;
+      switch (op)
+	{
+	case '+':
+	  break;
+	case '-':
+	  opr = -opr;
+	  break;
+	case '~':
+	  opr = ~opr;
+	  break;
+	case '!':
+	  opr = !opr;
+	  break;
+	default:
+	  abort ();
+	}
+      s_top->value.X_add_number = opr;
+    }
+  else
+    {
+      if (end <= top)
+	as_fatal (_("expr too huge"));
+      switch (op)
+	{
+	case '!':
+	  top->type = BFD_RELOC_LARCH_SOP_NOT;
+	default:
+	  abort ();
+	}
+      top->value = const_0;
+      top++;
+    }
+}
+#pragma GCC diagnostic pop
+
+static void
+emit_bin (int op)
+{
+  struct reloc_info *last_1st = top - 1, *last_2nd = top - 2;
+  if (is_const (last_1st) && is_const (last_2nd))
+    {
+      offsetT opr1 = last_2nd->value.X_add_number;
+      offsetT opr2 = last_1st->value.X_add_number;
+      switch (op)
+	{
+	case '*':
+	  opr1 = opr1 * opr2;
+	  break;
+	case '/':
+	  opr1 = opr1 / opr2;
+	  break;
+	case '%':
+	  opr1 = opr1 % opr2;
+	  break;
+	case '+':
+	  opr1 = opr1 + opr2;
+	  break;
+	case '-':
+	  opr1 = opr1 - opr2;
+	  break;
+	case LEFT_OP:
+	  opr1 = opr1 << opr2;
+	  break;
+	case RIGHT_OP:
+	  /* Algorithm right shift  */
+	  opr1 = (offsetT)opr1 >> (offsetT)opr2;
+	  break;
+	case '<':
+	  opr1 = opr1 < opr2;
+	  break;
+	case '>':
+	  opr1 = opr1 > opr2;
+	  break;
+	case LE_OP:
+	  opr1 = opr1 <= opr2;
+	  break;
+	case GE_OP:
+	  opr1 = opr1 >= opr2;
+	  break;
+	case EQ_OP:
+	  opr1 = opr1 == opr2;
+	  break;
+	case NE_OP:
+	  opr1 = opr1 != opr2;
+	  break;
+	case '&':
+	  opr1 = opr1 & opr2;
+	  break;
+	case '^':
+	  opr1 = opr1 ^ opr2;
+	  break;
+	case '|':
+	  opr1 = opr1 | opr2;
+	  break;
+	case AND_OP:
+	  opr1 = opr1 && opr2;
+	  break;
+	case OR_OP:
+	  opr1 = opr1 || opr2;
+	  break;
+	default:
+	  abort ();
+	}
+      last_2nd->value.X_add_number = opr1;
+      last_1st->type = 0;
+      top--;
+    }
+  else
+    {
+      if (end <= top)
+	as_fatal (_("expr too huge"));
+      switch (op)
+	{
+	case '+':
+	  top->type = BFD_RELOC_LARCH_SOP_ADD;
+	  break;
+	case '-':
+	  top->type = BFD_RELOC_LARCH_SOP_SUB;
+	  break;
+	case LEFT_OP:
+	  top->type = BFD_RELOC_LARCH_SOP_SL;
+	  break;
+	case RIGHT_OP:
+	  top->type = BFD_RELOC_LARCH_SOP_SR;
+	  break;
+	case '&':
+	  top->type = BFD_RELOC_LARCH_SOP_AND;
+	  break;
+	default:
+	  abort ();
+	}
+      top->value = const_0;
+      top++;
+    }
+}
+
+static void
+emit_if_else (void)
+{
+  struct reloc_info *last_1st = top - 1;
+  struct reloc_info *last_2nd = top - 2;
+  struct reloc_info *last_3rd = top - 3;
+  if (is_const (last_1st) && is_const (last_2nd) && is_const (last_3rd))
+    {
+      offsetT opr1 = last_3rd->value.X_add_number;
+      offsetT opr2 = last_2nd->value.X_add_number;
+      offsetT opr3 = last_1st->value.X_add_number;
+      opr1 = opr1 ? opr2 : opr3;
+      last_3rd->value.X_add_number = opr1;
+      last_2nd->type = 0;
+      last_1st->type = 0;
+      top -= 2;
+    }
+  else
+    {
+      if (end <= top)
+	as_fatal (_("expr too huge"));
+      top->type = BFD_RELOC_LARCH_SOP_IF_ELSE;
+      top->value = const_0;
+      top++;
+    }
+}
+
+%}
+
+%union {
+char *c_str;
+offsetT imm;
+}
+
+%token <imm> INTEGER
+%token <c_str> IDENTIFIER
+%type <imm> addend
+
+%token LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP AND_OP OR_OP
+%start expression
+%%
+
+primary_expression
+	: INTEGER {emit_const ($1);}
+	| '(' expression ')'
+	| '%' IDENTIFIER '(' IDENTIFIER addend ')' {reloc ($2, $4, $5); free ($2); free ($4);}
+	| '%' IDENTIFIER '(' INTEGER addend ')' {reloc ($2, NULL, $4 + $5); free ($2);}
+	;
+
+addend
+	: addend '-' INTEGER {$$ -= $3;}
+	| addend '+' INTEGER {$$ += $3;}
+	| {$$ = 0;}
+	;
+
+unary_expression
+	: primary_expression
+	| '+' unary_expression {emit_unary ('+');}
+	| '-' unary_expression {emit_unary ('-');}
+	| '~' unary_expression {emit_unary ('~');}
+	| '!' unary_expression {emit_unary ('!');}
+	;
+
+multiplicative_expression
+	: unary_expression
+	| multiplicative_expression '*' unary_expression {emit_bin ('*');}
+	| multiplicative_expression '/' unary_expression {emit_bin ('/');}
+	| multiplicative_expression '%' unary_expression {emit_bin ('%');}
+	;
+
+additive_expression
+	: multiplicative_expression
+	| additive_expression '+' multiplicative_expression {emit_bin ('+');}
+	| additive_expression '-' multiplicative_expression {emit_bin ('-');}
+	;
+
+shift_expression
+	: additive_expression
+	| shift_expression LEFT_OP additive_expression {emit_bin (LEFT_OP);}
+	| shift_expression RIGHT_OP additive_expression {emit_bin (RIGHT_OP);}
+	;
+
+relational_expression
+	: shift_expression
+	| relational_expression '<' shift_expression {emit_bin ('<');}
+	| relational_expression '>' shift_expression {emit_bin ('>');}
+	| relational_expression LE_OP shift_expression {emit_bin (LE_OP);}
+	| relational_expression GE_OP shift_expression {emit_bin (GE_OP);}
+	;
+
+equality_expression
+	: relational_expression
+	| equality_expression EQ_OP relational_expression {emit_bin (EQ_OP);}
+	| equality_expression NE_OP relational_expression {emit_bin (NE_OP);}
+	;
+
+and_expression
+	: equality_expression
+	| and_expression '&' equality_expression {emit_bin ('&');}
+	;
+
+exclusive_or_expression
+	: and_expression
+	| exclusive_or_expression '^' and_expression {emit_bin ('^');}
+	;
+
+inclusive_or_expression
+	: exclusive_or_expression
+	| inclusive_or_expression '|' exclusive_or_expression {emit_bin ('|');}
+	;
+
+logical_and_expression
+	: inclusive_or_expression
+	| logical_and_expression AND_OP inclusive_or_expression {emit_bin (AND_OP);}
+	;
+
+logical_or_expression
+	: logical_and_expression
+	| logical_or_expression OR_OP logical_and_expression {emit_bin (OR_OP);}
+	;
+
+conditional_expression
+	: logical_or_expression
+	| logical_or_expression '?' expression ':' conditional_expression {emit_if_else ();}
+	;
+
+expression
+	: conditional_expression
+	;
+%%
+
diff --git a/gas/config/tc-loongarch.c b/gas/config/tc-loongarch.c
new file mode 100644
index 00000000000..1bcd392dffe
--- /dev/null
+++ b/gas/config/tc-loongarch.c
@@ -0,0 +1,1232 @@
+/* tc-loongarch.c -- Assemble for the Loongarch ISA
+
+   Copyright (C) 2021-2021 Free Software Foundation, Inc.
+   Contributed by Loongson Ltd.
+
+   This file is part of GAS.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the license, or
+   (at your option) any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+
+#include "as.h"
+#include "dw2gencfi.h"
+#include "elf/loongarch.h"
+#include "opcode/loongarch.h"
+#include "obj-elf.h"
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <assert.h>
+
+/* All information about an instruction during assemble */
+struct loongarch_cl_insn
+{
+  /* First split string */
+  const char *name;
+  const char *arg_strs[MAX_ARG_NUM_PLUS_2];
+  size_t arg_num;
+
+  /* Second analyze name_str and each actual args string to match the insn
+     in 'loongarch-opc.c'. And actual args may need be relocated.
+     We get length of insn. If 'insn_length == 0 && insn_mo->macro != NULL',
+     it's a macro insntruction and we call 'md_assemble' recursively
+     after expanding it.  */
+  int match_now;
+  int all_match;
+
+  const struct loongarch_opcode *insn;
+  size_t insn_length;
+
+  offsetT args[MAX_ARG_NUM_PLUS_2];
+  struct reloc_info reloc_info[MAX_RELOC_NUMBER_A_INSN];
+  size_t reloc_num;
+
+  /* For relax reserved. We not support relax now.
+     'insn_length < relax_max_length' means need to relax.
+     And 'insn_length == relax_max_length' means no need to relax. */
+  size_t relax_max_length;
+  relax_substateT subtype;
+
+  /* Then we get the binary representation of insn
+     and write it in to section. */
+  insn_t insn_bin;
+
+  /* The frag that contains the instruction.  */
+  struct frag *frag;
+  /* The offset into FRAG of the first instruction byte.  */
+  long where;
+  /* The relocs associated with the instruction, if any.  */
+  fixS *fixp[MAX_RELOC_NUMBER_A_INSN];
+};
+
+/* This array holds the chars that always start a comment.  If the
+   pre-processor is disabled, these aren't very useful */
+const char comment_chars[] = "#";
+
+/* This array holds the chars that only start a comment at the beginning of
+   a line.  If the line seems to have the form '# 123 filename'
+   .line and .file directives will appear in the pre-processed output */
+/* Note that input_file.c hand checks for '#' at the beginning of the
+   first line of the input file.  This is because the compiler outputs
+#NO_APP at the beginning of its output.  */
+/* Also note that C style comments are always supported.  */
+const char line_comment_chars[] = "#";
+
+/* This array holds machine specific line separator characters.  */
+const char line_separator_chars[] = ";";
+
+/* Chars that can be used to separate mant from exp in floating point nums */
+const char EXP_CHARS[] = "eE";
+
+/* Chars that mean this number is a floating point constant */
+/* As in 0f12.456 */
+/* or    0d1.2345e12 */
+const char FLT_CHARS[] = "rRsSfFdDxXpP";
+
+const char *md_shortopts = "O::g::G:";
+
+enum options
+{
+  OPTION_IGNORE = OPTION_MD_BASE,
+
+  OPTION_SOFT_FLOAT,
+  OPTION_HARD_FLOAT,
+  OPTION_ABI,
+
+  OPTION_LA_LOCAL_WITH_ABS,
+  OPTION_LA_GLOBAL_WITH_PCREL,
+  OPTION_LA_GLOBAL_WITH_ABS,
+
+  OPTION_END_OF_ENUM,
+};
+
+struct option md_longopts[] =
+{
+  { "msoft-float", no_argument, NULL, OPTION_SOFT_FLOAT },
+  { "mhard-float", no_argument, NULL, OPTION_HARD_FLOAT },
+  { "mabi", required_argument, NULL, OPTION_ABI },
+
+  { "mla-local-with-abs", no_argument, NULL, OPTION_LA_LOCAL_WITH_ABS },
+  { "mla-global-with-pcrel", no_argument, NULL, OPTION_LA_GLOBAL_WITH_PCREL },
+  { "mla-global-with-abs", no_argument, NULL, OPTION_LA_GLOBAL_WITH_ABS },
+
+  { NULL, no_argument, NULL, 0 }
+};
+
+size_t md_longopts_size = sizeof (md_longopts);
+
+int
+md_parse_option (int c, const char *arg)
+{
+  int ret = 1;
+  switch (c)
+    {
+    case OPTION_SOFT_FLOAT:
+      LARCH_opts.ase_float = 0;
+      break;
+    case OPTION_HARD_FLOAT:
+      LARCH_opts.ase_float = 1;
+      break;
+    case OPTION_ABI:
+      if (strcasecmp (arg, "lp64") == 0)
+        LARCH_opts.abi_is_lp64 = 1;
+      else if (strcasecmp (arg, "lp32") == 0)
+        LARCH_opts.abi_is_lp32 = 1;
+      else
+        ret = 0;
+      break;
+    case OPTION_LA_LOCAL_WITH_ABS:
+      LARCH_opts.la_local_with_abs = 1;
+      break;
+    case OPTION_LA_GLOBAL_WITH_PCREL:
+      LARCH_opts.la_global_with_pcrel = 1;
+      break;
+    case OPTION_LA_GLOBAL_WITH_ABS:
+      LARCH_opts.la_global_with_abs = 1;
+      break;
+    case OPTION_IGNORE:
+      break;
+    }
+  return ret;
+}
+
+static struct htab *r_htab = NULL;
+static struct htab *f_htab = NULL;
+static struct htab *c_htab = NULL;
+static struct htab *cr_htab = NULL;
+static struct htab *v_htab = NULL;
+static struct htab *x_htab = NULL;
+
+void
+loongarch_after_parse_args ()
+{
+  size_t i;
+
+  LARCH_opts.ase_test = 1;
+  LARCH_opts.ase_fix = 1;
+  LARCH_opts.ase_float = 1;
+  LARCH_opts.ase_128vec = 1;
+  LARCH_opts.ase_256vec = 1;
+
+  if (!r_htab)
+    r_htab = str_htab_create (), str_hash_insert (r_htab, "", 0, 0);
+  if (!f_htab)
+    f_htab = str_htab_create (), str_hash_insert (f_htab, "", 0, 0);
+  if (!c_htab)
+    c_htab = str_htab_create (), str_hash_insert (c_htab, "", 0, 0);
+  if (!cr_htab)
+    cr_htab = str_htab_create (), str_hash_insert (cr_htab, "", 0, 0);
+  if (!v_htab)
+    v_htab = str_htab_create (), str_hash_insert (v_htab, "", 0, 0);
+  if (!x_htab)
+    x_htab = str_htab_create (), str_hash_insert (x_htab, "", 0, 0);
+
+  for (i = 0; i < ARRAY_SIZE (loongarch_r_normal_name); i++)
+    str_hash_insert (r_htab, loongarch_r_normal_name[i], (void *) (i + 1), 0);
+  for (i = 0; i < ARRAY_SIZE (loongarch_f_normal_name); i++)
+    str_hash_insert (f_htab, loongarch_f_normal_name[i], (void *) (i + 1), 0);
+  for (i = 0; i < ARRAY_SIZE (loongarch_c_normal_name); i++)
+    str_hash_insert (c_htab, loongarch_c_normal_name[i], (void *) (i + 1), 0);
+  for (i = 0; i < ARRAY_SIZE (loongarch_cr_normal_name); i++)
+    str_hash_insert (cr_htab, loongarch_cr_normal_name[i], (void *) (i + 1),
+                     0);
+  for (i = 0; i < ARRAY_SIZE (loongarch_v_normal_name); i++)
+    str_hash_insert (v_htab, loongarch_v_normal_name[i], (void *) (i + 1), 0);
+  for (i = 0; i < ARRAY_SIZE (loongarch_x_normal_name); i++)
+    str_hash_insert (x_htab, loongarch_x_normal_name[i], (void *) (i + 1), 0);
+
+  if (LARCH_opts.abi_is_lp64 + LARCH_opts.abi_is_lp32 == 0)
+    {
+      /* as_warn (_("default LARCH ABI is lp64")); */
+      LARCH_opts.abi_is_lp64 = 1;
+    }
+
+  if (1 < LARCH_opts.abi_is_lp64 + LARCH_opts.abi_is_lp32)
+    as_fatal (_ ("we can specify only ONE abi"));
+
+  if (LARCH_opts.abi_is_lp64)
+    {
+      LARCH_opts.addrwidth_is_64 = 1;
+      LARCH_opts.rlen_is_64 = 1;
+      for (i = 0; i < ARRAY_SIZE (loongarch_r_lp64_name); i++)
+        str_hash_insert (r_htab, loongarch_r_lp64_name[i], (void *) (i + 1),
+                         0);
+      for (i = 0; i < ARRAY_SIZE (loongarch_r_lp64_name1); i++)
+        str_hash_insert (r_htab, loongarch_r_lp64_name1[i], (void *) (i + 1),
+                         0);
+      for (i = 0; i < ARRAY_SIZE (loongarch_f_lp64_name); i++)
+        str_hash_insert (f_htab, loongarch_f_lp64_name[i], (void *) (i + 1),
+                         0);
+      for (i = 0; i < ARRAY_SIZE (loongarch_f_lp64_name1); i++)
+        str_hash_insert (f_htab, loongarch_f_lp64_name1[i], (void *) (i + 1),
+                         0);
+    }
+
+  if (LARCH_opts.abi_is_lp32)
+    {
+      LARCH_opts.addrwidth_is_32 = 1;
+      LARCH_opts.rlen_is_32 = 1;
+    }
+}
+
+const char *
+loongarch_target_format ()
+{
+  return LARCH_opts.addrwidth_is_32 ? "elf32-loongarch" : "elf64-loongarch";
+}
+
+void
+md_begin ()
+{
+  if (LARCH_opts.ase_test)
+    {
+      const struct loongarch_opcode *it;
+      struct loongarch_ase *ase;
+      for (ase = loongarch_ASEs; ase->enabled; ase++)
+        for (it = ase->opcodes; it->name; it++)
+          {
+            if (loongarch_check_format (it->format) != 0)
+              as_fatal (_ ("insn name: %s\tformat: %s\tsyntax error"),
+                        it->name, it->format);
+            if (it->mask == 0 && it->macro == 0)
+              as_fatal (_ ("insn name: %s\nformat: %s\nwe want macro but "
+                           "macro is NULL"),
+                        it->name, it->format);
+            if (it->macro &&
+                loongarch_check_macro (it->format, it->macro) != 0)
+              as_fatal (
+                _ ("insn name: %s\nformat: %s\nmacro: %s\tsyntax error"),
+                it->name, it->format, it->macro);
+          }
+    }
+
+  /* FIXME: expressionS use 'offsetT' as constant, we want this is 64-bit type */
+  assert (8 <= sizeof (offsetT));
+}
+
+void
+md_operand (expressionS *e)
+{
+  /* Because we use 'expression' to check if a actual arg is a expr at first.
+     If not, we want a returning. */
+  if (e->X_op == O_absent)
+    e->X_op = O_illegal;
+}
+
+static const expressionS const_0 = { .X_op = O_constant, .X_add_number = 0 };
+
+static const char *
+my_getExpression (expressionS *ep, const char *str)
+{
+  char *save_in, *ret;
+  save_in = input_line_pointer;
+  input_line_pointer = (char *) str;
+  expression (ep);
+  ret = input_line_pointer;
+  input_line_pointer = save_in;
+  return ret;
+}
+
+static void
+s_loongarch_align (int arg)
+{
+  const char *t = input_line_pointer;
+  while (!is_end_of_line[(unsigned char) *t] && *t != ',')
+    ++t;
+  if (*t == ',')
+    s_align_ptwo (arg);
+  else
+    s_align_ptwo (0);
+}
+
+/* Handle the .dtprelword and .dtpreldword pseudo-ops.  They generate
+   a 32-bit or 64-bit DTP-relative relocation (BYTES says which) for
+   use in DWARF debug information.  */
+
+static void
+s_dtprel (int bytes)
+{
+  expressionS ex;
+  char *p;
+
+  expression (&ex);
+
+  if (ex.X_op != O_symbol)
+    {
+      as_bad (_ ("Unsupported use of %s"),
+              (bytes == 8 ? ".dtpreldword" : ".dtprelword"));
+      ignore_rest_of_line ();
+    }
+
+  p = frag_more (bytes);
+  md_number_to_chars (p, 0, bytes);
+  fix_new_exp (frag_now, p - frag_now->fr_literal, bytes, &ex, FALSE,
+               (bytes == 8 ? BFD_RELOC_LARCH_TLS_DTPREL64
+                           : BFD_RELOC_LARCH_TLS_DTPREL32));
+
+  demand_empty_rest_of_line ();
+}
+
+static const pseudo_typeS loongarch_pseudo_table[] = 
+{
+  { "align", s_loongarch_align, -4 },
+  { "dword", cons, 8 },
+  { "word", cons, 4 },
+  { "half", cons, 2 },
+  { "dtprelword", s_dtprel, 4 },
+  { "dtpreldword", s_dtprel, 8 },
+  { NULL, NULL, 0 },
+};
+
+void
+loongarch_pop_insert (void)
+{
+  pop_insert (loongarch_pseudo_table);
+}
+
+#define INTERNAL_LABEL_SPECIAL 10
+static unsigned long internal_label_count[INTERNAL_LABEL_SPECIAL] = { 0 };
+
+static const char *
+loongarch_internal_label_name (unsigned long label, int augend)
+{
+  static char symbol_name_build[24];
+  unsigned long want_label;
+  char *p;
+
+  want_label = internal_label_count[label] + augend;
+
+  p = symbol_name_build;
+#ifdef LOCAL_LABEL_PREFIX
+  *p++ = LOCAL_LABEL_PREFIX;
+#endif
+  *p++ = 'L';
+  for (; label; label /= 10)
+    *p++ = label % 10 + '0';
+  /* make sure internal label never belong to normal label namespace */
+  *p++ = ':';
+  for (; want_label; want_label /= 10)
+    *p++ = want_label % 10 + '0';
+  *p++ = '\0';
+  return symbol_name_build;
+}
+
+static void
+setup_internal_label_here (unsigned long label)
+{
+  assert (label < INTERNAL_LABEL_SPECIAL);
+  internal_label_count[label]++;
+  colon (loongarch_internal_label_name (label, 0));
+}
+
+extern void /* no static. used by 'loongarch-parse.y' */
+get_internal_label (expressionS *label_expr, unsigned long label,
+                    int augend /* 0 for previous, 1 for next */);
+
+void
+get_internal_label (expressionS *label_expr, unsigned long label,
+                    int augend /* 0 for previous, 1 for next */)
+{
+  assert (label < INTERNAL_LABEL_SPECIAL);
+  if (augend == 0 && internal_label_count[label] == 0)
+    as_fatal (_ ("internal error: we have no internal label yet"));
+  label_expr->X_op = O_symbol;
+  label_expr->X_add_symbol =
+    symbol_find_or_make (loongarch_internal_label_name (label, augend));
+  label_expr->X_add_number = 0;
+}
+
+extern int loongarch_parse_expr (const char *expr,
+                                 struct reloc_info *reloc_stack_top,
+                                 size_t max_reloc_num, size_t *reloc_num,
+                                 offsetT *imm_if_no_reloc);
+
+static int32_t
+loongarch_args_parser_can_match_arg_helper (char esc_ch1, char esc_ch2,
+                                            const char *bit_field,
+                                            const char *arg, void *context)
+{
+  struct loongarch_cl_insn *ip = context;
+  offsetT imm, ret = 0;
+  size_t reloc_num_we_have = MAX_RELOC_NUMBER_A_INSN - ip->reloc_num;
+  size_t reloc_num = 0;
+
+  if (!ip->match_now)
+    return 0;
+
+  switch (esc_ch1)
+    {
+    case 'l':
+      switch (esc_ch2)
+        {
+        default:
+          ip->match_now = is_label (arg);
+          if (!ip->match_now && is_label_with_addend (arg))
+            as_fatal (_ ("This label shouldn't be with addend."));
+          break;
+        case 'a':
+          ip->match_now = is_label_with_addend (arg);
+          break;
+        }
+      break;
+    case 's':
+    case 'u':
+      ip->match_now =
+        loongarch_parse_expr (arg, ip->reloc_info + ip->reloc_num,
+                              reloc_num_we_have, &reloc_num, &imm) == 0;
+
+      if (!ip->match_now)
+        break;
+
+      if (esc_ch1 == 's')
+        switch (esc_ch2)
+          {
+          case 'c':
+            ip->match_now = reloc_num == 0;
+            break;
+          }
+      else
+        switch (esc_ch2)
+          {
+          case 'c':
+            ip->match_now = reloc_num == 0 && 0 <= imm;
+            break;
+          }
+
+      if (!ip->match_now)
+        break;
+
+      ret = imm;
+      if (reloc_num)
+        {
+          bfd_reloc_code_real_type reloc_type = BFD_RELOC_NONE;
+          reloc_num_we_have -= reloc_num;
+          if (reloc_num_we_have == 0)
+            as_fatal (_ ("expr too huge") /* want one more reloc */);
+          if (esc_ch1 == 'u')
+            {
+              if (strncmp (bit_field, "10:12", strlen ("10:12")) == 0)
+                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_U_10_12;
+            }
+          else if (esc_ch1 == 's')
+            {
+              if (strncmp (bit_field, "10:16<<2", strlen ("10:16<<2")) == 0)
+                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2;
+              else if (strncmp (bit_field, "0:5|10:16<<2",
+                                strlen ("0:5|10:16<<2")) == 0)
+                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2;
+              else if (strncmp (bit_field, "0:10|10:16<<2",
+                                strlen ("0:10|10:16<<2")) == 0)
+                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2;
+              else if (strncmp (bit_field, "10:12", strlen ("10:12")) == 0)
+                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_12;
+              else if (strncmp (bit_field, "5:20", strlen ("5:20")) == 0)
+                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_5_20;
+              else if (strncmp (bit_field, "10:16", strlen ("10:16")) == 0)
+                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_16;
+              else if (strncmp (bit_field, "10:5", strlen ("10:5")) == 0)
+                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_5;
+            }
+          if (reloc_type == BFD_RELOC_NONE)
+            as_fatal (
+              _ ("not support reloc bit-field\nfmt: %c%c %s\nargs: %s"),
+              esc_ch1, esc_ch2, bit_field, arg);
+          reloc_num++;
+          ip->reloc_num += reloc_num;
+          ip->reloc_info[ip->reloc_num - 1].type = reloc_type;
+          ip->reloc_info[ip->reloc_num - 1].value = const_0;
+        }
+      break;
+    case 'r':
+      imm = (offsetT) str_hash_find (r_htab, arg);
+      ip->match_now = 0 < imm;
+      ret = imm - 1;
+      break;
+    case 'f':
+      imm = (offsetT) str_hash_find (f_htab, arg);
+      ip->match_now = 0 < imm;
+      ret = imm - 1;
+      break;
+    case 'c':
+      switch (esc_ch2)
+        {
+        case 'r':
+          imm = (offsetT) str_hash_find (cr_htab, arg);
+          break;
+        default:
+          imm = (offsetT) str_hash_find (c_htab, arg);
+        }
+      ip->match_now = 0 < imm;
+      ret = imm - 1;
+      break;
+    case 'v':
+      imm = (offsetT) str_hash_find (v_htab, arg);
+      ip->match_now = 0 < imm;
+      ret = imm - 1;
+      break;
+    case 'x':
+      imm = (offsetT) str_hash_find (x_htab, arg);
+      ip->match_now = 0 < imm;
+      ret = imm - 1;
+      break;
+    case '\0':
+      ip->all_match = ip->match_now;
+      ip->insn_length =
+        ip->insn->mask ? loongarch_insn_length (ip->insn->match) : 0;
+      /* FIXME: now we have no relax insn */
+      ip->relax_max_length = ip->insn_length;
+      break;
+    default:
+      as_fatal (_ ("unknown escape"));
+    }
+
+  do
+    {
+      /* check imm overflow */
+      int bit_width, bits_needed_s, bits_needed_u;
+      char *t;
+
+      if (!ip->match_now)
+        break;
+
+      if (0 < reloc_num)
+        break;
+
+      bit_width = loongarch_get_bit_field_width (bit_field, &t);
+
+      if (bit_width == -1)
+        /* no specify bit width */
+        break;
+
+      imm = ret;
+      if (t[0] == '<' && t[1] == '<')
+        {
+          int i = strtol (t += 2, &t, 10), j;
+          for (j = i; 0 < j; j--, imm >>= 1)
+            if (imm & 1)
+              as_fatal (_ ("require imm low %d bit is 0."), i);
+        }
+
+      if (*t == '+')
+        imm -= strtol (t, &t, 10);
+
+      bits_needed_s = loongarch_bits_imm_needed (imm, 1);
+      bits_needed_u = loongarch_bits_imm_needed (imm, 0);
+
+      if ((esc_ch1 == 's' && bit_width < bits_needed_s) ||
+          (esc_ch1 != 's' && bit_width < bits_needed_u))
+        /* how to do after we detect overflow */
+        as_fatal (_ ("Immediate overflow.\n"
+                     "format: %c%c%s\n"
+                     "arg: %s"),
+                  esc_ch1, esc_ch2, bit_field, arg);
+    }
+  while (0);
+
+  if (esc_ch1 != '\0')
+    {
+      ip->args[ip->arg_num] = ret;
+      ip->arg_num++;
+    }
+  return ret;
+}
+
+static void
+get_loongarch_opcode (struct loongarch_cl_insn *insn)
+{
+  const struct loongarch_opcode *it;
+  struct loongarch_ase *ase;
+  for (ase = loongarch_ASEs; ase->enabled; ase++)
+    {
+      if (!*ase->enabled || (ase->include && !*ase->include) ||
+          (ase->exclude && *ase->exclude))
+        continue;
+
+      if (!ase->name_hash_entry)
+        {
+          ase->name_hash_entry = str_htab_create ();
+          for (it = ase->opcodes; it->name; it++)
+            str_hash_insert (ase->name_hash_entry, it->name, (void *) it, 0);
+        }
+
+      if ((it = str_hash_find (ase->name_hash_entry, insn->name)) == NULL)
+        continue;
+
+      do
+        {
+          insn->insn = it;
+          insn->match_now = 1;
+          insn->all_match = 0;
+          insn->arg_num = 0;
+          insn->reloc_num = 0;
+          insn->insn_bin = loongarch_foreach_args (
+            it->format, insn->arg_strs,
+            loongarch_args_parser_can_match_arg_helper, insn);
+          if (insn->all_match && !(it->include && !*it->include) &&
+              !(it->exclude && *it->exclude))
+            {
+              insn->insn_bin |= it->match;
+              return;
+            }
+          it++;
+        }
+      while (it->name && strcasecmp (it->name, insn->name) == 0);
+    }
+}
+
+static int
+check_this_insn_before_appending (struct loongarch_cl_insn *ip)
+{
+  int ret = 0;
+  if (strcmp (ip->name, "la.abs") == 0)
+    {
+      ip->reloc_info[ip->reloc_num].type = BFD_RELOC_LARCH_MARK_LA;
+      my_getExpression (&ip->reloc_info[ip->reloc_num].value, ip->arg_strs[1]);
+      ip->reloc_num++;
+    }
+  else if (ip->insn->mask == 0xffff8000 &&
+           ((ip->insn_bin & 0xfff00000) == 0x38600000 ||
+            (ip->insn_bin & 0xffff0000) == 0x38700000 ||
+            (ip->insn_bin & 0xffff0000) == 0x38710000))
+    {
+      /* for AMO insn amswap.[wd], amadd.[wd], etc. */
+      if (ip->args[0] != 0 &&
+          (ip->args[0] == ip->args[1] || ip->args[0] == ip->args[2]))
+        as_fatal (
+          _ ("AMO insns require rd != base && rd != rt when rd isn't $r0"));
+    }
+  else if ((ip->insn->mask == 0xffe08000 &&
+            (ip->insn_bin & 0xffe00000) == 0x00600000) ||
+           (ip->insn->mask == 0xffc00000 &&
+            (ip->insn_bin & 0xff800000) == 0x00800000))
+    {
+      /* for bstr(ins|pick).[wd] */
+      if (ip->args[2] < ip->args[3])
+        as_fatal (_ ("bstr(ins|pick).[wd] require msbd >= lsbd"));
+    }
+  else if (ip->insn->mask != 0 && (ip->insn_bin & 0xfe0003c0) == 0x04000000 &&
+           (strcmp ("csrxchg", ip->name) == 0 ||
+            strcmp ("gcsrxchg", ip->name) == 0))
+    as_fatal (_ ("g?csrxchg require rj != $r0 && rj != $r1"));
+
+  return ret;
+}
+
+static void
+install_insn (const struct loongarch_cl_insn *insn)
+{
+  char *f = insn->frag->fr_literal + insn->where;
+  if (0 < insn->insn_length)
+    md_number_to_chars (f, insn->insn_bin, insn->insn_length);
+}
+
+static void
+move_insn (struct loongarch_cl_insn *insn, fragS *frag, long where)
+{
+  size_t i;
+  insn->frag = frag;
+  insn->where = where;
+  for (i = 0; i < insn->reloc_num; i++)
+    {
+      insn->fixp[i]->fx_frag = frag;
+      insn->fixp[i]->fx_where = where;
+    }
+  install_insn (insn);
+}
+
+/* Add INSN to the end of the output.  */
+static void
+append_fixed_insn (struct loongarch_cl_insn *insn)
+{
+  char *f = frag_more (insn->insn_length);
+  move_insn (insn, frag_now, f - frag_now->fr_literal);
+}
+
+static void
+append_fixp_and_insn (struct loongarch_cl_insn *ip)
+{
+  reloc_howto_type *howto;
+  bfd_reloc_code_real_type reloc_type;
+  struct reloc_info *reloc_info = ip->reloc_info;
+  size_t i;
+  for (i = 0; i < ip->reloc_num; i++)
+    {
+      reloc_type = reloc_info[i].type;
+      howto = bfd_reloc_type_lookup (stdoutput, reloc_type);
+      if (howto == NULL)
+        as_fatal (_ ("no HOWTO loong relocation number %d"), reloc_type);
+
+      ip->fixp[i] =
+        fix_new_exp (ip->frag, ip->where, bfd_get_reloc_size (howto),
+                     &reloc_info[i].value, FALSE, reloc_type);
+    }
+
+  if (ip->insn_length < ip->relax_max_length)
+    as_fatal (_ ("Internal error: not support relax now"));
+  else
+    append_fixed_insn (ip);
+  dwarf2_emit_insn (0);
+}
+
+/* ask helper for returning a malloced c_str or NULL */
+static char *
+assember_macro_helper (const char *const args[], void *context_ptr)
+{
+  struct loongarch_cl_insn *insn = context_ptr;
+  char *ret = NULL;
+  if ( strcmp (insn->name, "li.w") == 0 || strcmp (insn->name, "li.d") == 0)
+    {
+      char args_buf[50], insns_buf[200];
+      const char *arg_strs[6];
+      uint32_t hi32, lo32;
+
+      /* We pay attention to sign extend beacause it is chance of reduce insn.
+         The exception is 12-bit and hi-12-bit unsigned,
+	 we need a 'ori' or a 'lu52i.d' accordingly. */
+      char all0_bit_vec, sign_bit_vec, allf_bit_vec, paritial_is_sext_of_prev;
+
+      lo32 = insn->args[1] & 0xffffffff;
+      hi32 = insn->args[1] >> 32;
+
+      if (strcmp (insn->name, "li.w") == 0)
+        {
+          if (hi32 != 0 && hi32 != 0xffffffff)
+            as_fatal (_ ("li overflow: hi32:0x%x lo32:0x%x"), hi32, lo32);
+          hi32 = lo32 & 0x80000000 ? 0xffffffff : 0;
+        }
+
+      if (strcmp (insn->name, "li.d") == 0 && LARCH_opts.rlen_is_32)
+        as_fatal (_ ("we can't li.d on 32bit-arch"));
+
+      snprintf (args_buf, sizeof (args_buf), "0x%x,0x%x,0x%x,0x%x,%s",
+                (hi32 >> 20) & 0xfff, hi32 & 0xfffff, (lo32 >> 12) & 0xfffff,
+                lo32 & 0xfff, args[0]);
+      loongarch_split_args_by_comma (args_buf, arg_strs);
+
+      all0_bit_vec =
+        (((hi32 & 0xfff00000) == 0) << 3) | (((hi32 & 0x000fffff) == 0) << 2) |
+        (((lo32 & 0xfffff000) == 0) << 1) | ((lo32 & 0x00000fff) == 0);
+      sign_bit_vec =
+        (((hi32 & 0x80000000) != 0) << 3) | (((hi32 & 0x00080000) != 0) << 2) |
+        (((lo32 & 0x80000000) != 0) << 1) | ((lo32 & 0x00000800) != 0);
+      allf_bit_vec = (((hi32 & 0xfff00000) == 0xfff00000) << 3) |
+                     (((hi32 & 0x000fffff) == 0x000fffff) << 2) |
+                     (((lo32 & 0xfffff000) == 0xfffff000) << 1) |
+                     ((lo32 & 0x00000fff) == 0x00000fff);
+      paritial_is_sext_of_prev =
+        (all0_bit_vec ^ allf_bit_vec) & (all0_bit_vec ^ (sign_bit_vec << 1));
+
+      static const char *const li_32bit[] =
+      {
+        "lu12i.w %5,%3&0x80000?%3-0x100000:%3;ori %5,%5,%4;",
+        "lu12i.w %5,%3&0x80000?%3-0x100000:%3;",
+        "addi.w %5,$r0,%4&0x800?%4-0x1000:%4;",
+        "or %5,$r0,$r0;",
+      };
+      static const char *const li_hi_32bit[] =
+      {
+        "lu32i.d %5,%2&0x80000?%2-0x100000:%2;"
+        "lu52i.d %5,%5,%1&0x800?%1-0x1000:%1;",
+        "lu52i.d %5,%5,%1&0x800?%1-0x1000:%1;",
+        "lu32i.d %5,%2&0x80000?%2-0x100000:%2;",
+        "",
+      };
+      do
+        {
+          insns_buf[0] = '\0';
+          if (paritial_is_sext_of_prev == 0x7)
+            {
+              strcat (insns_buf, "lu52i.d %5,$r0,%1&0x800?%1-0x1000:%1;");
+              break;
+            }
+          if ((all0_bit_vec & 0x3) == 0x2)
+            strcat (insns_buf, "ori %5,$r0,%4;");
+          else
+            strcat (insns_buf, li_32bit[paritial_is_sext_of_prev & 0x3]);
+          strcat (insns_buf, li_hi_32bit[paritial_is_sext_of_prev >> 2]);
+        }
+      while (0);
+
+      ret = loongarch_expand_macro (insns_buf, arg_strs, NULL, NULL);
+    }
+  return ret;
+}
+
+/* accept instructions separated by ';'
+* assuming 'not starting with space and not ending with space' or pass in empty c_str */
+static void
+loongarch_assemble_INSNs (char *str)
+{
+  char *rest;
+
+  for (rest = str; *rest != ';' && *rest != '\0'; rest++);
+  if (*rest == ';')
+    *rest++ = '\0';
+
+  if (*str == ':')
+    {
+      str++;
+      setup_internal_label_here (strtol (str, &str, 10));
+      str++;
+    }
+
+  do
+    {
+      if (*str == '\0')
+        break;
+
+      struct loongarch_cl_insn the_one = { 0 };
+      the_one.name = str;
+
+      for (; *str && *str != ' '; str++)
+        ;
+      if (*str == ' ')
+        *str++ = '\0';
+
+      loongarch_split_args_by_comma (str, the_one.arg_strs);
+      get_loongarch_opcode (&the_one);
+
+      if (!the_one.all_match)
+        as_fatal (_ ("no match insn: %s\t%s"), the_one.name,
+                  loongarch_cat_splited_strs (the_one.arg_strs));
+
+      if (check_this_insn_before_appending (&the_one) != 0)
+        break;
+
+      append_fixp_and_insn (&the_one);
+      if (the_one.insn_length == 0 && the_one.insn->macro)
+        {
+          char *c_str =
+            loongarch_expand_macro (the_one.insn->macro, the_one.arg_strs,
+                                    assember_macro_helper, &the_one);
+          loongarch_assemble_INSNs (c_str);
+          free (c_str);
+        }
+    }
+  while (0);
+
+  if (*rest != '\0')
+    loongarch_assemble_INSNs (rest);
+}
+
+void
+md_assemble (char *str)
+{
+  loongarch_assemble_INSNs (str);
+}
+
+const char *
+md_atof (int type, char *litP, int *sizeP)
+{
+  return ieee_md_atof (type, litP, sizeP, FALSE);
+}
+
+void
+md_number_to_chars (char *buf, valueT val, int n)
+{
+  number_to_chars_littleendian (buf, val, n);
+}
+
+/* The location from which a PC relative jump should be calculated,
+   given a PC relative reloc.  */
+long
+md_pcrel_from (fixS *fixP ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wimplicit-fallthrough="
+void
+md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
+{
+  static int64_t stack_top;
+  static int last_reloc_is_sop_push_pcrel_1 = 0;
+  int last_reloc_is_sop_push_pcrel = last_reloc_is_sop_push_pcrel_1;
+  insn_t insn;
+  last_reloc_is_sop_push_pcrel_1 = 0;
+
+  char *buf = fixP->fx_frag->fr_literal + fixP->fx_where;
+  switch (fixP->fx_r_type)
+    {
+    case BFD_RELOC_LARCH_SOP_PUSH_TLS_TPREL:
+    case BFD_RELOC_LARCH_SOP_PUSH_TLS_GD:
+    case BFD_RELOC_LARCH_SOP_PUSH_TLS_GOT:
+      if (fixP->fx_addsy)
+        S_SET_THREAD_LOCAL (fixP->fx_addsy);
+    case BFD_RELOC_LARCH_SOP_PUSH_PCREL:
+    case BFD_RELOC_LARCH_SOP_PUSH_PLT_PCREL:
+      if (fixP->fx_addsy == NULL)
+        as_bad_where (fixP->fx_file, fixP->fx_line,
+                      _ ("Relocation against a constant"));
+      if (fixP->fx_r_type == BFD_RELOC_LARCH_SOP_PUSH_PCREL)
+        {
+          last_reloc_is_sop_push_pcrel_1 = 1;
+          if (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+            stack_top = S_GET_VALUE (fixP->fx_addsy) + fixP->fx_offset -
+                        (fixP->fx_where + fixP->fx_frag->fr_address);
+          else
+            stack_top = 0;
+        }
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_10_5:
+      if (!last_reloc_is_sop_push_pcrel)
+        break;
+      if ((stack_top & ~(uint64_t) 0xf) != 0x0 &&
+          (stack_top & ~(uint64_t) 0xf) != ~(uint64_t) 0xf)
+        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & (~(uint32_t) 0x7c00)) | ((stack_top & 0x1f) << 10);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_U_10_12:
+      if (!last_reloc_is_sop_push_pcrel)
+        break;
+      if (stack_top & ~(uint64_t) 0xfff)
+        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & (~(uint32_t) 0x3ffc00)) | ((stack_top & 0xfff) << 10);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_10_12:
+      if (!last_reloc_is_sop_push_pcrel)
+        break;
+      if ((stack_top & ~(uint64_t) 0x7ff) != 0x0 &&
+          (stack_top & ~(uint64_t) 0x7ff) != ~(uint64_t) 0x7ff)
+        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & (~(uint32_t) 0x3ffc00)) | ((stack_top & 0xfff) << 10);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_10_16:
+      if (!last_reloc_is_sop_push_pcrel)
+        break;
+      if ((stack_top & ~(uint64_t) 0x7fff) != 0x0 &&
+          (stack_top & ~(uint64_t) 0x7fff) != ~(uint64_t) 0x7fff)
+        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & 0xfc0003ff) | ((stack_top & 0xffff) << 10);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2:
+      if (!last_reloc_is_sop_push_pcrel)
+        break;
+      if ((stack_top & 0x3) != 0)
+        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      stack_top >>= 2;
+      if ((stack_top & ~(uint64_t) 0x7fff) != 0x0 &&
+          (stack_top & ~(uint64_t) 0x7fff) != ~(uint64_t) 0x7fff)
+        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & 0xfc0003ff) | ((stack_top & 0xffff) << 10);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2:
+      if (!last_reloc_is_sop_push_pcrel)
+        break;
+      if ((stack_top & 0x3) != 0)
+        break;
+      stack_top >>= 2;
+      if ((stack_top & ~(uint64_t) 0xfffff) != 0x0 &&
+          (stack_top & ~(uint64_t) 0xfffff) != ~(uint64_t) 0xfffff)
+        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & 0xfc0003e0) | ((stack_top & 0xffff) << 10) |
+             ((stack_top & 0x1f0000) >> 16);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_5_20:
+      if (!last_reloc_is_sop_push_pcrel)
+        break;
+      if ((stack_top & ~(uint64_t) 0x7ffff) != 0x0 &&
+          (stack_top & ~(uint64_t) 0x7ffff) != ~(uint64_t) 0x7ffff)
+        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & (~(uint32_t) 0x1ffffe0)) | ((stack_top & 0xfffff) << 5);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2:
+      if (!last_reloc_is_sop_push_pcrel)
+        break;
+      if ((stack_top & 0x3) != 0)
+        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      stack_top >>= 2;
+      if ((stack_top & ~(uint64_t) 0x1ffffff) != 0x0 &&
+          (stack_top & ~(uint64_t) 0x1ffffff) != ~(uint64_t) 0x1ffffff)
+        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      insn = bfd_getl32 (buf);
+      insn = (insn & 0xfc000000) | ((stack_top & 0xffff) << 10) |
+             ((stack_top & 0x3ff0000) >> 16);
+      bfd_putl32 (insn, buf);
+      break;
+
+    case BFD_RELOC_LARCH_SOP_POP_32_U:
+      if (!last_reloc_is_sop_push_pcrel)
+        break;
+      if (stack_top & ~(uint64_t) 0xffffffff)
+        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      bfd_putl32 (stack_top, buf);
+      break;
+
+    case BFD_RELOC_64:
+    case BFD_RELOC_32:
+      if (fixP->fx_subsy)
+        {
+        case BFD_RELOC_24:
+        case BFD_RELOC_16:
+        case BFD_RELOC_8:
+          fixP->fx_next = xmemdup (fixP, sizeof (*fixP), sizeof (*fixP));
+          fixP->fx_next->fx_addsy = fixP->fx_subsy;
+          fixP->fx_next->fx_subsy = NULL;
+          fixP->fx_next->fx_offset = 0;
+          fixP->fx_subsy = NULL;
+
+          switch (fixP->fx_r_type)
+            {
+            case BFD_RELOC_64:
+              fixP->fx_r_type = BFD_RELOC_LARCH_ADD64;
+              fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB64;
+              break;
+            case BFD_RELOC_32:
+              fixP->fx_r_type = BFD_RELOC_LARCH_ADD32;
+              fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB32;
+              break;
+            case BFD_RELOC_24:
+              fixP->fx_r_type = BFD_RELOC_LARCH_ADD24;
+              fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB24;
+              break;
+            case BFD_RELOC_16:
+              fixP->fx_r_type = BFD_RELOC_LARCH_ADD16;
+              fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB16;
+              break;
+            case BFD_RELOC_8:
+              fixP->fx_r_type = BFD_RELOC_LARCH_ADD8;
+              fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB8;
+              break;
+            default:
+              break;
+            }
+          md_number_to_chars (buf, 0, fixP->fx_size);
+          if (fixP->fx_next->fx_addsy == NULL)
+            fixP->fx_next->fx_done = 1;
+        }
+      if (fixP->fx_addsy == NULL)
+        {
+          fixP->fx_done = 1;
+          md_number_to_chars (buf, *valP, fixP->fx_size);
+        }
+      break;
+
+    default:
+      break;
+    }
+}
+#pragma GCC diagnostic pop
+
+int
+loongarch_relax_frag (asection *sec ATTRIBUTE_UNUSED,
+                      fragS *fragp ATTRIBUTE_UNUSED,
+                      long stretch ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+int
+md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED,
+                               asection *segtype ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+/* Translate internal representation of relocation info to BFD target
+   format.  */
+arelent *
+tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
+{
+  arelent *reloc = (arelent *) xmalloc (sizeof (arelent));
+
+  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+  reloc->addend = fixp->fx_offset;
+
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
+  if (reloc->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+                    _ ("cannot represent %s relocation in object file"),
+                    bfd_get_reloc_code_name (fixp->fx_r_type));
+      return NULL;
+    }
+
+  return reloc;
+}
+
+/* Convert a machine dependent frag.  */
+void
+md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT asec ATTRIBUTE_UNUSED,
+                 fragS *fragp ATTRIBUTE_UNUSED)
+{
+  /* fragp->fr_fix += 8; */
+}
+
+/* Standard calling conventions leave the CFA at SP on entry.  */
+void
+loongarch_cfi_frame_initial_instructions (void)
+{
+  cfi_add_CFA_def_cfa_register (3 /* $sp */);
+}
+
+int
+loongarch_dwarf2_addr_size (void)
+{
+  return LARCH_opts.addrwidth_is_32 ? 4 : 8;
+}
+
+void
+tc_loongarch_parse_to_dw2regnum (expressionS *exp)
+{
+  expression_and_evaluate (exp);
+}
+
+void
+md_show_usage (FILE *stream)
+{
+  fprintf (stream, _ ("\
+		     LARCH options:\n\
+		     "));
+}
+
+/* Fill in an rs_align_code fragment.  We want to fill 'andi $r0,$r0,0'.  */
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wimplicit-fallthrough="
+void
+loongarch_handle_align (fragS *fragp)
+{
+  /* char nop_opcode; */
+  char *p;
+  int bytes, size, excess;
+  valueT opcode;
+
+  if (fragp->fr_type != rs_align_code)
+    return;
+
+  struct loongarch_cl_insn nop = { .name = "andi",
+                                   .arg_strs = { "$r0", "$r0", "0", NULL } };
+
+  get_loongarch_opcode (&nop);
+  gas_assert (nop.all_match);
+
+  p = fragp->fr_literal + fragp->fr_fix;
+  opcode = nop.insn_bin;
+  size = 4;
+
+  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
+  excess = bytes % size;
+
+  gas_assert (excess < 4);
+  fragp->fr_fix += excess;
+  switch (excess)
+    {
+    case 3:
+      *p++ = '\0';
+    case 2:
+      *p++ = '\0';
+    case 1:
+      *p++ = '\0';
+    case 0:
+      break;
+    }
+
+  md_number_to_chars (p, opcode, size);
+  fragp->fr_var = size;
+}
+#pragma GCC diagnostic pop
+
+void
+loongarch_elf_final_processing (void)
+{
+  if (LARCH_opts.abi_is_lp64)
+    elf_elfheader (stdoutput)->e_flags |= EF_LARCH_ABI_LP64;
+  else if (LARCH_opts.abi_is_lp32)
+    elf_elfheader (stdoutput)->e_flags |= EF_LARCH_ABI_LP32;
+}
diff --git a/gas/config/tc-loongarch.h b/gas/config/tc-loongarch.h
new file mode 100644
index 00000000000..88eb6b7a536
--- /dev/null
+++ b/gas/config/tc-loongarch.h
@@ -0,0 +1,91 @@
+/* tc-loongarch.h -- Header file for tc-loongarch.c.
+   Copyright (C) 2021-2021 Free Software Foundation, Inc.
+   Contributed by Loongson Ltd.
+
+   This file is part of GAS.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the license, or
+   (at your option) any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+
+#ifndef TC_LOONGARCH
+#define TC_LOONGARCH
+
+#define TARGET_BYTES_BIG_ENDIAN 0
+#define TARGET_ARCH bfd_arch_loongarch
+
+#define WORKING_DOT_WORD 1
+#define REPEAT_CONS_EXPRESSIONS
+
+/* early than md_begin */
+#define md_after_parse_args loongarch_after_parse_args
+extern void loongarch_after_parse_args (void);
+
+extern void loongarch_pop_insert (void);
+#define md_pop_insert() loongarch_pop_insert ()
+
+#define TARGET_FORMAT loongarch_target_format ()
+extern const char *loongarch_target_format (void);
+
+#define md_relax_frag(segment, fragp, stretch)                                \
+  loongarch_relax_frag (segment, fragp, stretch)
+extern int loongarch_relax_frag (asection *, struct frag *, long);
+#define md_section_align(seg, size) (size)
+#define md_undefined_symbol(name) (0)
+
+/* This is called to see whether a reloc against a defined symbol
+   should be converted into a reloc against a section.  */
+#define tc_fix_adjustable(fixp) 0
+
+/* Values passed to md_apply_fix don't include symbol values.  */
+#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX, SEG) 1
+#define TC_VALIDATE_FIX_SUB(FIX, SEG) 1
+#define DIFF_EXPR_OK 1
+
+#define TARGET_USE_CFIPOP 1
+#define DWARF2_DEFAULT_RETURN_COLUMN 1 /* $ra */
+#define DWARF2_CIE_DATA_ALIGNMENT -4
+extern int loongarch_dwarf2_addr_size (void);
+#define DWARF2_FDE_RELOC_SIZE loongarch_dwarf2_addr_size ()
+#define DWARF2_ADDR_SIZE(bfd) loongarch_dwarf2_addr_size ()
+#define CFI_DIFF_EXPR_OK 0
+
+#define tc_cfi_frame_initial_instructions                                     \
+  loongarch_cfi_frame_initial_instructions
+extern void loongarch_cfi_frame_initial_instructions (void);
+
+/* #define tc_regname_to_dw2regnum tc_loongarch_regname_to_dw2regnum */
+#define tc_parse_to_dw2regnum tc_loongarch_parse_to_dw2regnum
+extern void tc_loongarch_parse_to_dw2regnum (expressionS *);
+
+/* a enumerated values to specific how to deal with align in '.text' */
+/* now we want to fill 'andi $r0,$r0,0x0' */
+#define loongarch_nop_opcode() 0
+#define NOP_OPCODE (loongarch_nop_opcode ())
+
+#define HANDLE_ALIGN(fragp) loongarch_handle_align (fragp)
+extern void loongarch_handle_align (struct frag *);
+#define MAX_MEM_FOR_RS_ALIGN_CODE (3 + 4)
+
+#define elf_tc_final_processing loongarch_elf_final_processing
+extern void loongarch_elf_final_processing (void);
+
+#define MAX_RELOC_NUMBER_A_INSN 20
+
+struct reloc_info
+{
+  bfd_reloc_code_real_type type;
+  expressionS value;
+};
+
+#endif
diff --git a/gas/configure b/gas/configure
index 110d707f079..c33855121aa 100755
--- a/gas/configure
+++ b/gas/configure
@@ -12206,6 +12206,15 @@ _ACEOF
 	using_cgen=yes
 	;;
 
+      loongarch)
+	for f in loongarch-parse.o loongarch-lex-wrapper.o; do
+	  case " $extra_objects " in
+	    *" $f "*) ;;
+	    *) extra_objects="$extra_objects $f" ;;
+	  esac
+	done
+	;;
+
       m32c)
 	using_cgen=yes
 	;;
diff --git a/gas/configure.ac b/gas/configure.ac
index 78efba88e23..39c2f5b486f 100644
--- a/gas/configure.ac
+++ b/gas/configure.ac
@@ -446,6 +446,15 @@ changequote([,])dnl
 	using_cgen=yes
 	;;
 
+      loongarch)
+	for f in loongarch-parse.o loongarch-lex-wrapper.o; do
+	  case " $extra_objects " in
+	    *" $f "*) ;;
+	    *) extra_objects="$extra_objects $f" ;;
+	  esac
+	done
+	;;
+
       m32c)
 	using_cgen=yes
 	;;
diff --git a/gas/configure.tgt b/gas/configure.tgt
index 338892add2a..4a399c7c6d7 100644
--- a/gas/configure.tgt
+++ b/gas/configure.tgt
@@ -67,6 +67,7 @@ case ${cpu} in
   ip2k)			cpu_type=ip2k endian=big ;;
   iq2000)		cpu_type=iq2000 endian=big ;;
   lm32)			cpu_type=lm32 ;;
+  loongarch*)		cpu_type=loongarch ;;
   m32c)			cpu_type=m32c endian=little ;;
   m32r)			cpu_type=m32r endian=big ;;
   m32rle)		cpu_type=m32r endian=little ;;
@@ -275,6 +276,8 @@ case ${generic_target} in
 
   lm32-*-*)				fmt=elf ;;
 
+  loongarch*)				fmt=elf ;;
+
   m32c-*-elf)				fmt=elf ;;
 
   m32r-*-elf*)				fmt=elf ;;
@@ -435,7 +438,7 @@ esac
 
 case ${cpu_type} in
   aarch64 | alpha | arm | csky | i386 | ia64 | microblaze | mips | ns32k | \
-  or1k | or1knd | pdp11 | ppc | riscv | sh | sparc | z80 | z8k)
+  or1k | or1knd | pdp11 | ppc | riscv | sh | sparc | z80 | z8k | loongarch)
     bfd_gas=yes
     ;;
 esac
diff --git a/gas/testsuite/lib/gas-defs.exp b/gas/testsuite/lib/gas-defs.exp
index f9ee6f4ac72..6074c2ee282 100644
--- a/gas/testsuite/lib/gas-defs.exp
+++ b/gas/testsuite/lib/gas-defs.exp
@@ -360,6 +360,10 @@ proc verbose_eval { expr { level 1 } } {
 # This definition is taken from an unreleased version of DejaGnu.  Once
 # that version gets released, and has been out in the world for a few
 # months at least, it may be safe to delete this copy.
+
+if { [istarget loongarch*-*-*] } {
+    rename prune_warnings prune_warnings_other
+}
 if ![string length [info proc prune_warnings]] {
     #
     # prune_warnings -- delete various system verbosities from TEXT.
diff --git a/include/dis-asm.h b/include/dis-asm.h
index 0b91ab47ff3..c0bc1d542cf 100644
--- a/include/dis-asm.h
+++ b/include/dis-asm.h
@@ -307,6 +307,7 @@ extern void print_arm_disassembler_options (FILE *);
 extern void print_arc_disassembler_options (FILE *);
 extern void print_s390_disassembler_options (FILE *);
 extern void print_wasm32_disassembler_options (FILE *);
+extern void print_loongarch_disassembler_options (FILE *);
 extern bool aarch64_symbol_is_valid (asymbol *, struct disassemble_info *);
 extern bool arm_symbol_is_valid (asymbol *, struct disassemble_info *);
 extern bool csky_symbol_is_valid (asymbol *, struct disassemble_info *);
diff --git a/include/elf/loongarch.h b/include/elf/loongarch.h
new file mode 100644
index 00000000000..611ea4a76e2
--- /dev/null
+++ b/include/elf/loongarch.h
@@ -0,0 +1,101 @@
+/* Copyright (C) 2021-2021 Free Software Foundation, Inc.
+   Contributed by Loongson Ltd.
+
+   This file is part of GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the license, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _ELF_LOONG_H
+#define _ELF_LOONG_H
+
+#include "elf/reloc-macros.h"
+#include "libiberty.h"
+
+START_RELOC_NUMBERS (elf_loongarch_reloc_type)
+/* used by the dynamic linker */
+RELOC_NUMBER (R_LARCH_NONE, 0)
+RELOC_NUMBER (R_LARCH_32, 1)
+RELOC_NUMBER (R_LARCH_64, 2)
+RELOC_NUMBER (R_LARCH_RELATIVE, 3)
+RELOC_NUMBER (R_LARCH_COPY, 4)
+RELOC_NUMBER (R_LARCH_JUMP_SLOT, 5)
+RELOC_NUMBER (R_LARCH_TLS_DTPMOD32, 6)
+RELOC_NUMBER (R_LARCH_TLS_DTPMOD64, 7)
+RELOC_NUMBER (R_LARCH_TLS_DTPREL32, 8)
+RELOC_NUMBER (R_LARCH_TLS_DTPREL64, 9)
+RELOC_NUMBER (R_LARCH_TLS_TPREL32, 10)
+RELOC_NUMBER (R_LARCH_TLS_TPREL64, 11)
+RELOC_NUMBER (R_LARCH_IRELATIVE, 12)
+
+/* Reserved for future relocs that the dynamic linker must understand.  */
+
+/* used by the static linker for relocating .text */
+RELOC_NUMBER (R_LARCH_MARK_LA, 20)
+RELOC_NUMBER (R_LARCH_MARK_PCREL, 21)
+
+RELOC_NUMBER (R_LARCH_SOP_PUSH_PCREL, 22)
+
+RELOC_NUMBER (R_LARCH_SOP_PUSH_ABSOLUTE, 23)
+
+RELOC_NUMBER (R_LARCH_SOP_PUSH_DUP, 24)
+RELOC_NUMBER (R_LARCH_SOP_PUSH_GPREL, 25)
+RELOC_NUMBER (R_LARCH_SOP_PUSH_TLS_TPREL, 26)
+RELOC_NUMBER (R_LARCH_SOP_PUSH_TLS_GOT, 27)
+RELOC_NUMBER (R_LARCH_SOP_PUSH_TLS_GD, 28)
+RELOC_NUMBER (R_LARCH_SOP_PUSH_PLT_PCREL, 29)
+
+RELOC_NUMBER (R_LARCH_SOP_ASSERT, 30)
+RELOC_NUMBER (R_LARCH_SOP_NOT, 31)
+RELOC_NUMBER (R_LARCH_SOP_SUB, 32)
+RELOC_NUMBER (R_LARCH_SOP_SL, 33)
+RELOC_NUMBER (R_LARCH_SOP_SR, 34)
+RELOC_NUMBER (R_LARCH_SOP_ADD, 35)
+RELOC_NUMBER (R_LARCH_SOP_AND, 36)
+RELOC_NUMBER (R_LARCH_SOP_IF_ELSE, 37)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_10_5, 38)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_U_10_12, 39)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_10_12, 40)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_10_16, 41)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_10_16_S2, 42)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_5_20, 43)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_0_5_10_16_S2, 44)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_S_0_10_10_16_S2, 45)
+RELOC_NUMBER (R_LARCH_SOP_POP_32_U, 46)
+
+/* used by the static linker for relocating non .text */
+RELOC_NUMBER (R_LARCH_ADD8, 47)
+RELOC_NUMBER (R_LARCH_ADD16, 48)
+RELOC_NUMBER (R_LARCH_ADD24, 49)
+RELOC_NUMBER (R_LARCH_ADD32, 50)
+RELOC_NUMBER (R_LARCH_ADD64, 51)
+RELOC_NUMBER (R_LARCH_SUB8, 52)
+RELOC_NUMBER (R_LARCH_SUB16, 53)
+RELOC_NUMBER (R_LARCH_SUB24, 54)
+RELOC_NUMBER (R_LARCH_SUB32, 55)
+RELOC_NUMBER (R_LARCH_SUB64, 56)
+
+/* I don't know what it is. Existing in almost all other arch */
+RELOC_NUMBER (R_LARCH_GNU_VTINHERIT, 57)
+RELOC_NUMBER (R_LARCH_GNU_VTENTRY, 58)
+
+END_RELOC_NUMBERS (R_LARCH_count)
+
+/* Processor specific flags for the ELF header e_flags field.  */
+
+#define EF_LARCH_ABI 0x0003
+#define EF_LARCH_ABI_LP64 0x0003
+#define EF_LARCH_ABI_LP32 0x0001
+
+#endif /* _ELF_LOONG_H */
diff --git a/include/opcode/loongarch.h b/include/opcode/loongarch.h
new file mode 100644
index 00000000000..d5be50450fe
--- /dev/null
+++ b/include/opcode/loongarch.h
@@ -0,0 +1,217 @@
+/* Loongarch assembler/disassembler support.
+
+   Copyright (C) 2021-2021 Free Software Foundation, Inc.
+   Contributed by Loongson Ltd.
+
+   This file is part of GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the license, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LOONGARCH_H_
+#define _LOONGARCH_H_
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+  typedef uint32_t insn_t;
+
+  struct loongarch_opcode
+  {
+    const insn_t match;
+    const insn_t mask; /* High 1 byte is main opcode and it must be 0xf. */
+#define LARCH_INSN_OPC(insn) ((insn & 0xf0000000) >> 28)
+    const char *const name;
+
+    /* 
+     ACTUAL PARAMETER:
+
+  // BNF with regular expression. 
+args : token* end
+
+  // just few char separate 'iden'
+token : ','
+| '('
+| ')'
+| iden             // maybe a label (include at least one alphabet), maybe a number, maybe a expr
+| regname
+
+regname : '$' iden
+
+iden : [a-zA-Z0-9\.\+\-]+
+
+end : '\0'
+
+
+FORMAT: A string to describe the format of actual parameter including bit field infomation.
+For example, "r5:5,r0:5,sr10:16<<2" matches "$12,$13,12345" and "$4,$7,a_label".
+That 'sr' means the instruction may need relocate. '10:16' means bit field of instruction.
+In a 'format', every 'escape's can be replaced to 'iden' or 'regname' acrroding to its meaning.
+We fill all information needed by disassembing and assembing to 'format'.
+
+  // BNF with regular expression. 
+format : escape (literal+ escape)* literal* end
+| (literal+ escape)* literal* end
+
+end : '\0'       // Get here means parse end.
+
+  // The intersection between any two among FIRST (end), FIRST (literal) and FIRST (escape) must be empty.
+  // So we can build a simple parser.
+literal : ','
+| '('
+| ')'
+
+  // Double '<'s means the real number is the immediate after shifting left.
+escape : esc_ch bit_field '<' '<' dec2
+| esc_ch bit_field
+| esc_ch    // for MACRO. non-macro format must indicate 'bit_field'
+
+  // '|' means to concatenate nonadjacent bit fields 
+  // For example, "10:16|0:4" means 
+  // "16 bits starting from the 10th bit concatenating with 4 bits starting from the 0th bit".
+  // This is to say "[25..10]||[3..0]" (little endian).
+b_field : dec2 ':' dec2
+| dec2 ':' dec2 '|' bit_field
+
+esc_ch : 's' 'r'   // signed immediate or label need relocate
+| 's'       // signed immediate no need relocate
+| 'u'       // unsigned immediate
+| 'l'       // label needed relocate
+| 'r'       // general purpose registers
+| 'f'       // FPU registers
+| 'v'       // 128 bit SIMD register
+| 'x'       // 256 bit SIMD register
+
+dec2 : [1-9][0-9]?
+| 0
+
+*/
+    const char *const format;
+
+    /*
+MACRO: Indicate how a macro instruction expand for assembling.
+The main is to replace the '%num'(means the 'num'th 'escape' in 'format') in 'macro' string to get the real instruction.
+
+Maybe need 
+*/
+    const char *const macro;
+    const int *include;
+    const int *exclude;
+
+    const unsigned long pinfo;
+#define USELESS 0x0l
+  };
+
+  struct hash_control;
+
+  struct loongarch_ase
+  {
+    const int *enabled;
+    struct loongarch_opcode *const opcodes;
+    const int *include;
+    const int *exclude;
+
+    /* for disassemble to create main opcode hash table. */
+    const struct loongarch_opcode *opc_htab[16];
+    unsigned char opc_htab_inited;
+
+    /* for GAS to create hash table. */
+    struct htab *name_hash_entry;
+  };
+
+  extern int is_unsigned (const char *);
+  extern int is_signed (const char *);
+  extern int is_label_with_addend (const char *);
+  extern int is_label (const char *);
+  extern int is_branch_label (const char *);
+
+  extern int loongarch_get_bit_field_width (const char *bit_field, char **end);
+  extern int32_t loongarch_decode_imm (const char *bit_field, insn_t insn,
+                                       int si);
+
+#define MAX_ARG_NUM_PLUS_2 9
+
+  extern size_t loongarch_split_args_by_comma (char *args,
+                                               const char *arg_strs[]);
+  extern char *loongarch_cat_splited_strs (const char *arg_strs[]);
+  extern insn_t loongarch_foreach_args (
+    const char *format, const char *arg_strs[],
+    int32_t (*helper) (char esc1, char esc2, const char *bit_field,
+                       const char *arg, void *context),
+    void *context);
+
+  extern int loongarch_check_format (const char *format);
+  extern int loongarch_check_macro (const char *format, const char *macro);
+
+  extern char *loongarch_expand_macro_with_format_map (
+    const char *format, const char *macro, const char *const arg_strs[],
+    const char *(*map) (char esc1, char esc2, const char *arg),
+    char *(*helper) (const char *const arg_strs[], void *context),
+    void *context);
+  extern char *loongarch_expand_macro (
+    const char *macro, const char *const arg_strs[],
+    char *(*helper) (const char *const arg_strs[], void *context),
+    void *context);
+  extern size_t loongarch_bits_imm_needed (int64_t imm, int si);
+
+  extern void loongarch_eliminate_adjacent_repeat_char (char *dest, char c);
+
+  extern int loongarch_parse_dis_options (const char *opts_in);
+  extern void loongarch_disassemble_one (
+    int64_t pc, insn_t insn,
+    int (*fprintf_func) (void *stream, const char *format, ...), void *stream);
+
+  extern const char *const loongarch_r_normal_name[32];
+  extern const char *const loongarch_r_lp64_name[32];
+  extern const char *const loongarch_r_lp64_name1[32];
+  extern const char *const loongarch_f_normal_name[32];
+  extern const char *const loongarch_f_lp64_name[32];
+  extern const char *const loongarch_f_lp64_name1[32];
+  extern const char *const loongarch_c_normal_name[8];
+  extern const char *const loongarch_cr_normal_name[4];
+  extern const char *const loongarch_v_normal_name[32];
+  extern const char *const loongarch_x_normal_name[32];
+
+  extern struct loongarch_ase loongarch_ASEs[];
+
+  extern struct loongarch_ASEs_option
+  {
+    int ase_test;
+    int ase_fix;
+    int ase_float;
+    int ase_128vec;
+    int ase_256vec;
+
+    int addrwidth_is_32;
+    int addrwidth_is_64;
+    int rlen_is_32;
+    int rlen_is_64;
+    int la_local_with_abs;
+    int la_global_with_pcrel;
+    int la_global_with_abs;
+
+    int abi_is_lp32;
+    int abi_is_lp64;
+  } LARCH_opts;
+
+  extern size_t loongarch_insn_length (insn_t insn);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _LOONGARCH_H_ */
diff --git a/ld/Makefile.am b/ld/Makefile.am
index f8e99325361..436b5577256 100644
--- a/ld/Makefile.am
+++ b/ld/Makefile.am
@@ -434,6 +434,7 @@ ALL_64_EMULATION_SOURCES = \
 	eelf64hppa.c \
 	eelf64lppc.c \
 	eelf64lppc_fbsd.c \
+	eelf64loongarch.c \
 	eelf64lriscv.c \
 	eelf64lriscv_lp64f.c \
 	eelf64lriscv_lp64.c \
@@ -920,6 +921,7 @@ $(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES): $(GEN_DEPENDS)
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64hppa.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lppc.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lppc_fbsd.Pc@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64loongarch.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lriscv.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lriscv_lp64f.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lriscv_lp64.Pc@am__quote@
diff --git a/ld/Makefile.in b/ld/Makefile.in
index ef2e99e08da..9fb716b0b5e 100644
--- a/ld/Makefile.in
+++ b/ld/Makefile.in
@@ -923,6 +923,7 @@ ALL_64_EMULATION_SOURCES = \
 	eelf64hppa.c \
 	eelf64lppc.c \
 	eelf64lppc_fbsd.c \
+	eelf64loongarch.c \
 	eelf64lriscv.c \
 	eelf64lriscv_lp64f.c \
 	eelf64lriscv_lp64.c \
@@ -1417,6 +1418,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64btsmip.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64btsmip_fbsd.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64hppa.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64loongarch.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lppc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lppc_fbsd.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lriscv.Po@am__quote@
@@ -2578,6 +2580,7 @@ $(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES): $(GEN_DEPENDS)
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64hppa.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lppc.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lppc_fbsd.Pc@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64loongarch.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lriscv.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lriscv_lp64f.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lriscv_lp64.Pc@am__quote@
diff --git a/ld/configure.tgt b/ld/configure.tgt
index 6205d7c9872..86ce091985f 100644
--- a/ld/configure.tgt
+++ b/ld/configure.tgt
@@ -1021,6 +1021,10 @@ z8k-*-coff)		targ_emul=z8002
 			targ_extra_emuls=z8001
 			targ_extra_ofiles=
 			;;
+loongarch32-*)		targ_emul=elf32loongarch
+			;;
+loongarch64-*)		targ_emul=elf64loongarch
+			;;
 *-*-ieee*)		targ_emul=vanilla
 			targ_extra_ofiles=
 			;;
diff --git a/ld/emulparams/elf64loongarch-defs.sh b/ld/emulparams/elf64loongarch-defs.sh
new file mode 100644
index 00000000000..ed793565a06
--- /dev/null
+++ b/ld/emulparams/elf64loongarch-defs.sh
@@ -0,0 +1,38 @@
+# This is an ELF platform.
+SCRIPT_NAME=elf
+ARCH=loongarch
+NO_REL_RELOCS=yes
+
+#TEMPLATE_NAME=elf32
+TEMPLATE_NAME=elf
+EXTRA_EM_FILE=loongarchelf
+
+ELFSIZE=64
+
+if test `echo "$host" | sed -e s/64//` = `echo "$target" | sed -e s/64//`; then
+  case " $EMULATION_LIBPATH " in
+    *" ${EMULATION_NAME} "*)
+      NATIVE=yes
+      ;;
+  esac
+fi
+
+# Enable shared library support for everything except an embedded elf target.
+case "$target" in
+  loongarch*-elf)
+    ;;
+  *)
+    GENERATE_SHLIB_SCRIPT=yes
+    GENERATE_PIE_SCRIPT=yes
+    ;;
+esac
+
+NOP=0x03400000
+
+TEXT_START_ADDR=0x120000000
+MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
+COMMONPAGESIZE="CONSTANT (COMMONPAGESIZE)"
+
+SEPARATE_GOTPLT=0
+INITIAL_READONLY_SECTIONS=".interp         : { *(.interp) } ${CREATE_PIE-${INITIAL_READONLY_SECTIONS}}"
+INITIAL_READONLY_SECTIONS="${RELOCATING+${CREATE_SHLIB-${INITIAL_READONLY_SECTIONS}}}"
diff --git a/ld/emulparams/elf64loongarch.sh b/ld/emulparams/elf64loongarch.sh
new file mode 100644
index 00000000000..a9d800ad107
--- /dev/null
+++ b/ld/emulparams/elf64loongarch.sh
@@ -0,0 +1,11 @@
+. ${srcdir}/emulparams/elf64loongarch-defs.sh
+OUTPUT_FORMAT="elf64-loongarch"
+
+case "$target" in
+  loong64*-linux*)
+    case "$EMULATION_NAME" in
+      *64*)
+	LIBPATH_SUFFIX="64/lib64 64";;
+    esac
+    ;;
+esac
diff --git a/ld/emultempl/loongarchelf.em b/ld/emultempl/loongarchelf.em
new file mode 100644
index 00000000000..4984537eb0a
--- /dev/null
+++ b/ld/emultempl/loongarchelf.em
@@ -0,0 +1,91 @@
+# This shell script emits a C file. -*- C -*-
+#   Copyright (C) 2021-2021 Free Software Foundation, Inc.
+#   Contributed by Loongson Ltd.
+#
+# This file is part of the GNU Binutils.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING3. If not,
+# see <http://www.gnu.org/licenses/>.
+
+fragment <<EOF
+
+#include "ldmain.h"
+#include "ldctor.h"
+#include "elf/loongarch.h"
+
+static void
+loong_elf_before_allocation (void)
+{
+  gld${EMULATION_NAME}_before_allocation ();
+
+  if (link_info.discard == discard_sec_merge)
+    link_info.discard = discard_l;
+
+  if (!bfd_link_relocatable (&link_info))
+    {
+      /* We always need at least some relaxation to handle code alignment.  */
+      if (RELAXATION_DISABLED_BY_USER)
+	TARGET_ENABLE_RELAXATION;
+      else
+	ENABLE_RELAXATION;
+    }
+
+  link_info.relax_pass = 3;
+}
+
+static void
+gld${EMULATION_NAME}_after_allocation (void)
+{
+  int need_layout = 0;
+
+  /* Don't attempt to discard unused .eh_frame sections until the final link,
+     as we can't reliably tell if they're used until after relaxation.  */
+  if (!bfd_link_relocatable (&link_info))
+    {
+      need_layout = bfd_elf_discard_info (link_info.output_bfd, &link_info);
+      if (need_layout < 0)
+	{
+	  einfo (_("%X%P: .eh_frame/.stab edit: %E\n"));
+	  return;
+	}
+    }
+
+  /* gld${EMULATION_NAME}_map_segments (need_layout); */
+  ldelf_map_segments (need_layout);
+}
+
+/* This is a convenient point to tell BFD about target specific flags.
+   After the output has been created, but before inputs are read.  */
+
+static void
+loong_create_output_section_statements (void)
+{
+  /* See PR 22920 for an example of why this is necessary.  */
+  if (strstr (bfd_get_target (link_info.output_bfd), "loong") == NULL)
+    {
+      /* The RISC-V backend needs special fields in the output hash structure.
+	 These will only be created if the output format is a RISC-V format,
+	 hence we do not support linking and changing output formats at the
+	 same time.  Use a link followed by objcopy to change output formats.  */
+      einfo (_("%F%P: error: cannot change output format"
+	       " whilst linking %s binaries\n"), "RISC-V");
+      return;
+    }
+}
+
+EOF
+
+LDEMUL_BEFORE_ALLOCATION=loong_elf_before_allocation
+LDEMUL_AFTER_ALLOCATION=gld${EMULATION_NAME}_after_allocation
+LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS=loong_create_output_section_statements
diff --git a/opcodes/Makefile.am b/opcodes/Makefile.am
index 0e04b4c05c4..c45fc295665 100644
--- a/opcodes/Makefile.am
+++ b/opcodes/Makefile.am
@@ -164,6 +164,9 @@ TARGET_LIBOPCODES_CFILES = \
 	lm32-ibld.c \
 	lm32-opc.c \
 	lm32-opinst.c \
+	loongarch-opc.c \
+	loongarch-dis.c \
+	loongarch-coder.c \
 	m10200-dis.c \
 	m10200-opc.c \
 	m10300-dis.c \
diff --git a/opcodes/Makefile.in b/opcodes/Makefile.in
index 42c15f00d30..8ba01c9f8f9 100644
--- a/opcodes/Makefile.in
+++ b/opcodes/Makefile.in
@@ -555,6 +555,9 @@ TARGET_LIBOPCODES_CFILES = \
 	lm32-ibld.c \
 	lm32-opc.c \
 	lm32-opinst.c \
+	loongarch-opc.c \
+	loongarch-dis.c \
+	loongarch-coder.c \
 	m10200-dis.c \
 	m10200-opc.c \
 	m10300-dis.c \
@@ -973,6 +976,9 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lm32-ibld.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lm32-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lm32-opinst.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/loongarch-coder.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/loongarch-dis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/loongarch-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/m10200-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/m10200-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/m10300-dis.Plo@am__quote@
diff --git a/opcodes/configure b/opcodes/configure
index 3513e408ce1..aa46453d815 100755
--- a/opcodes/configure
+++ b/opcodes/configure
@@ -12294,6 +12294,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_z80_arch)		ta="$ta z80-dis.lo" ;;
 	bfd_z8k_arch)		ta="$ta z8k-dis.lo" ;;
 	bfd_bpf_arch)		ta="$ta bpf-asm.lo bpf-desc.lo bpf-dis.lo bpf-ibld.lo bpf-opc.lo" using_cgen=yes ;;
+	bfd_loongarch_arch)		ta="$ta loongarch-dis.lo loongarch-opc.lo loongarch-coder.lo" ;;
 
 	"")			;;
 	*)		as_fn_error $? "*** unknown target architecture $arch" "$LINENO" 5 ;;
diff --git a/opcodes/configure.ac b/opcodes/configure.ac
index e564f067334..4853b9e32d7 100644
--- a/opcodes/configure.ac
+++ b/opcodes/configure.ac
@@ -355,6 +355,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_z80_arch)		ta="$ta z80-dis.lo" ;;
 	bfd_z8k_arch)		ta="$ta z8k-dis.lo" ;;
 	bfd_bpf_arch)		ta="$ta bpf-asm.lo bpf-desc.lo bpf-dis.lo bpf-ibld.lo bpf-opc.lo" using_cgen=yes ;;
+	bfd_loongarch_arch)	ta="$ta loongarch-dis.lo loongarch-opc.lo loongarch-coder.lo" ;;
 
 	"")			;;
 	*)		AC_MSG_ERROR(*** unknown target architecture $arch) ;;
diff --git a/opcodes/disassemble.c b/opcodes/disassemble.c
index 8590e945c58..61e666c1822 100644
--- a/opcodes/disassemble.c
+++ b/opcodes/disassemble.c
@@ -49,6 +49,7 @@
 #define ARCH_ip2k
 #define ARCH_iq2000
 #define ARCH_lm32
+#define ARCH_loongarch
 #define ARCH_m32c
 #define ARCH_m32r
 #define ARCH_m68hc11
@@ -551,6 +552,11 @@ disassembler (enum bfd_architecture a,
     case bfd_arch_tilepro:
       disassemble = print_insn_tilepro;
       break;
+#endif
+#ifdef ARCH_loongarch
+    case bfd_arch_loongarch:
+      disassemble = print_insn_loongarch;
+      break;
 #endif
     default:
       return 0;
@@ -591,6 +597,9 @@ disassembler_usage (FILE *stream ATTRIBUTE_UNUSED)
 #ifdef ARCH_wasm32
   print_wasm32_disassembler_options (stream);
 #endif
+#ifdef ARCH_loongarch
+  print_loongarch_disassembler_options (stream);
+#endif
 
   return;
 }
diff --git a/opcodes/disassemble.h b/opcodes/disassemble.h
index 8ee54dc9494..4e3ea2328e0 100644
--- a/opcodes/disassemble.h
+++ b/opcodes/disassemble.h
@@ -100,6 +100,7 @@ extern int print_insn_xtensa		(bfd_vma, disassemble_info *);
 extern int print_insn_z80		(bfd_vma, disassemble_info *);
 extern int print_insn_z8001		(bfd_vma, disassemble_info *);
 extern int print_insn_z8002		(bfd_vma, disassemble_info *);
+extern int print_insn_loongarch		(bfd_vma, disassemble_info *);
 
 extern disassembler_ftype csky_get_disassembler (bfd *);
 extern disassembler_ftype rl78_get_disassembler (bfd *);
diff --git a/opcodes/loongarch-coder.c b/opcodes/loongarch-coder.c
new file mode 100644
index 00000000000..da22520fc83
--- /dev/null
+++ b/opcodes/loongarch-coder.c
@@ -0,0 +1,548 @@
+/* loongarch opcode support.
+   Copyright (C) 2021-2021 Free Software Foundation, Inc.
+   Contributed by Loongson Ltd.
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+#include "sysdep.h"
+#include "opcode/loongarch.h"
+
+int
+is_unsigned (const char *c_str)
+{
+  if (c_str[0] == '0' && (c_str[1] == 'x' || c_str[1] == 'X'))
+    {
+      c_str += 2;
+      while (('a' <= *c_str && *c_str <= 'f') ||
+             ('A' <= *c_str && *c_str <= 'F') ||
+             ('0' <= *c_str && *c_str <= '9'))
+        c_str++;
+    }
+  else if (*c_str == '\0')
+    return 0;
+  else
+    while ('0' <= *c_str && *c_str <= '9')
+      c_str++;
+  return *c_str == '\0';
+}
+
+int
+is_signed (const char *c_str)
+{
+  return *c_str == '-' ? is_unsigned (c_str + 1) : is_unsigned (c_str);
+}
+
+static int
+is_internal_label (const char *c_str)
+{
+  do
+    {
+      if (*c_str != ':')
+        break;
+      c_str++;
+      if (!('0' <= *c_str && *c_str <= '9'))
+        break;
+      while ('0' <= *c_str && *c_str <= '9')
+        c_str++;
+      if (*c_str != 'b' && *c_str != 'f')
+        break;
+      c_str++;
+      return *c_str == '\0';
+    }
+  while (0);
+  return 0;
+}
+
+int
+is_label (const char *c_str)
+{
+  if (is_internal_label (c_str))
+    return 1;
+  else if ('0' <= *c_str && *c_str <= '9')
+    {
+      /* [0-9]+[bf] */
+      while ('0' <= *c_str && *c_str <= '9')
+        c_str++;
+      return *c_str == 'b' || *c_str == 'f';
+    }
+  else if (('a' <= *c_str && *c_str <= 'z') ||
+           ('A' <= *c_str && *c_str <= 'Z') || *c_str == '.' ||
+           *c_str == '_' || *c_str == '$')
+    {
+      /* [a-zA-Z\._\$][0-9a-zA-Z\._\$]* */
+      while (('a' <= *c_str && *c_str <= 'z') ||
+             ('A' <= *c_str && *c_str <= 'Z') ||
+             ('0' <= *c_str && *c_str <= '9') || *c_str == '.' ||
+             *c_str == '_' || *c_str == '$')
+        c_str++;
+      return *c_str == '\0';
+    }
+  else
+    return 0;
+}
+
+int
+is_label_with_addend (const char *c_str)
+{
+  if (is_internal_label (c_str))
+    return 1;
+  else if ('0' <= *c_str && *c_str <= '9')
+    {
+      /* [0-9]+[bf] */
+      while ('0' <= *c_str && *c_str <= '9')
+        c_str++;
+      if (*c_str == 'b' || *c_str == 'f')
+        c_str++;
+      else
+        return 0;
+      return *c_str == '\0' ||
+             ((*c_str == '-' || *c_str == '+') && is_unsigned (c_str + 1));
+    }
+  else if (('a' <= *c_str && *c_str <= 'z') ||
+           ('A' <= *c_str && *c_str <= 'Z') || *c_str == '.' ||
+           *c_str == '_' || *c_str == '$')
+    {
+      /* [a-zA-Z\._\$][0-9a-zA-Z\._\$]* */
+      while (('a' <= *c_str && *c_str <= 'z') ||
+             ('A' <= *c_str && *c_str <= 'Z') ||
+             ('0' <= *c_str && *c_str <= '9') || *c_str == '.' ||
+             *c_str == '_' || *c_str == '$')
+        c_str++;
+      return *c_str == '\0' ||
+             ((*c_str == '-' || *c_str == '+') && is_unsigned (c_str + 1));
+    }
+  else
+    return 0;
+}
+
+int
+loongarch_get_bit_field_width (const char *bit_field, char **end)
+{
+  int width = 0;
+  char has_specify = 0, *bit_field_1 = (char *) bit_field;
+  if (bit_field_1 && *bit_field_1 != '\0')
+    while (1)
+      {
+        strtol (bit_field_1, &bit_field_1, 10);
+
+        if (*bit_field_1 != ':')
+          break;
+        bit_field_1++;
+
+        width += strtol (bit_field_1, &bit_field_1, 10);
+        has_specify = 1;
+
+        if (*bit_field_1 != '|')
+          break;
+        bit_field_1++;
+      }
+  if (end)
+    *end = bit_field_1;
+  return has_specify ? width : -1;
+}
+
+int32_t
+loongarch_decode_imm (const char *bit_field, insn_t insn, int si)
+{
+  int32_t ret = 0;
+  uint32_t t;
+  int len = 0, width, b_start;
+  char *bit_field_1 = (char *) bit_field;
+  while (1)
+    {
+      b_start = strtol (bit_field_1, &bit_field_1, 10);
+      if (*bit_field_1 != ':')
+        break;
+      width = strtol (bit_field_1 + 1, &bit_field_1, 10);
+      len += width;
+
+      t = insn;
+      t <<= sizeof (t) * 8 - width - b_start;
+      t >>= sizeof (t) * 8 - width;
+      ret <<= width;
+      ret |= t;
+
+      if (*bit_field_1 != '|')
+        break;
+      bit_field_1++;
+    }
+
+  if (*bit_field_1 == '<' && *(++bit_field_1) == '<')
+    {
+      width = atoi (bit_field_1 + 1);
+      ret <<= width;
+      len += width;
+    }
+  else if (*bit_field_1 == '+')
+    ret += atoi (bit_field_1 + 1);
+
+  if (si)
+    {
+      ret <<= sizeof (ret) * 8 - len;
+      ret >>= sizeof (ret) * 8 - len;
+    }
+  return ret;
+}
+
+static insn_t
+loongarch_encode_imm (const char *bit_field, int32_t imm)
+{
+  char *bit_field_1 = (char *) bit_field;
+  char *t = bit_field_1;
+  int width, b_start;
+  insn_t ret = 0, i;
+
+  width = loongarch_get_bit_field_width (t, &t);
+  if (width == -1)
+    return ret;
+
+  if (*t == '<' && *(++t) == '<')
+    width += atoi (t + 1);
+  else if (*t == '+')
+    imm -= atoi (t + 1);
+
+  imm <<= sizeof (imm) * 8 - width;
+  while (1)
+    {
+      b_start = strtol (bit_field_1, &bit_field_1, 10);
+      if (*bit_field_1 != ':')
+        break;
+      width = strtol (bit_field_1 + 1, &bit_field_1, 10);
+      i = imm;
+      i >>= sizeof (i) * 8 - width;
+      i <<= b_start;
+      ret |= i;
+      imm <<= width;
+
+      if (*bit_field_1 != '|')
+        break;
+      bit_field_1++;
+    }
+  return ret;
+}
+
+/* parse such FORMAT
+     ""
+     "u"
+     "v0:5,r5:5,s10:10<<2"
+     "r0:5,r5:5,r10:5,u15:2+1"
+     "r,r,u0:5+32,u0:5+1"
+*/
+static int
+loongarch_parse_format (const char *format, char *esc1s, char *esc2s,
+                        const char **bit_fields)
+{
+  size_t arg_num = 0;
+
+  if (*format == '\0')
+    goto end;
+
+  while (1)
+    {
+      /*        esc1    esc2
+	 for "[a-zA-Z][a-zA-Z]?" */
+      if (('a' <= *format && *format <= 'z') ||
+          ('A' <= *format && *format <= 'Z'))
+        {
+          *esc1s++ = *format++;
+          if (('a' <= *format && *format <= 'z') ||
+              ('A' <= *format && *format <= 'Z'))
+            *esc2s++ = *format++;
+          else
+            *esc2s++ = '\0';
+        }
+      else
+        return -1;
+
+      arg_num++;
+      if (MAX_ARG_NUM_PLUS_2 - 2 < arg_num)
+        /* need larger MAX_ARG_NUM_PLUS_2 */
+        return -1;
+
+      *bit_fields++ = format;
+
+      if ('0' <= *format && *format <= '9')
+        {
+          /* for "[0-9]+:[0-9]+(\|[0-9]+:[0-9]+)*" */
+          while (1)
+            {
+              while ('0' <= *format && *format <= '9')
+                format++;
+
+              if (*format != ':')
+                return -1;
+              format++;
+
+              if (!('0' <= *format && *format <= '9'))
+                return -1;
+              while ('0' <= *format && *format <= '9')
+                format++;
+
+              if (*format != '|')
+                break;
+              format++;
+            }
+
+          /* for "((\+|<<)[1-9][0-9]*)?" */
+          do
+            {
+              if (*format == '+')
+                format++;
+              else if (format[0] == '<' && format[1] == '<')
+                format += 2;
+              else
+                break;
+
+              if (!('1' <= *format && *format <= '9'))
+                return -1;
+              while ('0' <= *format && *format <= '9')
+                format++;
+            }
+          while (0);
+        }
+
+      if (*format == ',')
+        format++;
+      else if (*format == '\0')
+        break;
+      else
+        return -1;
+    }
+
+end:
+  *esc1s = '\0';
+  return 0;
+}
+
+size_t
+loongarch_split_args_by_comma (char *args, const char *arg_strs[])
+{
+  size_t num = 0;
+
+  if (*args)
+    arg_strs[num++] = args;
+  for (; *args; args++)
+    if (*args == ',')
+      {
+        if (MAX_ARG_NUM_PLUS_2 - 1 == num)
+          break;
+        else
+          *args = '\0', arg_strs[num++] = args + 1;
+      }
+  arg_strs[num] = NULL;
+  return num;
+}
+
+char *
+loongarch_cat_splited_strs (const char *arg_strs[])
+{
+  char *ret;
+  size_t n, l;
+
+  for (l = 0, n = 0; arg_strs[n]; n++)
+    l += strlen (arg_strs[n]);
+  ret = malloc (l + n + 1);
+  ret[0] = '\0';
+  if (0 < n)
+    strcat (ret, arg_strs[0]);
+  for (l = 1; l < n; l++)
+    strcat (ret, ","), strcat (ret, arg_strs[l]);
+  return ret;
+}
+
+insn_t
+loongarch_foreach_args (const char *format, const char *arg_strs[],
+                        int32_t (*helper) (char esc1, char esc2,
+                                           const char *bit_field,
+                                           const char *arg, void *context),
+                        void *context)
+{
+  char esc1s[MAX_ARG_NUM_PLUS_2 - 1], esc2s[MAX_ARG_NUM_PLUS_2 - 1];
+  const char *bit_fields[MAX_ARG_NUM_PLUS_2 - 1];
+  size_t i;
+  insn_t ret = 0;
+  int ok;
+
+  ok = loongarch_parse_format (format, esc1s, esc2s, bit_fields) == 0;
+
+  /* make sure the num of actual args is equal to the num of escape */
+  for (i = 0; esc1s[i] && arg_strs[i]; i++)
+    ;
+  ok = ok && !esc1s[i] && !arg_strs[i];
+
+  if (ok && helper)
+    {
+      for (i = 0; arg_strs[i]; i++)
+        ret |= loongarch_encode_imm (
+          bit_fields[i],
+          helper (esc1s[i], esc2s[i], bit_fields[i], arg_strs[i], context));
+      ret |= helper ('\0', '\0', NULL, NULL, context);
+    }
+
+  return ret;
+}
+
+int
+loongarch_check_format (const char *format)
+{
+  char esc1s[MAX_ARG_NUM_PLUS_2 - 1], esc2s[MAX_ARG_NUM_PLUS_2 - 1];
+  const char *bit_fields[MAX_ARG_NUM_PLUS_2 - 1];
+
+  if (!format)
+    return -1;
+
+  return loongarch_parse_format (format, esc1s, esc2s, bit_fields);
+}
+
+int
+loongarch_check_macro (const char *format, const char *macro)
+{
+  int num_of_args;
+  char esc1s[MAX_ARG_NUM_PLUS_2 - 1], esc2s[MAX_ARG_NUM_PLUS_2 - 1];
+  const char *bit_fields[MAX_ARG_NUM_PLUS_2 - 1];
+
+  if (!format || !macro ||
+      loongarch_parse_format (format, esc1s, esc2s, bit_fields) != 0)
+    return -1;
+
+  for (num_of_args = 0; esc1s[num_of_args]; num_of_args++)
+    ;
+
+  for (; macro[0]; macro++)
+    if (macro[0] == '%')
+      {
+        macro++;
+        if ('1' <= macro[0] && macro[0] <= '9')
+          {
+            if (num_of_args < macro[0] - '0')
+              /* out of args num */
+              return -1;
+          }
+        else if (macro[0] == 'f')
+          ;
+        else if (macro[0] == '%')
+          ;
+        else
+          return -1;
+      }
+  return 0;
+}
+
+static const char *
+I (char esc_ch1 ATTRIBUTE_UNUSED, char esc_ch2 ATTRIBUTE_UNUSED,
+   const char *c_str)
+{
+  return c_str;
+}
+
+char *
+loongarch_expand_macro_with_format_map (
+  const char *format, const char *macro, const char *const arg_strs[],
+  const char *(*map) (char esc1, char esc2, const char *arg),
+  char *(*helper) (const char *const arg_strs[], void *context), void *context)
+{
+  char esc1s[MAX_ARG_NUM_PLUS_2 - 1], esc2s[MAX_ARG_NUM_PLUS_2 - 1];
+  const char *bit_fields[MAX_ARG_NUM_PLUS_2 - 1];
+  const char *src;
+  char *dest;
+  char buffer[8192];
+
+  if (format)
+    loongarch_parse_format (format, esc1s, esc2s, bit_fields);
+
+  src = macro;
+  dest = buffer;
+
+  while (*src)
+    if (*src == '%')
+      {
+        src++;
+        if ('1' <= *src && *src <= '9')
+          {
+            size_t i = *src - '1';
+            const char *t = map (esc1s[i], esc2s[i], arg_strs[i]);
+            while (*t)
+              *dest++ = *t++;
+          }
+        else if (*src == '%')
+          *dest++ = '%';
+        else if (*src == 'f' && helper)
+          {
+            char *b, *t;
+            t = b = (*helper) (arg_strs, context);
+            if (b)
+              {
+                while (*t)
+                  *dest++ = *t++;
+                free (b);
+              }
+          }
+        src++;
+      }
+    else
+      *dest++ = *src++;
+
+  *dest = '\0';
+  return strdup (buffer);
+}
+
+char *
+loongarch_expand_macro (const char *macro, const char *const arg_strs[],
+                        char *(*helper) (const char *const arg_strs[],
+                                         void *context),
+                        void *context)
+{
+  return loongarch_expand_macro_with_format_map (NULL, macro, arg_strs, I,
+                                                 helper, context);
+}
+
+size_t
+loongarch_bits_imm_needed (int64_t imm, int si)
+{
+  size_t ret;
+  if (si)
+    {
+      if (imm < 0)
+        {
+          for (ret = 0; imm < 0; imm <<= 1, ret++)
+            ;
+          ret = 64 - ret + 1;
+        }
+      else
+        ret = loongarch_bits_imm_needed (imm, 0) + 1;
+    }
+  else
+    {
+      uint64_t t = imm;
+      for (ret = 0; t; t >>= 1, ret++)
+        ;
+    }
+  return ret;
+}
+
+void
+loongarch_eliminate_adjacent_repeat_char (char *dest, char c)
+{
+  if (c == '\0')
+    return;
+  char *src = dest;
+  while (*dest)
+    {
+      while (src[0] == c && src[0] == src[1])
+        src++;
+      *dest++ = *src++;
+    }
+}
diff --git a/opcodes/loongarch-dis.c b/opcodes/loongarch-dis.c
new file mode 100644
index 00000000000..6c6cb8ceb16
--- /dev/null
+++ b/opcodes/loongarch-dis.c
@@ -0,0 +1,332 @@
+/* loongarch opcode support.
+   Copyright (C) 2021-2021 Free Software Foundation, Inc.
+   Contributed by Loongson Ltd.
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+
+#include "sysdep.h"
+#include "disassemble.h"
+#include "opintl.h"
+#include "opcode/loongarch.h"
+#include <stdlib.h>
+
+static const struct loongarch_opcode *
+get_loongarch_opcode_by_binfmt (insn_t insn)
+{
+  const struct loongarch_opcode *it;
+  struct loongarch_ase *ase;
+  size_t i;
+  for (ase = loongarch_ASEs; ase->enabled; ase++)
+    {
+      if (!*ase->enabled || (ase->include && !*ase->include) ||
+          (ase->exclude && *ase->exclude))
+        continue;
+
+      if (!ase->opc_htab_inited)
+        {
+          for (it = ase->opcodes; it->mask; it++)
+            if (!ase->opc_htab[LARCH_INSN_OPC (it->match)] &&
+                it->macro == NULL)
+              ase->opc_htab[LARCH_INSN_OPC (it->match)] = it;
+          for (i = 0; i < 16; i++)
+            if (!ase->opc_htab[i])
+              ase->opc_htab[i] = it;
+          ase->opc_htab_inited = 1;
+        }
+
+      it = ase->opc_htab[LARCH_INSN_OPC (insn)];
+      for (; it->name; it++)
+        if ((insn & it->mask) == it->match && it->mask &&
+            !(it->include && !*it->include) && !(it->exclude && *it->exclude))
+          return it;
+    }
+  return NULL;
+}
+
+static const char *const *loongarch_r_disname = NULL;
+static const char *const *loongarch_f_disname = NULL;
+static const char *const *loongarch_c_disname = NULL;
+static const char *const *loongarch_cr_disname = NULL;
+static const char *const *loongarch_v_disname = NULL;
+static const char *const *loongarch_x_disname = NULL;
+
+static void
+set_default_loongarch_dis_options (void)
+{
+  LARCH_opts.ase_test = 1;
+  LARCH_opts.ase_fix = 1;
+  LARCH_opts.ase_float = 1;
+  LARCH_opts.ase_128vec = 1;
+  LARCH_opts.ase_256vec = 1;
+
+  loongarch_r_disname = loongarch_r_normal_name;
+  loongarch_f_disname = loongarch_f_normal_name;
+  loongarch_c_disname = loongarch_c_normal_name;
+  loongarch_cr_disname = loongarch_cr_normal_name;
+  loongarch_v_disname = loongarch_v_normal_name;
+  loongarch_x_disname = loongarch_x_normal_name;
+}
+
+static int
+parse_loongarch_dis_option (const char *option ATTRIBUTE_UNUSED)
+{
+  return -1;
+}
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wstack-usage="
+static int
+parse_loongarch_dis_options (const char *opts_in)
+{
+  set_default_loongarch_dis_options ();
+
+  if (opts_in == NULL)
+    return 0;
+
+  char opts[strlen (opts_in) + 1], *opt, *opt_end;
+  strcpy (opts, opts_in);
+
+  for (opt = opt_end = opts; opt_end != NULL; opt = opt_end + 1)
+    {
+      if ((opt_end = strchr (opt, ',')) != NULL)
+        *opt_end = 0;
+      if (parse_loongarch_dis_option (opt) != 0)
+        return -1;
+    }
+  return 0;
+}
+#pragma GCC diagnostic pop
+
+static int32_t
+dis_one_arg (char esc1, char esc2, const char *bit_field,
+             const char *arg ATTRIBUTE_UNUSED, void *context)
+{
+  static int need_comma = 0;
+  struct disassemble_info *info = context;
+  insn_t insn = *(insn_t *) info->private_data;
+  int32_t imm, u_imm;
+
+  if (esc1)
+    {
+      if (need_comma)
+        info->fprintf_func (info->stream, ",");
+      need_comma = 1;
+      imm = loongarch_decode_imm (bit_field, insn, 1);
+      u_imm = loongarch_decode_imm (bit_field, insn, 0);
+    }
+
+  switch (esc1)
+    {
+    case 'r':
+      info->fprintf_func (info->stream, "%s", loongarch_r_disname[u_imm]);
+      break;
+    case 'f':
+      info->fprintf_func (info->stream, "%s", loongarch_f_disname[u_imm]);
+      break;
+    case 'c':
+      switch (esc2)
+        {
+        case 'r':
+          info->fprintf_func (info->stream, "%s", loongarch_cr_disname[u_imm]);
+          break;
+        default:
+          info->fprintf_func (info->stream, "%s", loongarch_c_disname[u_imm]);
+        }
+      break;
+    case 'v':
+      info->fprintf_func (info->stream, "%s", loongarch_v_disname[u_imm]);
+      break;
+    case 'x':
+      info->fprintf_func (info->stream, "%s", loongarch_x_disname[u_imm]);
+      break;
+    case 'u':
+      info->fprintf_func (info->stream, "0x%x", u_imm);
+      break;
+    case 's':
+      if (imm == 0)
+        info->fprintf_func (info->stream, "%d", imm);
+      else
+        info->fprintf_func (info->stream, "%d(0x%x)", imm, u_imm);
+      switch (esc2)
+        {
+        case 'b':
+          info->insn_type = dis_branch;
+          info->target += imm;
+        }
+      break;
+    case '\0':
+      need_comma = 0;
+    }
+  return 0;
+}
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wstack-usage="
+static void
+disassemble_one (insn_t insn, struct disassemble_info *info)
+{
+  const struct loongarch_opcode *opc = get_loongarch_opcode_by_binfmt (insn);
+
+#ifdef LOONGARCH_DEBUG
+  char have_space[32] = { 0 };
+  insn_t t;
+  int i;
+  const char *t_f = opc ? opc->format : NULL;
+  if (t_f)
+    while (*t_f)
+      {
+        while (('a' <= t_f[0] && t_f[0] <= 'z') ||
+               ('A' <= t_f[0] && t_f[0] <= 'Z') t_f[0] == ',')
+          t_f++;
+        while (1)
+          {
+            i = strtol (t_f, &t_f, 10);
+            have_space[i] = 1;
+            t_f++; /* ':' */
+            i += strtol (t_f, &t_f, 10);
+            have_space[i] = 1;
+            if (t_f[0] == '|')
+              t_f++;
+            else
+              break;
+          }
+        if (t_f[0] == '<')
+          t_f += 2; /* '<' '<' */
+        strtol (t_f, &t_f, 10);
+      }
+
+  have_space[28] = 1;
+  have_space[0] = 0;
+  t = ~((insn_t) -1 >> 1);
+  for (i = 31; 0 <= i; i--)
+    {
+      if (t & insn)
+        info->fprintf_func (info->stream, "1");
+      else
+        info->fprintf_func (info->stream, "0");
+      if (have_space[i])
+        info->fprintf_func (info->stream, " ");
+      t = t >> 1;
+    }
+  info->fprintf_func (info->stream, "\t");
+#endif
+
+  if (!opc)
+    {
+      info->insn_type = dis_noninsn;
+      info->fprintf_func (info->stream, "0x%08x", insn);
+      return;
+    }
+
+  info->insn_type = dis_nonbranch;
+  info->fprintf_func (info->stream, "%s", opc->name);
+
+  {
+    char fake_args[strlen (opc->format) + 1];
+    const char *fake_arg_strs[MAX_ARG_NUM_PLUS_2];
+    strcpy (fake_args, opc->format);
+    if (0 < loongarch_split_args_by_comma (fake_args, fake_arg_strs))
+      info->fprintf_func (info->stream, "\t");
+    info->private_data = &insn;
+    loongarch_foreach_args (opc->format, fake_arg_strs, dis_one_arg, info);
+  }
+
+  if (info->insn_type == dis_branch || info->insn_type == dis_condbranch
+      /* || someother if we have extra info to print */)
+    info->fprintf_func (info->stream, " #");
+
+  if (info->insn_type == dis_branch || info->insn_type == dis_condbranch)
+    {
+      info->fprintf_func (info->stream, " ");
+      info->print_address_func (info->target, info);
+    }
+}
+#pragma GCC diagnostic pop
+
+int
+print_insn_loongarch (bfd_vma memaddr, struct disassemble_info *info)
+{
+  insn_t insn;
+  int status;
+
+  static int not_init_yet = 1;
+  if (not_init_yet)
+    {
+      parse_loongarch_dis_options (info->disassembler_options);
+      not_init_yet = 0;
+    }
+
+  info->bytes_per_chunk = 4;
+  info->bytes_per_line = 4;
+  info->display_endian = BFD_ENDIAN_LITTLE;
+  info->insn_info_valid = 1;
+  info->target = memaddr;
+
+  if ((status = info->read_memory_func (memaddr, (bfd_byte *) &insn,
+                                        sizeof (insn), info)) != 0)
+    {
+      info->memory_error_func (status, memaddr, info);
+      return -1; /* loongarch_insn_length (0); */
+    }
+
+  disassemble_one (insn, info);
+
+  return loongarch_insn_length (insn);
+}
+
+void
+print_loongarch_disassembler_options (FILE *stream)
+{
+  fprintf (stream, _ ("\n\
+		       LARCH:\n"));
+
+  fprintf (stream, _ ("\n"));
+}
+
+int
+loongarch_parse_dis_options (const char *opts_in)
+{
+  return parse_loongarch_dis_options (opts_in);
+}
+
+static void
+my_print_address_func (bfd_vma addr, struct disassemble_info *dinfo)
+{
+  dinfo->fprintf_func (dinfo->stream, "0x%llx", (long long) addr);
+}
+
+void
+loongarch_disassemble_one (int64_t pc, insn_t insn,
+                           int (*fprintf_func) (void *stream,
+                                                const char *format, ...),
+                           void *stream)
+{
+  static struct disassemble_info my_disinfo = {
+    .print_address_func = my_print_address_func,
+  };
+  static int not_init_yet = 1;
+  if (not_init_yet)
+    {
+      loongarch_parse_dis_options (NULL);
+      not_init_yet = 0;
+    }
+
+  my_disinfo.fprintf_func = fprintf_func;
+  my_disinfo.stream = stream;
+  my_disinfo.target = pc;
+  disassemble_one (insn, &my_disinfo);
+}
diff --git a/opcodes/loongarch-opc.c b/opcodes/loongarch-opc.c
new file mode 100644
index 00000000000..7de81d47c82
--- /dev/null
+++ b/opcodes/loongarch-opc.c
@@ -0,0 +1,781 @@
+/* loongarch opcode support.
+   Copyright (C) 2021-2021 Free Software Foundation, Inc.
+   Contributed by Loongson Ltd.
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3. If not,
+   see <http://www.gnu.org/licenses/>.  */
+
+#include <stddef.h>
+#include "opcode/loongarch.h"
+
+struct loongarch_ASEs_option LARCH_opts = 
+{
+  .ase_test = 0,
+  .ase_fix = 0,
+  .ase_float = 0,
+  .ase_128vec = 0,
+  .ase_256vec = 0,
+
+  .addrwidth_is_32 = 0,
+  .addrwidth_is_64 = 0,
+  .rlen_is_32 = 0,
+  .rlen_is_64 = 0,
+  .la_local_with_abs = 0,
+  .la_global_with_pcrel = 0,
+  .la_global_with_abs = 0,
+
+  .abi_is_lp32 = 0,
+  .abi_is_lp64 = 0,
+};
+
+size_t
+loongarch_insn_length (insn_t insn)
+{
+  return insn ? 4 : 4; /* eliminate warning */
+}
+
+const char *const loongarch_r_normal_name[32] = 
+{
+  "$r0",  "$r1",  "$r2",  "$r3",  "$r4",  "$r5",  "$r6",  "$r7",
+  "$r8",  "$r9",  "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
+  "$r16", "$r17", "$r18", "$r19", "$r20", "$r21", "$r22", "$r23",
+  "$r24", "$r25", "$r26", "$r27", "$r28", "$r29", "$r30", "$r31",
+};
+
+const char *const loongarch_r_lp64_name[32] = 
+{
+  "$zero", "$ra", "$tp", "$sp", "$a0", "$a1", "$a2", "$a3",
+  "$a4",   "$a5", "$a6", "$a7", "$t0", "$t1", "$t2", "$t3",
+  "$t4",   "$t5", "$t6", "$t7", "$t8", "$x",  "$fp", "$s0",
+  "$s1",   "$s2", "$s3", "$s4", "$s5", "$s6", "$s7", "$s8",
+};
+
+const char *const loongarch_r_lp64_name1[32] = 
+{
+  "", "", "", "", "$v0", "$v1", "", "", "", "", "", "", "", "", "", "",
+  "", "", "", "", "",    "",    "", "", "", "", "", "", "", "", "", "",
+};
+
+const char *const loongarch_f_normal_name[32] = 
+{
+  "$f0",  "$f1",  "$f2",  "$f3",  "$f4",  "$f5",  "$f6",  "$f7",
+  "$f8",  "$f9",  "$f10", "$f11", "$f12", "$f13", "$f14", "$f15",
+  "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23",
+  "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31",
+};
+
+const char *const loongarch_f_lp64_name[32] = 
+{
+  "$fa0", "$fa1", "$fa2",  "$fa3",  "$fa4",  "$fa5",  "$fa6",  "$fa7",
+  "$ft0", "$ft1", "$ft2",  "$ft3",  "$ft4",  "$ft5",  "$ft6",  "$ft7",
+  "$ft8", "$ft9", "$ft10", "$ft11", "$ft12", "$ft13", "$ft14", "$ft15",
+  "$fs0", "$fs1", "$fs2",  "$fs3",  "$fs4",  "$fs5",  "$fs6",  "$fs7",
+};
+
+const char *const loongarch_f_lp64_name1[32] = 
+{
+  "$fv0", "$fv1", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+  "",     "",     "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+};
+
+const char *const loongarch_c_normal_name[8] = 
+{
+  "$fcc0", "$fcc1", "$fcc2", "$fcc3", "$fcc4", "$fcc5", "$fcc6", "$fcc7",
+};
+
+const char *const loongarch_cr_normal_name[4] = 
+{
+  "$scr0",
+  "$scr1",
+  "$scr2",
+  "$scr3",
+};
+
+const char *const loongarch_v_normal_name[32] = 
+{
+  "$vr0",  "$vr1",  "$vr2",  "$vr3",  "$vr4",  "$vr5",  "$vr6",  "$vr7",
+  "$vr8",  "$vr9",  "$vr10", "$vr11", "$vr12", "$vr13", "$vr14", "$vr15",
+  "$vr16", "$vr17", "$vr18", "$vr19", "$vr20", "$vr21", "$vr22", "$vr23",
+  "$vr24", "$vr25", "$vr26", "$vr27", "$vr28", "$vr29", "$vr30", "$vr31",
+};
+
+const char *const loongarch_x_normal_name[32] = 
+{
+  "$xr0",  "$xr1",  "$xr2",  "$xr3",  "$xr4",  "$xr5",  "$xr6",  "$xr7",
+  "$xr8",  "$xr9",  "$xr10", "$xr11", "$xr12", "$xr13", "$xr14", "$xr15",
+  "$xr16", "$xr17", "$xr18", "$xr19", "$xr20", "$xr21", "$xr22", "$xr23",
+  "$xr24", "$xr25", "$xr26", "$xr27", "$xr28", "$xr29", "$xr30", "$xr31",
+};
+
+static struct loongarch_opcode loongarch_macro_opcodes[] = 
+{
+  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  {0, 0, "li.w", "r,sc", "%f", 0, 0, 0},
+  {0, 0, "li.d", "r,sc", "%f", 0, 0, 0},
+  { 0, 0, "la", "r,la", "la.global %1,%2", 0, 0, 0 },
+
+  { 0, 0, "la.global", "r,la", "la.pcrel %1,%2",
+    &LARCH_opts.la_global_with_pcrel, 0, 0 },
+  { 0, 0, "la.global", "r,r,la", "la.pcrel %1,%2,%3",
+    &LARCH_opts.la_global_with_pcrel, 0, 0 },
+  { 0, 0, "la.global", "r,la", "la.abs %1,%2", &LARCH_opts.la_global_with_abs,
+    0, 0 },
+  { 0, 0, "la.global", "r,r,la", "la.abs %1,%3",
+    &LARCH_opts.la_global_with_abs, 0, 0 },
+  { 0, 0, "la.global", "r,l", "la.got %1,%2", 0, 0, 0 },
+  { 0, 0, "la.global", "r,r,l", "la.got %1,%2,%3", 0, 0, 0 },
+
+  { 0, 0, "la.local", "r,la", "la.abs %1,%2", &LARCH_opts.la_local_with_abs, 0,
+    0 },
+  { 0, 0, "la.local", "r,r,la", "la.abs %1,%3", &LARCH_opts.la_local_with_abs,
+    0, 0 },
+  { 0, 0, "la.local", "r,la", "la.pcrel %1,%2", 0, 0, 0 },
+  { 0, 0, "la.local", "r,r,la", "la.pcrel %1,%2,%3", 0, 0, 0 },
+
+  { 0, 0, "la.abs", "r,la",
+    "lu12i.w %1,%%abs(%2)>>12;"
+    "ori %1,%1,%%abs(%2)&0xfff;",
+    &LARCH_opts.addrwidth_is_32, 0, 0 },
+  { 0, 0, "la.abs", "r,la",
+    "lu12i.w %1,%%abs(%2)<<32>>44;"
+    "ori %1,%1,%%abs(%2)&0xfff;"
+    "lu32i.d %1,%%abs(%2)<<12>>44;"
+    "lu52i.d %1,%1,%%abs(%2)>>52;",
+    &LARCH_opts.addrwidth_is_64, 0, 0 },
+
+  { 0, 0, "la.pcrel", "r,la",
+    "pcaddu12i %1,%%pcrel(%2+0x800)<<32>>44;"
+    "addi.w %1,%1,%%pcrel(%2+4)-(%%pcrel(%2+4+0x800)>>12<<12);",
+    &LARCH_opts.addrwidth_is_32, 0, 0 },
+
+  { 0, 0, "la.pcrel", "r,la",
+    "pcaddu12i %1,%%pcrel(%2+0x800)>>12;"
+    "addi.d %1,%1,%%pcrel(%2+4)-(%%pcrel(%2+4+0x800)>>12<<12);",
+    &LARCH_opts.addrwidth_is_64, 0, 0 },
+  { 0, 0, "la.pcrel", "r,r,la",
+    "pcaddu12i %1,(%%pcrel(%3)-(%%pcrel(%3+0x80000000)>>32<<32))<<32>>44;"
+    "ori %2,$r0,(%%pcrel(%3+4)-(%%pcrel(%3+4+0x80000000)>>32<<32))&0xfff;"
+    "lu32i.d %2,%%pcrel(%3+8+0x80000000)<<12>>44;"
+    "lu52i.d %2,%2,%%pcrel(%3+12+0x80000000)>>52;"
+    "add.d %1,%1,%2;",
+    &LARCH_opts.addrwidth_is_64, 0, 0 },
+
+  { 0, 0, "la.got", "r,l",
+    "pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_+0x800)+%%gprel(%2))<<32>>44;"
+    "ld.w "
+    "%1,%1,%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%gprel(%2)-((%%pcrel(_GLOBAL_"
+    "OFFSET_TABLE_+4+0x800)+%%gprel(%2))>>12<<12);",
+    &LARCH_opts.addrwidth_is_32, 0, 0 },
+
+  { 0, 0, "la.got", "r,l",
+    "pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_+0x800)+%%gprel(%2))>>12;"
+    "ld.d "
+    "%1,%1,%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%gprel(%2)-((%%pcrel(_GLOBAL_"
+    "OFFSET_TABLE_+4+0x800)+%%gprel(%2))>>12<<12);",
+    &LARCH_opts.addrwidth_is_64, 0, 0 },
+  { 0, 0, "la.got", "r,r,l",
+    "pcaddu12i "
+    "%1,(%%pcrel(_GLOBAL_OFFSET_TABLE_)+%%gprel(%3)-((%%pcrel(_GLOBAL_OFFSET_"
+    "TABLE_+0x80000000)+%%gprel(%3))>>32<<32))<<32>>44;"
+    "ori "
+    "%2,$r0,(%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%gprel(%3)-((%%pcrel(_GLOBAL_"
+    "OFFSET_TABLE_+4+0x80000000)+%%gprel(%3))>>32<<32))&0xfff;"
+    "lu32i.d "
+    "%2,(%%pcrel(_GLOBAL_OFFSET_TABLE_+8+0x80000000)+%%gprel(%3))<<12>>44;"
+    "lu52i.d "
+    "%2,%2,(%%pcrel(_GLOBAL_OFFSET_TABLE_+12+0x80000000)+%%gprel(%3))>>52;"
+    "ldx.d %1,%1,%2;",
+    &LARCH_opts.addrwidth_is_64, 0, 0 },
+
+  { 0, 0, "la.tls.le", "r,la",
+    "lu12i.w %1,%%tprel(%2)>>12;"
+    "ori %1,%1,%%tprel(%2)&0xfff",
+    &LARCH_opts.addrwidth_is_32, 0, 0 },
+  /* {0, 0, "la.tls.le", "r,la",
+  * "lu12i.w %1,%%tprel(%2)>>12;"
+  * "ori %1,%1,%%tprel(%2)&0xfff"
+  * , &LARCH_opts.addrwidth_is_64, 0, 0}, */
+  { 0, 0, "la.tls.le", "r,la",
+    "lu12i.w %1,%%tprel(%2)<<32>>44;"
+    "ori %1,%1,%%tprel(%2)&0xfff;"
+    "lu32i.d %1,%%tprel(%2)<<12>>44;"
+    "lu52i.d %1,%1,%%tprel(%2)>>52;",
+    &LARCH_opts.addrwidth_is_64, 0, 0 },
+
+  { 0, 0, "la.tls.ie", "r,l",
+    "pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_+0x800)+%%tlsgot(%2))<<32>>44;"
+    "ld.w "
+    "%1,%1,%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%tlsgot(%2)-((%%pcrel(_GLOBAL_"
+    "OFFSET_TABLE_+4+0x800)+%%tlsgot(%2))>>12<<12);",
+    &LARCH_opts.addrwidth_is_32, 0, 0 },
+
+  { 0, 0, "la.tls.ie", "r,l",
+    "pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_+0x800)+%%tlsgot(%2))>>12;"
+    "ld.d "
+    "%1,%1,%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%tlsgot(%2)-((%%pcrel(_GLOBAL_"
+    "OFFSET_TABLE_+4+0x800)+%%tlsgot(%2))>>12<<12);",
+    &LARCH_opts.addrwidth_is_64, 0, 0 },
+  { 0, 0, "la.tls.ie", "r,r,l",
+    "pcaddu12i "
+    "%1,(%%pcrel(_GLOBAL_OFFSET_TABLE_)+%%tlsgot(%3)-((%%pcrel(_GLOBAL_OFFSET_"
+    "TABLE_+0x80000000)+%%tlsgot(%3))>>32<<32))<<32>>44;"
+    "ori "
+    "%2,$r0,(%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%tlsgot(%3)-((%%pcrel(_GLOBAL_"
+    "OFFSET_TABLE_+4+0x80000000)+%%tlsgot(%3))>>32<<32))&0xfff;"
+    "lu32i.d "
+    "%2,(%%pcrel(_GLOBAL_OFFSET_TABLE_+8+0x80000000)+%%tlsgot(%3))<<12>>44;"
+    "lu52i.d "
+    "%2,%2,(%%pcrel(_GLOBAL_OFFSET_TABLE_+12+0x80000000)+%%tlsgot(%3))>>52;"
+    "ldx.d %1,%1,%2;",
+    &LARCH_opts.addrwidth_is_64, 0, 0 },
+
+  { 0, 0, "la.tls.ld", "r,l", "la.tls.gd %1,%2", 0, 0, 0 },
+  { 0, 0, "la.tls.ld", "r,r,l", "la.tls.gd %1,%2,%3",
+    &LARCH_opts.addrwidth_is_64, 0, 0 },
+
+  { 0, 0, "la.tls.gd", "r,l",
+    "pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_+0x800)+%%tlsgd(%2))<<32>>44;"
+    "addi.w "
+    "%1,%1,%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%tlsgd(%2)-((%%pcrel(_GLOBAL_"
+    "OFFSET_TABLE_+4+0x800)+%%tlsgd(%2))>>12<<12);",
+    &LARCH_opts.addrwidth_is_32, 0, 0 },
+
+  { 0, 0, "la.tls.gd", "r,l",
+    "pcaddu12i %1,(%%pcrel(_GLOBAL_OFFSET_TABLE_+0x800)+%%tlsgd(%2))>>12;"
+    "addi.d "
+    "%1,%1,%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%tlsgd(%2)-((%%pcrel(_GLOBAL_"
+    "OFFSET_TABLE_+4+0x800)+%%tlsgd(%2))>>12<<12);",
+    &LARCH_opts.addrwidth_is_64, 0, 0 },
+  { 0, 0, "la.tls.gd", "r,r,l",
+    "pcaddu12i "
+    "%1,(%%pcrel(_GLOBAL_OFFSET_TABLE_)+%%tlsgd(%3)-((%%pcrel(_GLOBAL_OFFSET_"
+    "TABLE_+0x80000000)+%%tlsgd(%3))>>32<<32))<<32>>44;"
+    "ori "
+    "%2,$r0,(%%pcrel(_GLOBAL_OFFSET_TABLE_+4)+%%tlsgd(%3)-((%%pcrel(_GLOBAL_"
+    "OFFSET_TABLE_+4+0x80000000)+%%tlsgd(%3))>>32<<32))&0xfff;"
+    "lu32i.d "
+    "%2,(%%pcrel(_GLOBAL_OFFSET_TABLE_+8+0x80000000)+%%tlsgd(%3))<<12>>44;"
+    "lu52i.d "
+    "%2,%2,(%%pcrel(_GLOBAL_OFFSET_TABLE_+12+0x80000000)+%%tlsgd(%3))>>52;"
+    "add.d %1,%1,%2;",
+    &LARCH_opts.addrwidth_is_64, 0, 0 },
+
+  { 0 } /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_fix_opcodes[] = 
+{
+  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  { 0x00001000, 0xfffffc00, "clo.w", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00001400, 0xfffffc00, "clz.w", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00001800, 0xfffffc00, "cto.w", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00001c00, 0xfffffc00, "ctz.w", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00002000, 0xfffffc00, "clo.d", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00002400, 0xfffffc00, "clz.d", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00002800, 0xfffffc00, "cto.d", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00002c00, 0xfffffc00, "ctz.d", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00003000, 0xfffffc00, "revb.2h", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00003400, 0xfffffc00, "revb.4h", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00003800, 0xfffffc00, "revb.2w", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00003c00, 0xfffffc00, "revb.d", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00004000, 0xfffffc00, "revh.2w", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00004400, 0xfffffc00, "revh.d", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00004800, 0xfffffc00, "bitrev.4b", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00004c00, 0xfffffc00, "bitrev.8b", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00005000, 0xfffffc00, "bitrev.w", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00005400, 0xfffffc00, "bitrev.d", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00005800, 0xfffffc00, "ext.w.h", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00005c00, 0xfffffc00, "ext.w.b", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00150000, 0xfffffc00, "move", "r0:5,r5:5", 0 /* or %1,%2,$r0 */, 0, 0, 0 },
+  { 0x00006000, 0xfffffc00, "rdtimel.w", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00006400, 0xfffffc00, "rdtimeh.w", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00006800, 0xfffffc00, "rdtime.d", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00006c00, 0xfffffc00, "cpucfg", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x00010000, 0xffff801f, "asrtle.d", "r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00018000, 0xffff801f, "asrtgt.d", "r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00040000, 0xfffe0000, "alsl.w", "r0:5,r5:5,r10:5,u15:2+1", 0, 0, 0, 0 },
+  { 0x00060000, 0xfffe0000, "alsl.wu", "r0:5,r5:5,r10:5,u15:2+1", 0, 0, 0, 0 },
+  { 0x00080000, 0xfffe0000, "bytepick.w", "r0:5,r5:5,r10:5,u15:2", 0, 0, 0,0 },
+  { 0x000c0000, 0xfffc0000, "bytepick.d", "r0:5,r5:5,r10:5,u15:3", 0, 0, 0,0 },
+  { 0x00100000, 0xffff8000, "add.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00108000, 0xffff8000, "add.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00110000, 0xffff8000, "sub.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00118000, 0xffff8000, "sub.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00120000, 0xffff8000, "slt", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00128000, 0xffff8000, "sltu", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00130000, 0xffff8000, "maskeqz", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00138000, 0xffff8000, "masknez", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00140000, 0xffff8000, "nor", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00148000, 0xffff8000, "and", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00150000, 0xffff8000, "or", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00158000, 0xffff8000, "xor", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00160000, 0xffff8000, "orn", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00168000, 0xffff8000, "andn", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00170000, 0xffff8000, "sll.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00178000, 0xffff8000, "srl.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00180000, 0xffff8000, "sra.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00188000, 0xffff8000, "sll.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00190000, 0xffff8000, "srl.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00198000, 0xffff8000, "sra.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x001b0000, 0xffff8000, "rotr.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x001b8000, 0xffff8000, "rotr.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x001c0000, 0xffff8000, "mul.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x001c8000, 0xffff8000, "mulh.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x001d0000, 0xffff8000, "mulh.wu", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x001d8000, 0xffff8000, "mul.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x001e0000, 0xffff8000, "mulh.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x001e8000, 0xffff8000, "mulh.du", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x001f0000, 0xffff8000, "mulw.d.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x001f8000, 0xffff8000, "mulw.d.wu", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00200000, 0xffff8000, "div.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00208000, 0xffff8000, "mod.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00210000, 0xffff8000, "div.wu", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00218000, 0xffff8000, "mod.wu", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00220000, 0xffff8000, "div.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00228000, 0xffff8000, "mod.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00230000, 0xffff8000, "div.du", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00238000, 0xffff8000, "mod.du", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00240000, 0xffff8000, "crc.w.b.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00248000, 0xffff8000, "crc.w.h.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00250000, 0xffff8000, "crc.w.w.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00258000, 0xffff8000, "crc.w.d.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00260000, 0xffff8000, "crcc.w.b.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00268000, 0xffff8000, "crcc.w.h.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00270000, 0xffff8000, "crcc.w.w.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x00278000, 0xffff8000, "crcc.w.d.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x002a0000, 0xffff8000, "break", "u0:15", 0, 0, 0, 0 },
+  { 0x002a8000, 0xffff8000, "dbcl", "u0:15", 0, 0, 0, 0 },
+  { 0x002b0000, 0xffff8000, "syscall", "u0:15", 0, 0, 0, 0 },
+  { 0x002c0000, 0xfffe0000, "alsl.d", "r0:5,r5:5,r10:5,u15:2+1", 0, 0, 0, 0 },
+  { 0x00408000, 0xffff8000, "slli.w", "r0:5,r5:5,u10:5", 0, 0, 0, 0 },
+  { 0x00410000, 0xffff0000, "slli.d", "r0:5,r5:5,u10:6", 0, 0, 0, 0 },
+  { 0x00448000, 0xffff8000, "srli.w", "r0:5,r5:5,u10:5", 0, 0, 0, 0 },
+  { 0x00450000, 0xffff0000, "srli.d", "r0:5,r5:5,u10:6", 0, 0, 0, 0 },
+  { 0x00488000, 0xffff8000, "srai.w", "r0:5,r5:5,u10:5", 0, 0, 0, 0 },
+  { 0x00490000, 0xffff0000, "srai.d", "r0:5,r5:5,u10:6", 0, 0, 0, 0 },
+  { 0x004c8000, 0xffff8000, "rotri.w", "r0:5,r5:5,u10:5", 0, 0, 0, 0 },
+  { 0x004d0000, 0xffff0000, "rotri.d", "r0:5,r5:5,u10:6", 0, 0, 0, 0 },
+  { 0x00600000, 0xffe08000, "bstrins.w", "r0:5,r5:5,u16:5,u10:5", 0, 0, 0, 0 },
+  { 0x00608000, 0xffe08000, "bstrpick.w", "r0:5,r5:5,u16:5,u10:5", 0, 0, 0,0 },
+  { 0x00800000, 0xffc00000, "bstrins.d", "r0:5,r5:5,u16:6,u10:6", 0, 0, 0, 0 },
+  { 0x00c00000, 0xffc00000, "bstrpick.d", "r0:5,r5:5,u16:6,u10:6", 0, 0, 0,0 },
+  { 0 } /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_float_opcodes[] = 
+{
+  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  { 0x01008000, 0xffff8000, "fadd.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01010000, 0xffff8000, "fadd.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01028000, 0xffff8000, "fsub.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01030000, 0xffff8000, "fsub.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01048000, 0xffff8000, "fmul.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01050000, 0xffff8000, "fmul.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01068000, 0xffff8000, "fdiv.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01070000, 0xffff8000, "fdiv.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01088000, 0xffff8000, "fmax.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01090000, 0xffff8000, "fmax.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x010a8000, 0xffff8000, "fmin.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x010b0000, 0xffff8000, "fmin.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x010c8000, 0xffff8000, "fmaxa.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x010d0000, 0xffff8000, "fmaxa.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x010e8000, 0xffff8000, "fmina.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x010f0000, 0xffff8000, "fmina.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01108000, 0xffff8000, "fscaleb.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01110000, 0xffff8000, "fscaleb.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01128000, 0xffff8000, "fcopysign.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01130000, 0xffff8000, "fcopysign.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x01140400, 0xfffffc00, "fabs.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01140800, 0xfffffc00, "fabs.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01141400, 0xfffffc00, "fneg.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01141800, 0xfffffc00, "fneg.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01142400, 0xfffffc00, "flogb.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01142800, 0xfffffc00, "flogb.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01143400, 0xfffffc00, "fclass.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01143800, 0xfffffc00, "fclass.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01144400, 0xfffffc00, "fsqrt.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01144800, 0xfffffc00, "fsqrt.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01145400, 0xfffffc00, "frecip.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01145800, 0xfffffc00, "frecip.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01146400, 0xfffffc00, "frsqrt.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01146800, 0xfffffc00, "frsqrt.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01149400, 0xfffffc00, "fmov.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01149800, 0xfffffc00, "fmov.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x0114a400, 0xfffffc00, "movgr2fr.w", "f0:5,r5:5", 0, 0, 0, 0 },
+  { 0x0114a800, 0xfffffc00, "movgr2fr.d", "f0:5,r5:5", 0, 0, 0, 0 },
+  { 0x0114ac00, 0xfffffc00, "movgr2frh.w", "f0:5,r5:5", 0, 0, 0, 0 },
+  { 0x0114b400, 0xfffffc00, "movfr2gr.s", "r0:5,f5:5", 0, 0, 0, 0 },
+  { 0x0114b800, 0xfffffc00, "movfr2gr.d", "r0:5,f5:5", 0, 0, 0, 0 },
+  { 0x0114bc00, 0xfffffc00, "movfrh2gr.s", "r0:5,f5:5", 0, 0, 0, 0 },
+  { 0x0114c000, 0xfffffc00, "movgr2fcsr", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x0114c800, 0xfffffc00, "movfcsr2gr", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x0114d000, 0xfffffc18, "movfr2cf", "c0:3,f5:5", 0, 0, 0, 0 },
+  { 0x0114d400, 0xffffff00, "movcf2fr", "f0:5,c5:3", 0, 0, 0, 0 },
+  { 0x0114d800, 0xfffffc18, "movgr2cf", "c0:3,r5:5", 0, 0, 0, 0 },
+  { 0x0114dc00, 0xffffff00, "movcf2gr", "r0:5,c5:3", 0, 0, 0, 0 },
+  { 0x01191800, 0xfffffc00, "fcvt.s.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x01192400, 0xfffffc00, "fcvt.d.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011a0400, 0xfffffc00, "ftintrm.w.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011a0800, 0xfffffc00, "ftintrm.w.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011a2400, 0xfffffc00, "ftintrm.l.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011a2800, 0xfffffc00, "ftintrm.l.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011a4400, 0xfffffc00, "ftintrp.w.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011a4800, 0xfffffc00, "ftintrp.w.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011a6400, 0xfffffc00, "ftintrp.l.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011a6800, 0xfffffc00, "ftintrp.l.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011a8400, 0xfffffc00, "ftintrz.w.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011a8800, 0xfffffc00, "ftintrz.w.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011aa400, 0xfffffc00, "ftintrz.l.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011aa800, 0xfffffc00, "ftintrz.l.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011ac400, 0xfffffc00, "ftintrne.w.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011ac800, 0xfffffc00, "ftintrne.w.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011ae400, 0xfffffc00, "ftintrne.l.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011ae800, 0xfffffc00, "ftintrne.l.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011b0400, 0xfffffc00, "ftint.w.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011b0800, 0xfffffc00, "ftint.w.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011b2400, 0xfffffc00, "ftint.l.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011b2800, 0xfffffc00, "ftint.l.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011d1000, 0xfffffc00, "ffint.s.w", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011d1800, 0xfffffc00, "ffint.s.l", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011d2000, 0xfffffc00, "ffint.d.w", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011d2800, 0xfffffc00, "ffint.d.l", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011e4400, 0xfffffc00, "frint.s", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0x011e4800, 0xfffffc00, "frint.d", "f0:5,f5:5", 0, 0, 0, 0 },
+  { 0 } /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_lmm_opcodes[] = 
+{
+  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  { 0x02000000, 0xffc00000, "slti", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x02400000, 0xffc00000, "sltui", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x02800000, 0xffc00000, "addi.w", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x02c00000, 0xffc00000, "addi.d", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x03000000, 0xffc00000, "lu52i.d", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0, 0, "nop", "", "andi $r0,$r0,0", 0, 0, 0 },
+  { 0x03400000, 0xffc00000, "andi", "r0:5,r5:5,u10:12", 0, 0, 0, 0 },
+  { 0x03800000, 0xffc00000, "ori", "r0:5,r5:5,u10:12", 0, 0, 0, 0 },
+  { 0x03c00000, 0xffc00000, "xori", "r0:5,r5:5,u10:12", 0, 0, 0, 0 },
+  { 0x10000000, 0xfc000000, "addu16i.d", "r0:5,r5:5,s10:16", 0, 0, 0, 0 },
+  { 0x14000000, 0xfe000000, "lu12i.w", "r0:5,s5:20", 0, 0, 0, 0 },
+  { 0x16000000, 0xfe000000, "lu32i.d", "r0:5,s5:20", 0, 0, 0, 0 },
+  { 0x18000000, 0xfe000000, "pcaddi", "r0:5,s5:20", 0, 0, 0, 0 },
+  { 0x1a000000, 0xfe000000, "pcalau12i", "r0:5,s5:20", 0, 0, 0, 0 },
+  { 0x1c000000, 0xfe000000, "pcaddu12i", "r0:5,s5:20", 0, 0, 0, 0 },
+  { 0x1e000000, 0xfe000000, "pcaddu18i", "r0:5,s5:20", 0, 0, 0, 0 },
+  { 0 } /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_privilege_opcodes[] = 
+{
+  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  { 0x04000000, 0xff0003e0, "csrrd", "r0:5,u10:14", 0, 0, 0, 0 },
+  { 0x04000020, 0xff0003e0, "csrwr", "r0:5,u10:14", 0, 0, 0, 0 },
+  { 0x04000000, 0xff000000, "csrxchg", "r0:5,r5:5,u10:14", 0, 0, 0, 0 },
+  { 0x06000000, 0xffc00000, "cacop", "u0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x06400000, 0xfffc0000, "lddir", "r0:5,r5:5,u10:8", 0, 0, 0, 0 },
+  { 0x06440000, 0xfffc001f, "ldpte", "r5:5,u10:8", 0, 0, 0, 0 },
+  { 0x06480000, 0xfffffc00, "iocsrrd.b", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x06480400, 0xfffffc00, "iocsrrd.h", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x06480800, 0xfffffc00, "iocsrrd.w", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x06480c00, 0xfffffc00, "iocsrrd.d", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x06481000, 0xfffffc00, "iocsrwr.b", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x06481400, 0xfffffc00, "iocsrwr.h", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x06481800, 0xfffffc00, "iocsrwr.w", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x06481c00, 0xfffffc00, "iocsrwr.d", "r0:5,r5:5", 0, 0, 0, 0 },
+  { 0x06482000, 0xffffffff, "tlbclr", "", 0, 0, 0, 0 },
+  { 0x06482400, 0xffffffff, "tlbflush", "", 0, 0, 0, 0 },
+  { 0x06482800, 0xffffffff, "tlbsrch", "", 0, 0, 0, 0 },
+  { 0x06482c00, 0xffffffff, "tlbrd", "", 0, 0, 0, 0 },
+  { 0x06483000, 0xffffffff, "tlbwr", "", 0, 0, 0, 0 },
+  { 0x06483400, 0xffffffff, "tlbfill", "", 0, 0, 0, 0 },
+  { 0x06483800, 0xffffffff, "ertn", "", 0, 0, 0, 0 },
+  { 0x06488000, 0xffff8000, "idle", "u0:15", 0, 0, 0, 0 },
+  { 0x06498000, 0xffff8000, "invtlb", "u0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0 } /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_4opt_opcodes[] = 
+{
+  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  { 0x08100000, 0xfff00000, "fmadd.s", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0 },
+  { 0x08200000, 0xfff00000, "fmadd.d", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0 },
+  { 0x08500000, 0xfff00000, "fmsub.s", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0 },
+  { 0x08600000, 0xfff00000, "fmsub.d", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0 },
+  { 0x08900000, 0xfff00000, "fnmadd.s", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0 },
+  { 0x08a00000, 0xfff00000, "fnmadd.d", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0 },
+  { 0x08d00000, 0xfff00000, "fnmsub.s", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0 },
+  { 0x08e00000, 0xfff00000, "fnmsub.d", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0 },
+  { 0x0c100000, 0xffff8018, "fcmp.caf.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c108000, 0xffff8018, "fcmp.saf.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c110000, 0xffff8018, "fcmp.clt.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c118000, 0xffff8018, "fcmp.slt.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c118000, 0xffff8018, "fcmp.sgt.s", "c0:3,f10:5,f5:5", 0, 0, 0, 0 },
+  { 0x0c120000, 0xffff8018, "fcmp.ceq.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c128000, 0xffff8018, "fcmp.seq.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c130000, 0xffff8018, "fcmp.cle.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c138000, 0xffff8018, "fcmp.sle.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c138000, 0xffff8018, "fcmp.sge.s", "c0:3,f10:5,f5:5", 0, 0, 0, 0 },
+  { 0x0c140000, 0xffff8018, "fcmp.cun.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c148000, 0xffff8018, "fcmp.sun.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c150000, 0xffff8018, "fcmp.cult.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c150000, 0xffff8018, "fcmp.cugt.s", "c0:3,f10:5,f5:5", 0, 0, 0, 0 },
+  { 0x0c158000, 0xffff8018, "fcmp.sult.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c160000, 0xffff8018, "fcmp.cueq.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c168000, 0xffff8018, "fcmp.sueq.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c170000, 0xffff8018, "fcmp.cule.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c170000, 0xffff8018, "fcmp.cuge.s", "c0:3,f10:5,f5:5", 0, 0, 0, 0 },
+  { 0x0c178000, 0xffff8018, "fcmp.sule.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c180000, 0xffff8018, "fcmp.cne.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c188000, 0xffff8018, "fcmp.sne.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c1a0000, 0xffff8018, "fcmp.cor.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c1a8000, 0xffff8018, "fcmp.sor.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c1c0000, 0xffff8018, "fcmp.cune.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c1c8000, 0xffff8018, "fcmp.sune.s", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c200000, 0xffff8018, "fcmp.caf.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c208000, 0xffff8018, "fcmp.saf.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c210000, 0xffff8018, "fcmp.clt.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c218000, 0xffff8018, "fcmp.slt.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c218000, 0xffff8018, "fcmp.sgt.d", "c0:3,f10:5,f5:5", 0, 0, 0, 0 },
+  { 0x0c220000, 0xffff8018, "fcmp.ceq.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c228000, 0xffff8018, "fcmp.seq.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c230000, 0xffff8018, "fcmp.cle.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c238000, 0xffff8018, "fcmp.sle.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c238000, 0xffff8018, "fcmp.sge.d", "c0:3,f10:5,f5:5", 0, 0, 0, 0 },
+  { 0x0c240000, 0xffff8018, "fcmp.cun.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c248000, 0xffff8018, "fcmp.sun.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c250000, 0xffff8018, "fcmp.cult.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c250000, 0xffff8018, "fcmp.cugt.d", "c0:3,f10:5,f5:5", 0, 0, 0, 0 },
+  { 0x0c258000, 0xffff8018, "fcmp.sult.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c260000, 0xffff8018, "fcmp.cueq.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c268000, 0xffff8018, "fcmp.sueq.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c270000, 0xffff8018, "fcmp.cule.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c270000, 0xffff8018, "fcmp.cuge.d", "c0:3,f10:5,f5:5", 0, 0, 0, 0 },
+  { 0x0c278000, 0xffff8018, "fcmp.sule.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c280000, 0xffff8018, "fcmp.cne.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c288000, 0xffff8018, "fcmp.sne.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c2a0000, 0xffff8018, "fcmp.cor.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c2a8000, 0xffff8018, "fcmp.sor.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c2c0000, 0xffff8018, "fcmp.cune.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0c2c8000, 0xffff8018, "fcmp.sune.d", "c0:3,f5:5,f10:5", 0, 0, 0, 0 },
+  { 0x0d000000, 0xfffc0000, "fsel", "f0:5,f5:5,f10:5,c15:3", 0, 0, 0, 0 },
+  { 0 } /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_load_store_opcodes[] = 
+{
+  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  { 0x20000000, 0xff000000, "ll.w", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0 },
+  { 0x21000000, 0xff000000, "sc.w", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0 },
+  { 0x22000000, 0xff000000, "ll.d", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0 },
+  { 0x23000000, 0xff000000, "sc.d", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0 },
+  { 0x24000000, 0xff000000, "ldptr.w", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0 },
+  { 0x25000000, 0xff000000, "stptr.w", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0 },
+  { 0x26000000, 0xff000000, "ldptr.d", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0 },
+  { 0x27000000, 0xff000000, "stptr.d", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0 },
+  { 0x28000000, 0xffc00000, "ld.b", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x28400000, 0xffc00000, "ld.h", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x28800000, 0xffc00000, "ld.w", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x28c00000, 0xffc00000, "ld.d", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x29000000, 0xffc00000, "st.b", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x29400000, 0xffc00000, "st.h", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x29800000, 0xffc00000, "st.w", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x29c00000, 0xffc00000, "st.d", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x2a000000, 0xffc00000, "ld.bu", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x2a400000, 0xffc00000, "ld.hu", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x2a800000, 0xffc00000, "ld.wu", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x2ac00000, 0xffc00000, "preld", "u0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x2b000000, 0xffc00000, "fld.s", "f0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x2b400000, 0xffc00000, "fst.s", "f0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x2b800000, 0xffc00000, "fld.d", "f0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x2bc00000, 0xffc00000, "fst.d", "f0:5,r5:5,s10:12", 0, 0, 0, 0 },
+  { 0x38000000, 0xffff8000, "ldx.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38040000, 0xffff8000, "ldx.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38080000, 0xffff8000, "ldx.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x380c0000, 0xffff8000, "ldx.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38100000, 0xffff8000, "stx.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38140000, 0xffff8000, "stx.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38180000, 0xffff8000, "stx.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x381c0000, 0xffff8000, "stx.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38200000, 0xffff8000, "ldx.bu", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38240000, 0xffff8000, "ldx.hu", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38280000, 0xffff8000, "ldx.wu", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x382c0000, 0xffff8000, "preldx", "u0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38300000, 0xffff8000, "fldx.s", "f0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38340000, 0xffff8000, "fldx.d", "f0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38380000, 0xffff8000, "fstx.s", "f0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x383c0000, 0xffff8000, "fstx.d", "f0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0, 0, "amswap.w", "r,r,r,u0:0", "amswap.w %1,%2,%3", 0, 0, 0 },
+  { 0x38600000, 0xffff8000, "amswap.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amswap.d", "r,r,r,u0:0", "amswap.d %1,%2,%3", 0, 0, 0 },
+  { 0x38608000, 0xffff8000, "amswap.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amadd.w", "r,r,r,u0:0", "amadd.w %1,%2,%3", 0, 0, 0 },
+  { 0x38610000, 0xffff8000, "amadd.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amadd.d", "r,r,r,u0:0", "amadd.d %1,%2,%3", 0, 0, 0 },
+  { 0x38618000, 0xffff8000, "amadd.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amand.w", "r,r,r,u0:0", "amand.w %1,%2,%3", 0, 0, 0 },
+  { 0x38620000, 0xffff8000, "amand.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amand.d", "r,r,r,u0:0", "amand.d %1,%2,%3", 0, 0, 0 },
+  { 0x38628000, 0xffff8000, "amand.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amor.w", "r,r,r,u0:0", "amor.w %1,%2,%3", 0, 0, 0 },
+  { 0x38630000, 0xffff8000, "amor.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amor.d", "r,r,r,u0:0", "amor.d %1,%2,%3", 0, 0, 0 },
+  { 0x38638000, 0xffff8000, "amor.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amxor.w", "r,r,r,u0:0", "amxor.w %1,%2,%3", 0, 0, 0 },
+  { 0x38640000, 0xffff8000, "amxor.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amxor.d", "r,r,r,u0:0", "amxor.d %1,%2,%3", 0, 0, 0 },
+  { 0x38648000, 0xffff8000, "amxor.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammax.w", "r,r,r,u0:0", "ammax.w %1,%2,%3", 0, 0, 0 },
+  { 0x38650000, 0xffff8000, "ammax.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammax.d", "r,r,r,u0:0", "ammax.d %1,%2,%3", 0, 0, 0 },
+  { 0x38658000, 0xffff8000, "ammax.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammin.w", "r,r,r,u0:0", "ammin.w %1,%2,%3", 0, 0, 0 },
+  { 0x38660000, 0xffff8000, "ammin.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammin.d", "r,r,r,u0:0", "ammin.d %1,%2,%3", 0, 0, 0 },
+  { 0x38668000, 0xffff8000, "ammin.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammax.wu", "r,r,r,u0:0", "ammax.wu %1,%2,%3", 0, 0, 0 },
+  { 0x38670000, 0xffff8000, "ammax.wu", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammax.du", "r,r,r,u0:0", "ammax.du %1,%2,%3", 0, 0, 0 },
+  { 0x38678000, 0xffff8000, "ammax.du", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammin.wu", "r,r,r,u0:0", "ammin.wu %1,%2,%3", 0, 0, 0 },
+  { 0x38680000, 0xffff8000, "ammin.wu", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammin.du", "r,r,r,u0:0", "ammin.du %1,%2,%3", 0, 0, 0 },
+  { 0x38688000, 0xffff8000, "ammin.du", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amswap_db.w", "r,r,r,u0:0", "amswap_db.w %1,%2,%3", 0, 0, 0 },
+  { 0x38690000, 0xffff8000, "amswap_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amswap_db.d", "r,r,r,u0:0", "amswap_db.d %1,%2,%3", 0, 0, 0 },
+  { 0x38698000, 0xffff8000, "amswap_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amadd_db.w", "r,r,r,u0:0", "amadd_db.w %1,%2,%3", 0, 0, 0 },
+  { 0x386a0000, 0xffff8000, "amadd_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amadd_db.d", "r,r,r,u0:0", "amadd_db.d %1,%2,%3", 0, 0, 0 },
+  { 0x386a8000, 0xffff8000, "amadd_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amand_db.w", "r,r,r,u0:0", "amand_db.w %1,%2,%3", 0, 0, 0 },
+  { 0x386b0000, 0xffff8000, "amand_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amand_db.d", "r,r,r,u0:0", "amand_db.d %1,%2,%3", 0, 0, 0 },
+  { 0x386b8000, 0xffff8000, "amand_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amor_db.w", "r,r,r,u0:0", "amor_db.w %1,%2,%3", 0, 0, 0 },
+  { 0x386c0000, 0xffff8000, "amor_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amor_db.d", "r,r,r,u0:0", "amor_db.d %1,%2,%3", 0, 0, 0 },
+  { 0x386c8000, 0xffff8000, "amor_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amxor_db.w", "r,r,r,u0:0", "amxor_db.w %1,%2,%3", 0, 0, 0 },
+  { 0x386d0000, 0xffff8000, "amxor_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "amxor_db.d", "r,r,r,u0:0", "amxor_db.d %1,%2,%3", 0, 0, 0 },
+  { 0x386d8000, 0xffff8000, "amxor_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammax_db.w", "r,r,r,u0:0", "ammax_db.w %1,%2,%3", 0, 0, 0 },
+  { 0x386e0000, 0xffff8000, "ammax_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammax_db.d", "r,r,r,u0:0", "ammax_db.d %1,%2,%3", 0, 0, 0 },
+  { 0x386e8000, 0xffff8000, "ammax_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammin_db.w", "r,r,r,u0:0", "ammin_db.w %1,%2,%3", 0, 0, 0 },
+  { 0x386f0000, 0xffff8000, "ammin_db.w", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammin_db.d", "r,r,r,u0:0", "ammin_db.d %1,%2,%3", 0, 0, 0 },
+  { 0x386f8000, 0xffff8000, "ammin_db.d", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammax_db.wu", "r,r,r,u0:0", "ammax_db.wu %1,%2,%3", 0, 0, 0 },
+  { 0x38700000, 0xffff8000, "ammax_db.wu", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammax_db.du", "r,r,r,u0:0", "ammax_db.du %1,%2,%3", 0, 0, 0 },
+  { 0x38708000, 0xffff8000, "ammax_db.du", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammin_db.wu", "r,r,r,u0:0", "ammin_db.wu %1,%2,%3", 0, 0, 0 },
+  { 0x38710000, 0xffff8000, "ammin_db.wu", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0, 0, "ammin_db.du", "r,r,r,u0:0", "ammin_db.du %1,%2,%3", 0, 0, 0 },
+  { 0x38718000, 0xffff8000, "ammin_db.du", "r0:5,r10:5,r5:5", 0, 0, 0, 0 },
+  { 0x38720000, 0xffff8000, "dbar", "u0:15", 0, 0, 0, 0 },
+  { 0x38728000, 0xffff8000, "ibar", "u0:15", 0, 0, 0, 0 },
+  { 0x38740000, 0xffff8000, "fldgt.s", "f0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38748000, 0xffff8000, "fldgt.d", "f0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38750000, 0xffff8000, "fldle.s", "f0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38758000, 0xffff8000, "fldle.d", "f0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38760000, 0xffff8000, "fstgt.s", "f0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38768000, 0xffff8000, "fstgt.d", "f0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38770000, 0xffff8000, "fstle.s", "f0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38778000, 0xffff8000, "fstle.d", "f0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38780000, 0xffff8000, "ldgt.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38788000, 0xffff8000, "ldgt.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38790000, 0xffff8000, "ldgt.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x38798000, 0xffff8000, "ldgt.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x387a0000, 0xffff8000, "ldle.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x387a8000, 0xffff8000, "ldle.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x387b0000, 0xffff8000, "ldle.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x387b8000, 0xffff8000, "ldle.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x387c0000, 0xffff8000, "stgt.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x387c8000, 0xffff8000, "stgt.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x387d0000, 0xffff8000, "stgt.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x387d8000, 0xffff8000, "stgt.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x387e0000, 0xffff8000, "stle.b", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x387e8000, 0xffff8000, "stle.h", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x387f0000, 0xffff8000, "stle.w", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0x387f8000, 0xffff8000, "stle.d", "r0:5,r5:5,r10:5", 0, 0, 0, 0 },
+  { 0 } /* Terminate the list.  */
+};
+
+static struct loongarch_opcode loongarch_jmp_opcodes[] = 
+{
+  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  { 0, 0, "bltz", "r,la", "bltz %1,%%pcrel(%2)", 0, 0, 0 },
+  { 0x60000000, 0xfc00001f, "bltz", "r5:5,sb10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "bgtz", "r,la", "bgtz %1,%%pcrel(%2)", 0, 0, 0 },
+  { 0x60000000, 0xfc0003e0, "bgtz", "r0:5,sb10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "bgez", "r,la", "bgez %1,%%pcrel(%2)", 0, 0, 0 },
+  { 0x64000000, 0xfc00001f, "bgez", "r5:5,sb10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "blez", "r,la", "blez %1,%%pcrel(%2)", 0, 0, 0 },
+  { 0x64000000, 0xfc0003e0, "blez", "r0:5,sb10:16<<2", 0, 0, 0, 0 },
+
+  { 0, 0, "beqz", "r,la", "beqz %1,%%pcrel(%2)", 0, 0, 0 },
+  { 0x40000000, 0xfc000000, "beqz", "r5:5,sb0:5|10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "bnez", "r,la", "bnez %1,%%pcrel(%2)", 0, 0, 0 },
+  { 0x44000000, 0xfc000000, "bnez", "r5:5,sb0:5|10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "bceqz", "c,la", "bceqz %1,%%pcrel(%2)", 0, 0, 0 },
+  { 0x48000000, 0xfc000300, "bceqz", "c5:3,sb0:5|10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "bcnez", "c,la", "bcnez %1,%%pcrel(%2)", 0, 0, 0 },
+  { 0x48000100, 0xfc000300, "bcnez", "c5:3,sb0:5|10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "jr", "r", "jirl $r0,%1,0", 0, 0, 0 },
+  { 0x4c000000, 0xfc000000, "jirl", "r0:5,r5:5,s10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "bl", "la", "bl %%pcrel(%1)", 0, 0, 0 },
+  { 0x54000000, 0xfc000000, "bl", "sb0:10|10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "beq", "r,r,la", "beq %1,%2,%%pcrel(%3)", 0, 0, 0 },
+  { 0x58000000, 0xfc000000, "beq", "r5:5,r0:5,sb10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "bne", "r,r,la", "bne %1,%2,%%pcrel(%3)", 0, 0, 0 },
+  { 0x5c000000, 0xfc000000, "bne", "r5:5,r0:5,sb10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "blt", "r,r,la", "blt %1,%2,%%pcrel(%3)", 0, 0, 0 },
+  { 0x60000000, 0xfc000000, "blt", "r5:5,r0:5,sb10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "bgt", "r,r,la", "bgt %1,%2,%%pcrel(%3)", 0, 0, 0 },
+  { 0x60000000, 0xfc000000, "bgt", "r0:5,r5:5,sb10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "bge", "r,r,la", "bge %1,%2,%%pcrel(%3)", 0, 0, 0 },
+  { 0x64000000, 0xfc000000, "bge", "r5:5,r0:5,sb10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "ble", "r,r,la", "ble %1,%2,%%pcrel(%3)", 0, 0, 0 },
+  { 0x64000000, 0xfc000000, "ble", "r0:5,r5:5,sb10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "bltu", "r,r,la", "bltu %1,%2,%%pcrel(%3)", 0, 0, 0 },
+  { 0x68000000, 0xfc000000, "bltu", "r5:5,r0:5,sb10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "bgtu", "r,r,la", "bgtu %1,%2,%%pcrel(%3)", 0, 0, 0 },
+  { 0x68000000, 0xfc000000, "bgtu", "r0:5,r5:5,sb10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "bgeu", "r,r,la", "bgeu %1,%2,%%pcrel(%3)", 0, 0, 0 },
+  { 0x6c000000, 0xfc000000, "bgeu", "r5:5,r0:5,sb10:16<<2", 0, 0, 0, 0 },
+  { 0, 0, "bleu", "r,r,la", "bleu %1,%2,%%pcrel(%3)", 0, 0, 0 },
+  { 0x6c000000, 0xfc000000, "bleu", "r0:5,r5:5,sb10:16<<2", 0, 0, 0, 0 },
+  { 0 } /* Terminate the list.  */
+};
+
+struct loongarch_ase loongarch_ASEs[] = 
+{
+  { &LARCH_opts.ase_fix, loongarch_macro_opcodes, 0, 0, { 0 }, 0, 0 },
+  { &LARCH_opts.ase_fix, loongarch_lmm_opcodes, 0, 0, { 0 }, 0, 0 },
+  { &LARCH_opts.ase_fix, loongarch_privilege_opcodes, 0, 0, { 0 }, 0, 0 },
+  { &LARCH_opts.ase_fix, loongarch_jmp_opcodes, 0, 0, { 0 }, 0, 0 },
+  { &LARCH_opts.ase_fix, loongarch_load_store_opcodes, 0, 0, { 0 }, 0, 0 },
+  { &LARCH_opts.ase_fix, loongarch_fix_opcodes, 0, 0, { 0 }, 0, 0 },
+  { &LARCH_opts.ase_float, loongarch_4opt_opcodes, 0, 0, { 0 }, 0, 0 },
+  { &LARCH_opts.ase_float, loongarch_float_opcodes, 0, 0, { 0 }, 0, 0 },
+
+  { 0 },
+};
-- 
2.30.1

