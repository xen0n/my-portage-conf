From 4adc22e3dfbaa14a50458f61353520ac0895c7cb Mon Sep 17 00:00:00 2001
From: Calring <519384449@qq.com>
Date: Wed, 11 Aug 2021 21:53:38 +0800
Subject: [PATCH 14/30] Change code style to GNU style.

---
 gas/config/tc-loongarch.c | 668 +++++++++++++++++++-------------------
 1 file changed, 334 insertions(+), 334 deletions(-)

diff --git a/gas/config/tc-loongarch.c b/gas/config/tc-loongarch.c
index 9148706c098..690f1875447 100644
--- a/gas/config/tc-loongarch.c
+++ b/gas/config/tc-loongarch.c
@@ -140,11 +140,11 @@ md_parse_option (int c, const char *arg)
       break;
     case OPTION_ABI:
       if (strcasecmp (arg, "lp64") == 0)
-        LARCH_opts.abi_is_lp64 = 1;
+	LARCH_opts.abi_is_lp64 = 1;
       else if (strcasecmp (arg, "lp32") == 0)
-        LARCH_opts.abi_is_lp32 = 1;
+	LARCH_opts.abi_is_lp32 = 1;
       else
-        ret = 0;
+	ret = 0;
       break;
     case OPTION_LA_LOCAL_WITH_ABS:
       LARCH_opts.la_local_with_abs = 1;
@@ -200,7 +200,7 @@ loongarch_after_parse_args ()
     str_hash_insert (c_htab, loongarch_c_normal_name[i], (void *) (i + 1), 0);
   for (i = 0; i < ARRAY_SIZE (loongarch_cr_normal_name); i++)
     str_hash_insert (cr_htab, loongarch_cr_normal_name[i], (void *) (i + 1),
-                     0);
+		     0);
   for (i = 0; i < ARRAY_SIZE (loongarch_v_normal_name); i++)
     str_hash_insert (v_htab, loongarch_v_normal_name[i], (void *) (i + 1), 0);
   for (i = 0; i < ARRAY_SIZE (loongarch_x_normal_name); i++)
@@ -220,17 +220,17 @@ loongarch_after_parse_args ()
       LARCH_opts.addrwidth_is_64 = 1;
       LARCH_opts.rlen_is_64 = 1;
       for (i = 0; i < ARRAY_SIZE (loongarch_r_lp64_name); i++)
-        str_hash_insert (r_htab, loongarch_r_lp64_name[i], (void *) (i + 1),
-                         0);
+	str_hash_insert (r_htab, loongarch_r_lp64_name[i], (void *) (i + 1),
+			 0);
       for (i = 0; i < ARRAY_SIZE (loongarch_r_lp64_name1); i++)
-        str_hash_insert (r_htab, loongarch_r_lp64_name1[i], (void *) (i + 1),
-                         0);
+	str_hash_insert (r_htab, loongarch_r_lp64_name1[i], (void *) (i + 1),
+			 0);
       for (i = 0; i < ARRAY_SIZE (loongarch_f_lp64_name); i++)
-        str_hash_insert (f_htab, loongarch_f_lp64_name[i], (void *) (i + 1),
-                         0);
+	str_hash_insert (f_htab, loongarch_f_lp64_name[i], (void *) (i + 1),
+			 0);
       for (i = 0; i < ARRAY_SIZE (loongarch_f_lp64_name1); i++)
-        str_hash_insert (f_htab, loongarch_f_lp64_name1[i], (void *) (i + 1),
-                         0);
+	str_hash_insert (f_htab, loongarch_f_lp64_name1[i], (void *) (i + 1),
+			 0);
     }
 
   if (LARCH_opts.abi_is_lp32)
@@ -254,21 +254,21 @@ md_begin ()
       const struct loongarch_opcode *it;
       struct loongarch_ase *ase;
       for (ase = loongarch_ASEs; ase->enabled; ase++)
-        for (it = ase->opcodes; it->name; it++)
-          {
-            if (loongarch_check_format (it->format) != 0)
-              as_fatal (_ ("insn name: %s\tformat: %s\tsyntax error"),
-                        it->name, it->format);
-            if (it->mask == 0 && it->macro == 0)
-              as_fatal (_ ("insn name: %s\nformat: %s\nwe want macro but "
-                           "macro is NULL"),
-                        it->name, it->format);
-            if (it->macro &&
-                loongarch_check_macro (it->format, it->macro) != 0)
-              as_fatal (
-                _ ("insn name: %s\nformat: %s\nmacro: %s\tsyntax error"),
-                it->name, it->format, it->macro);
-          }
+	for (it = ase->opcodes; it->name; it++)
+	  {
+	    if (loongarch_check_format (it->format) != 0)
+	      as_fatal (_ ("insn name: %s\tformat: %s\tsyntax error"),
+			it->name, it->format);
+	    if (it->mask == 0 && it->macro == 0)
+	      as_fatal (_ ("insn name: %s\nformat: %s\nwe want macro but "
+			   "macro is NULL"),
+			it->name, it->format);
+	    if (it->macro
+	 && loongarch_check_macro (it->format, it->macro) != 0)
+	      as_fatal (
+		_ ("insn name: %s\nformat: %s\nmacro: %s\tsyntax error"),
+		it->name, it->format, it->macro);
+	  }
     }
 
   /* FIXME: expressionS use 'offsetT' as constant, we want this is 64-bit type */
@@ -279,7 +279,7 @@ void
 md_operand (expressionS *e)
 {
   /* Because we use 'expression' to check if a actual arg is a expr at first.
-     If not, we want a returning. */
+     If not, we want a returning.  */
   if (e->X_op == O_absent)
     e->X_op = O_illegal;
 }
@@ -325,15 +325,15 @@ s_dtprel (int bytes)
   if (ex.X_op != O_symbol)
     {
       as_bad (_ ("Unsupported use of %s"),
-              (bytes == 8 ? ".dtpreldword" : ".dtprelword"));
+	      (bytes == 8 ? ".dtpreldword" : ".dtprelword"));
       ignore_rest_of_line ();
     }
 
   p = frag_more (bytes);
   md_number_to_chars (p, 0, bytes);
   fix_new_exp (frag_now, p - frag_now->fr_literal, bytes, &ex, FALSE,
-               (bytes == 8 ? BFD_RELOC_LARCH_TLS_DTPREL64
-                           : BFD_RELOC_LARCH_TLS_DTPREL32));
+	       (bytes == 8 ? BFD_RELOC_LARCH_TLS_DTPREL64
+			   : BFD_RELOC_LARCH_TLS_DTPREL32));
 
   demand_empty_rest_of_line ();
 }
@@ -374,7 +374,7 @@ loongarch_internal_label_name (unsigned long label, int augend)
   *p++ = 'L';
   for (; label; label /= 10)
     *p++ = label % 10 + '0';
-  /* make sure internal label never belong to normal label namespace */
+  /* make sure internal label never belong to normal label namespace.  */
   *p++ = ':';
   for (; want_label; want_label /= 10)
     *p++ = want_label % 10 + '0';
@@ -390,13 +390,13 @@ setup_internal_label_here (unsigned long label)
   colon (loongarch_internal_label_name (label, 0));
 }
 
-extern void /* No static. used by 'loongarch-parse.y'. */
+extern void /* No static. used by 'loongarch-parse.y'.   */
 get_internal_label (expressionS *label_expr, unsigned long label,
-                    int augend /* 0 for previous, 1 for next. */);
+		    int augend /* 0 for previous, 1 for next.  */);
 
 void
 get_internal_label (expressionS *label_expr, unsigned long label,
-                    int augend /* 0 for previous, 1 for next. */)
+		    int augend /* 0 for previous, 1 for next.  */)
 {
   assert (label < INTERNAL_LABEL_SPECIAL);
   if (augend == 0 && internal_label_count[label] == 0)
@@ -408,14 +408,14 @@ get_internal_label (expressionS *label_expr, unsigned long label,
 }
 
 extern int loongarch_parse_expr (const char *expr,
-                                 struct reloc_info *reloc_stack_top,
-                                 size_t max_reloc_num, size_t *reloc_num,
-                                 offsetT *imm_if_no_reloc);
+				 struct reloc_info *reloc_stack_top,
+				 size_t max_reloc_num, size_t *reloc_num,
+				 offsetT *imm_if_no_reloc);
 
 static int32_t
 loongarch_args_parser_can_match_arg_helper (char esc_ch1, char esc_ch2,
-                                            const char *bit_field,
-                                            const char *arg, void *context)
+					    const char *bit_field,
+					    const char *arg, void *context)
 {
   struct loongarch_cl_insn *ip = context;
   offsetT imm, ret = 0;
@@ -429,84 +429,84 @@ loongarch_args_parser_can_match_arg_helper (char esc_ch1, char esc_ch2,
     {
     case 'l':
       switch (esc_ch2)
-        {
-        default:
-          ip->match_now = is_label (arg);
-          if (!ip->match_now && is_label_with_addend (arg))
-            as_fatal (_ ("This label shouldn't be with addend."));
-          break;
-        case 'a':
-          ip->match_now = is_label_with_addend (arg);
-          break;
-        }
+	{
+	default:
+	  ip->match_now = is_label (arg);
+	  if (!ip->match_now && is_label_with_addend (arg))
+	    as_fatal (_ ("This label shouldn't be with addend."));
+	  break;
+	case 'a':
+	  ip->match_now = is_label_with_addend (arg);
+	  break;
+	}
       break;
     case 's':
     case 'u':
       ip->match_now =
-        loongarch_parse_expr (arg, ip->reloc_info + ip->reloc_num,
-                              reloc_num_we_have, &reloc_num, &imm) == 0;
+	loongarch_parse_expr (arg, ip->reloc_info + ip->reloc_num,
+			      reloc_num_we_have, &reloc_num, &imm) == 0;
 
       if (!ip->match_now)
-        break;
+	break;
 
       if (esc_ch1 == 's')
-        switch (esc_ch2)
-          {
-          case 'c':
-            ip->match_now = reloc_num == 0;
-            break;
-          }
+	switch (esc_ch2)
+	  {
+	  case 'c':
+	    ip->match_now = reloc_num == 0;
+	    break;
+	  }
       else
-        switch (esc_ch2)
-          {
-          case 'c':
-            ip->match_now = reloc_num == 0 && 0 <= imm;
-            break;
-          }
+	switch (esc_ch2)
+	  {
+	  case 'c':
+	    ip->match_now = reloc_num == 0 && 0 <= imm;
+	    break;
+	  }
 
       if (!ip->match_now)
-        break;
+	break;
 
       ret = imm;
       if (reloc_num)
-        {
-          bfd_reloc_code_real_type reloc_type = BFD_RELOC_NONE;
-          reloc_num_we_have -= reloc_num;
-          if (reloc_num_we_have == 0)
-            as_fatal (_ ("expr too huge") /* Want one more reloc. */);
-          if (esc_ch1 == 'u')
-            {
-              if (strncmp (bit_field, "10:12", strlen ("10:12")) == 0)
-                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_U_10_12;
-            }
-          else if (esc_ch1 == 's')
-            {
-              if (strncmp (bit_field, "10:16<<2", strlen ("10:16<<2")) == 0)
-                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2;
-              else if (strncmp (bit_field, "0:5|10:16<<2",
-                                strlen ("0:5|10:16<<2")) == 0)
-                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2;
-              else if (strncmp (bit_field, "0:10|10:16<<2",
-                                strlen ("0:10|10:16<<2")) == 0)
-                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2;
-              else if (strncmp (bit_field, "10:12", strlen ("10:12")) == 0)
-                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_12;
-              else if (strncmp (bit_field, "5:20", strlen ("5:20")) == 0)
-                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_5_20;
-              else if (strncmp (bit_field, "10:16", strlen ("10:16")) == 0)
-                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_16;
-              else if (strncmp (bit_field, "10:5", strlen ("10:5")) == 0)
-                reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_5;
-            }
-          if (reloc_type == BFD_RELOC_NONE)
-            as_fatal (
-              _ ("not support reloc bit-field\nfmt: %c%c %s\nargs: %s"),
-              esc_ch1, esc_ch2, bit_field, arg);
-          reloc_num++;
-          ip->reloc_num += reloc_num;
-          ip->reloc_info[ip->reloc_num - 1].type = reloc_type;
-          ip->reloc_info[ip->reloc_num - 1].value = const_0;
-        }
+	{
+	  bfd_reloc_code_real_type reloc_type = BFD_RELOC_NONE;
+	  reloc_num_we_have -= reloc_num;
+	  if (reloc_num_we_have == 0)
+	    as_fatal (_ ("expr too huge") /* Want one more reloc.  */);
+	  if (esc_ch1 == 'u')
+	    {
+	      if (strncmp (bit_field, "10:12", strlen ("10:12")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_U_10_12;
+	    }
+	  else if (esc_ch1 == 's')
+	    {
+	      if (strncmp (bit_field, "10:16<<2", strlen ("10:16<<2")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2;
+	      else if (strncmp (bit_field, "0:5|10:16<<2",
+				strlen ("0:5|10:16<<2")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2;
+	      else if (strncmp (bit_field, "0:10|10:16<<2",
+				strlen ("0:10|10:16<<2")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2;
+	      else if (strncmp (bit_field, "10:12", strlen ("10:12")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_12;
+	      else if (strncmp (bit_field, "5:20", strlen ("5:20")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_5_20;
+	      else if (strncmp (bit_field, "10:16", strlen ("10:16")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_16;
+	      else if (strncmp (bit_field, "10:5", strlen ("10:5")) == 0)
+		reloc_type = BFD_RELOC_LARCH_SOP_POP_32_S_10_5;
+	    }
+	  if (reloc_type == BFD_RELOC_NONE)
+	    as_fatal (
+	      _ ("not support reloc bit-field\nfmt: %c%c %s\nargs: %s"),
+	      esc_ch1, esc_ch2, bit_field, arg);
+	  reloc_num++;
+	  ip->reloc_num += reloc_num;
+	  ip->reloc_info[ip->reloc_num - 1].type = reloc_type;
+	  ip->reloc_info[ip->reloc_num - 1].value = const_0;
+	}
       break;
     case 'r':
       imm = (offsetT) str_hash_find (r_htab, arg);
@@ -520,13 +520,13 @@ loongarch_args_parser_can_match_arg_helper (char esc_ch1, char esc_ch2,
       break;
     case 'c':
       switch (esc_ch2)
-        {
-        case 'r':
-          imm = (offsetT) str_hash_find (cr_htab, arg);
-          break;
-        default:
-          imm = (offsetT) str_hash_find (c_htab, arg);
-        }
+	{
+	case 'r':
+	  imm = (offsetT) str_hash_find (cr_htab, arg);
+	  break;
+	default:
+	  imm = (offsetT) str_hash_find (c_htab, arg);
+	}
       ip->match_now = 0 < imm;
       ret = imm - 1;
       break;
@@ -543,7 +543,7 @@ loongarch_args_parser_can_match_arg_helper (char esc_ch1, char esc_ch2,
     case '\0':
       ip->all_match = ip->match_now;
       ip->insn_length =
-        ip->insn->mask ? loongarch_insn_length (ip->insn->match) : 0;
+	ip->insn->mask ? loongarch_insn_length (ip->insn->match) : 0;
       /* FIXME: now we have no relax insn */
       ip->relax_max_length = ip->insn_length;
       break;
@@ -553,44 +553,44 @@ loongarch_args_parser_can_match_arg_helper (char esc_ch1, char esc_ch2,
 
   do
     {
-      /* Check imm overflow. */
+      /* Check imm overflow.  */
       int bit_width, bits_needed_s, bits_needed_u;
       char *t;
 
       if (!ip->match_now)
-        break;
+	break;
 
       if (0 < reloc_num)
-        break;
+	break;
 
       bit_width = loongarch_get_bit_field_width (bit_field, &t);
 
       if (bit_width == -1)
-        /* No specify bit width. */
-        break;
+	/* No specify bit width.  */
+	break;
 
       imm = ret;
       if (t[0] == '<' && t[1] == '<')
-        {
-          int i = strtol (t += 2, &t, 10), j;
-          for (j = i; 0 < j; j--, imm >>= 1)
-            if (imm & 1)
-              as_fatal (_ ("require imm low %d bit is 0."), i);
-        }
+	{
+	  int i = strtol (t += 2, &t, 10), j;
+	  for (j = i; 0 < j; j--, imm >>= 1)
+	    if (imm & 1)
+	      as_fatal (_ ("require imm low %d bit is 0."), i);
+	}
 
       if (*t == '+')
-        imm -= strtol (t, &t, 10);
+	imm -= strtol (t, &t, 10);
 
       bits_needed_s = loongarch_bits_imm_needed (imm, 1);
       bits_needed_u = loongarch_bits_imm_needed (imm, 0);
 
       if ((esc_ch1 == 's' && bit_width < bits_needed_s) ||
-          (esc_ch1 != 's' && bit_width < bits_needed_u))
-        /* How to do after we detect overflow. */
-        as_fatal (_ ("Immediate overflow.\n"
-                     "format: %c%c%s\n"
-                     "arg: %s"),
-                  esc_ch1, esc_ch2, bit_field, arg);
+	  (esc_ch1 != 's' && bit_width < bits_needed_u))
+	/* How to do after we detect overflow.  */
+	as_fatal (_ ("Immediate overflow.\n"
+		     "format: %c%c%s\n"
+		     "arg: %s"),
+		  esc_ch1, esc_ch2, bit_field, arg);
     }
   while (0);
 
@@ -610,37 +610,37 @@ get_loongarch_opcode (struct loongarch_cl_insn *insn)
   for (ase = loongarch_ASEs; ase->enabled; ase++)
     {
       if (!*ase->enabled || (ase->include && !*ase->include) ||
-          (ase->exclude && *ase->exclude))
-        continue;
+	  (ase->exclude && *ase->exclude))
+	continue;
 
       if (!ase->name_hash_entry)
-        {
-          ase->name_hash_entry = str_htab_create ();
-          for (it = ase->opcodes; it->name; it++)
-            str_hash_insert (ase->name_hash_entry, it->name, (void *) it, 0);
-        }
+	{
+	  ase->name_hash_entry = str_htab_create ();
+	  for (it = ase->opcodes; it->name; it++)
+	    str_hash_insert (ase->name_hash_entry, it->name, (void *) it, 0);
+	}
 
       if ((it = str_hash_find (ase->name_hash_entry, insn->name)) == NULL)
-        continue;
+	continue;
 
       do
-        {
-          insn->insn = it;
-          insn->match_now = 1;
-          insn->all_match = 0;
-          insn->arg_num = 0;
-          insn->reloc_num = 0;
-          insn->insn_bin = loongarch_foreach_args (
-            it->format, insn->arg_strs,
-            loongarch_args_parser_can_match_arg_helper, insn);
-          if (insn->all_match && !(it->include && !*it->include) &&
-              !(it->exclude && *it->exclude))
-            {
-              insn->insn_bin |= it->match;
-              return;
-            }
-          it++;
-        }
+	{
+	  insn->insn = it;
+	  insn->match_now = 1;
+	  insn->all_match = 0;
+	  insn->arg_num = 0;
+	  insn->reloc_num = 0;
+	  insn->insn_bin = loongarch_foreach_args (
+	    it->format, insn->arg_strs,
+	    loongarch_args_parser_can_match_arg_helper, insn);
+	  if (insn->all_match && !(it->include && !*it->include)
+       && !(it->exclude && *it->exclude))
+	    {
+	      insn->insn_bin |= it->match;
+	      return;
+	    }
+	  it++;
+	}
       while (it->name && strcasecmp (it->name, insn->name) == 0);
     }
 }
@@ -655,34 +655,34 @@ check_this_insn_before_appending (struct loongarch_cl_insn *ip)
       my_getExpression (&ip->reloc_info[ip->reloc_num].value, ip->arg_strs[1]);
       ip->reloc_num++;
     }
-  else if (ip->insn->mask == 0xffff8000 &&
-           ((ip->insn_bin & 0xfff00000) == 0x38600000 ||  /* amswap.w  rd, rk,
-                                                             rj  */
-            (ip->insn_bin & 0xffff0000) == 0x38700000 ||  /* ammax_db.wu  rd, 
-                                                             rk, rj  */
-            (ip->insn_bin & 0xffff0000) == 0x38710000))  /* ammin_db.wu  rd, 
-                                                            rk, rj  */
+  else if (ip->insn->mask == 0xffff8000
+	   /* amswap.w  rd, rk, rj  */
+	   && ((ip->insn_bin & 0xfff00000) == 0x38600000
+	   /* ammax_db.wu  rd, rk, rj  */
+	   || (ip->insn_bin & 0xffff0000) == 0x38700000
+	   /* ammin_db.wu  rd, rk, rj  */
+	       || (ip->insn_bin & 0xffff0000) == 0x38710000))
     {
       /* For AMO insn amswap.[wd], amadd.[wd], etc. */
-      if (ip->args[0] != 0 &&
-          (ip->args[0] == ip->args[1] || ip->args[0] == ip->args[2]))
-        as_fatal (
-          _ ("AMO insns require rd != base && rd != rt when rd isn't $r0"));
+      if (ip->args[0] != 0
+	  && (ip->args[0] == ip->args[1] || ip->args[0] == ip->args[2]))
+	as_fatal (
+	  _ ("AMO insns require rd != base && rd != rt when rd isn't $r0"));
     }
-  else if ((ip->insn->mask == 0xffe08000 &&
-            (ip->insn_bin & 0xffe00000) == 0x00600000) ||  /* bstrins.w  rd, 
-                                                              rj, msbw, lsbw  */
-           (ip->insn->mask == 0xffc00000 &&
-            (ip->insn_bin & 0xff800000) == 0x00800000))  /* bstrins.d  rd, rj, 
-                                                            msbd, lsbd  */
+  else if ((ip->insn->mask == 0xffe08000
+	    /* bstrins.w  rd, rj, msbw, lsbw  */
+	    && (ip->insn_bin & 0xffe00000) == 0x00600000)
+	   || (ip->insn->mask == 0xffc00000
+	    /* bstrins.d  rd, rj, msbd, lsbd  */
+	    && (ip->insn_bin & 0xff800000) == 0x00800000))
     {
       /* For bstr(ins|pick).[wd] */
       if (ip->args[2] < ip->args[3])
-        as_fatal (_ ("bstr(ins|pick).[wd] require msbd >= lsbd"));
+	as_fatal (_ ("bstr(ins|pick).[wd] require msbd >= lsbd"));
     }
-  else if (ip->insn->mask != 0 && (ip->insn_bin & 0xfe0003c0) == 0x04000000 && 
-        /* csrxchg  rd, rj, csr_num  */
-           (strcmp ("csrxchg", ip->name) == 0))
+  else if (ip->insn->mask != 0 && (ip->insn_bin & 0xfe0003c0) == 0x04000000
+	   /* csrxchg  rd, rj, csr_num  */
+	   && (strcmp ("csrxchg", ip->name) == 0))
     as_fatal (_ ("csrxchg require rj != $r0 && rj != $r1"));
 
   return ret;
@@ -730,11 +730,11 @@ append_fixp_and_insn (struct loongarch_cl_insn *ip)
       reloc_type = reloc_info[i].type;
       howto = bfd_reloc_type_lookup (stdoutput, reloc_type);
       if (howto == NULL)
-        as_fatal (_ ("no HOWTO loong relocation number %d"), reloc_type);
+	as_fatal (_ ("no HOWTO loong relocation number %d"), reloc_type);
 
       ip->fixp[i] =
-        fix_new_exp (ip->frag, ip->where, bfd_get_reloc_size (howto),
-                     &reloc_info[i].value, FALSE, reloc_type);
+	fix_new_exp (ip->frag, ip->where, bfd_get_reloc_size (howto),
+		     &reloc_info[i].value, FALSE, reloc_type);
     }
 
   if (ip->insn_length < ip->relax_max_length)
@@ -757,70 +757,70 @@ assember_macro_helper (const char *const args[], void *context_ptr)
       uint32_t hi32, lo32;
 
       /* We pay attention to sign extend beacause it is chance of reduce insn.
-         The exception is 12-bit and hi-12-bit unsigned,
-	 we need a 'ori' or a 'lu52i.d' accordingly. */
+	 The exception is 12-bit and hi-12-bit unsigned,
+	 we need a 'ori' or a 'lu52i.d' accordingly.  */
       char all0_bit_vec, sign_bit_vec, allf_bit_vec, paritial_is_sext_of_prev;
 
       lo32 = insn->args[1] & 0xffffffff;
       hi32 = insn->args[1] >> 32;
 
       if (strcmp (insn->name, "li.w") == 0)
-        {
-          if (hi32 != 0 && hi32 != 0xffffffff)
-            as_fatal (_ ("li overflow: hi32:0x%x lo32:0x%x"), hi32, lo32);
-          hi32 = lo32 & 0x80000000 ? 0xffffffff : 0;
-        }
+	{
+	  if (hi32 != 0 && hi32 != 0xffffffff)
+	    as_fatal (_ ("li overflow: hi32:0x%x lo32:0x%x"), hi32, lo32);
+	  hi32 = lo32 & 0x80000000 ? 0xffffffff : 0;
+	}
 
       if (strcmp (insn->name, "li.d") == 0 && LARCH_opts.rlen_is_32)
-        as_fatal (_ ("we can't li.d on 32bit-arch"));
+	as_fatal (_ ("we can't li.d on 32bit-arch"));
 
       snprintf (args_buf, sizeof (args_buf), "0x%x,0x%x,0x%x,0x%x,%s",
-                (hi32 >> 20) & 0xfff, hi32 & 0xfffff, (lo32 >> 12) & 0xfffff,
-                lo32 & 0xfff, args[0]);
+		(hi32 >> 20) & 0xfff, hi32 & 0xfffff, (lo32 >> 12) & 0xfffff,
+		lo32 & 0xfff, args[0]);
       loongarch_split_args_by_comma (args_buf, arg_strs);
 
       all0_bit_vec =
-        (((hi32 & 0xfff00000) == 0) << 3) | (((hi32 & 0x000fffff) == 0) << 2) |
-        (((lo32 & 0xfffff000) == 0) << 1) | ((lo32 & 0x00000fff) == 0);
+	(((hi32 & 0xfff00000) == 0) << 3) | (((hi32 & 0x000fffff) == 0) << 2)
+	| (((lo32 & 0xfffff000) == 0) << 1) | ((lo32 & 0x00000fff) == 0);
       sign_bit_vec =
-        (((hi32 & 0x80000000) != 0) << 3) | (((hi32 & 0x00080000) != 0) << 2) |
-        (((lo32 & 0x80000000) != 0) << 1) | ((lo32 & 0x00000800) != 0);
-      allf_bit_vec = (((hi32 & 0xfff00000) == 0xfff00000) << 3) |
-                     (((hi32 & 0x000fffff) == 0x000fffff) << 2) |
-                     (((lo32 & 0xfffff000) == 0xfffff000) << 1) |
-                     ((lo32 & 0x00000fff) == 0x00000fff);
+	(((hi32 & 0x80000000) != 0) << 3) | (((hi32 & 0x00080000) != 0) << 2)
+	| (((lo32 & 0x80000000) != 0) << 1) | ((lo32 & 0x00000800) != 0);
+      allf_bit_vec = (((hi32 & 0xfff00000) == 0xfff00000) << 3)
+	| (((hi32 & 0x000fffff) == 0x000fffff) << 2)
+	|(((lo32 & 0xfffff000) == 0xfffff000) << 1)
+	| ((lo32 & 0x00000fff) == 0x00000fff);
       paritial_is_sext_of_prev =
-        (all0_bit_vec ^ allf_bit_vec) & (all0_bit_vec ^ (sign_bit_vec << 1));
+	(all0_bit_vec ^ allf_bit_vec) & (all0_bit_vec ^ (sign_bit_vec << 1));
 
       static const char *const li_32bit[] =
       {
-        "lu12i.w %5,%3&0x80000?%3-0x100000:%3;ori %5,%5,%4;",
-        "lu12i.w %5,%3&0x80000?%3-0x100000:%3;",
-        "addi.w %5,$r0,%4&0x800?%4-0x1000:%4;",
-        "or %5,$r0,$r0;",
+	"lu12i.w %5,%3&0x80000?%3-0x100000:%3;ori %5,%5,%4;",
+	"lu12i.w %5,%3&0x80000?%3-0x100000:%3;",
+	"addi.w %5,$r0,%4&0x800?%4-0x1000:%4;",
+	"or %5,$r0,$r0;",
       };
       static const char *const li_hi_32bit[] =
       {
-        "lu32i.d %5,%2&0x80000?%2-0x100000:%2;"
-        "lu52i.d %5,%5,%1&0x800?%1-0x1000:%1;",
-        "lu52i.d %5,%5,%1&0x800?%1-0x1000:%1;",
-        "lu32i.d %5,%2&0x80000?%2-0x100000:%2;",
-        "",
+	"lu32i.d %5,%2&0x80000?%2-0x100000:%2;"
+	"lu52i.d %5,%5,%1&0x800?%1-0x1000:%1;",
+	"lu52i.d %5,%5,%1&0x800?%1-0x1000:%1;",
+	"lu32i.d %5,%2&0x80000?%2-0x100000:%2;",
+	"",
       };
       do
-        {
-          insns_buf[0] = '\0';
-          if (paritial_is_sext_of_prev == 0x7)
-            {
-              strcat (insns_buf, "lu52i.d %5,$r0,%1&0x800?%1-0x1000:%1;");
-              break;
-            }
-          if ((all0_bit_vec & 0x3) == 0x2)
-            strcat (insns_buf, "ori %5,$r0,%4;");
-          else
-            strcat (insns_buf, li_32bit[paritial_is_sext_of_prev & 0x3]);
-          strcat (insns_buf, li_hi_32bit[paritial_is_sext_of_prev >> 2]);
-        }
+	{
+	  insns_buf[0] = '\0';
+	  if (paritial_is_sext_of_prev == 0x7)
+	    {
+	      strcat (insns_buf, "lu52i.d %5,$r0,%1&0x800?%1-0x1000:%1;");
+	      break;
+	    }
+	  if ((all0_bit_vec & 0x3) == 0x2)
+	    strcat (insns_buf, "ori %5,$r0,%4;");
+	  else
+	    strcat (insns_buf, li_32bit[paritial_is_sext_of_prev & 0x3]);
+	  strcat (insns_buf, li_hi_32bit[paritial_is_sext_of_prev >> 2]);
+	}
       while (0);
 
       ret = loongarch_expand_macro (insns_buf, arg_strs, NULL, NULL);
@@ -829,7 +829,8 @@ assember_macro_helper (const char *const args[], void *context_ptr)
 }
 
 /* Accept instructions separated by ';'
-* assuming 'not starting with space and not ending with space' or pass in empty c_str. */
+* assuming 'not starting with space and not ending with space' or pass in
+* empty c_str.  */
 static void
 loongarch_assemble_INSNs (char *str)
 {
@@ -849,35 +850,34 @@ loongarch_assemble_INSNs (char *str)
   do
     {
       if (*str == '\0')
-        break;
+	break;
 
       struct loongarch_cl_insn the_one = { 0 };
       the_one.name = str;
 
       for (; *str && *str != ' '; str++)
-        ;
+	;
       if (*str == ' ')
-        *str++ = '\0';
+	*str++ = '\0';
 
       loongarch_split_args_by_comma (str, the_one.arg_strs);
       get_loongarch_opcode (&the_one);
 
       if (!the_one.all_match)
-        as_fatal (_ ("no match insn: %s\t%s"), the_one.name,
-                  loongarch_cat_splited_strs (the_one.arg_strs));
+	as_fatal (_ ("no match insn: %s\t%s"), the_one.name,
+		  loongarch_cat_splited_strs (the_one.arg_strs));
 
       if (check_this_insn_before_appending (&the_one) != 0)
-        break;
+	break;
 
       append_fixp_and_insn (&the_one);
       if (the_one.insn_length == 0 && the_one.insn->macro)
-        {
-          char *c_str =
-            loongarch_expand_macro (the_one.insn->macro, the_one.arg_strs,
-                                    assember_macro_helper, &the_one);
-          loongarch_assemble_INSNs (c_str);
-          free (c_str);
-        }
+	{
+	  char *c_str = loongarch_expand_macro (the_one.insn->macro,
+		    the_one.arg_strs, assember_macro_helper, &the_one);
+	  loongarch_assemble_INSNs (c_str);
+	  free (c_str);
+	}
     }
   while (0);
 
@@ -927,33 +927,33 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
     case BFD_RELOC_LARCH_SOP_PUSH_TLS_GD:
     case BFD_RELOC_LARCH_SOP_PUSH_TLS_GOT:
       if (fixP->fx_addsy)
-        S_SET_THREAD_LOCAL (fixP->fx_addsy);
+	S_SET_THREAD_LOCAL (fixP->fx_addsy);
       else
-        as_bad_where (fixP->fx_file, fixP->fx_line,
-                      _ ("Relocation against a constant"));
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _ ("Relocation against a constant"));
       break;
     case BFD_RELOC_LARCH_SOP_PUSH_PCREL:
     case BFD_RELOC_LARCH_SOP_PUSH_PLT_PCREL:
       if (fixP->fx_addsy == NULL)
-        as_bad_where (fixP->fx_file, fixP->fx_line,
-                      _ ("Relocation against a constant"));
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _ ("Relocation against a constant"));
       if (fixP->fx_r_type == BFD_RELOC_LARCH_SOP_PUSH_PCREL)
-        {
-          last_reloc_is_sop_push_pcrel_1 = 1;
-          if (S_GET_SEGMENT (fixP->fx_addsy) == seg)
-            stack_top = S_GET_VALUE (fixP->fx_addsy) + fixP->fx_offset -
-                        (fixP->fx_where + fixP->fx_frag->fr_address);
-          else
-            stack_top = 0;
-        }
+	{
+	  last_reloc_is_sop_push_pcrel_1 = 1;
+	  if (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	    stack_top = S_GET_VALUE (fixP->fx_addsy) + fixP->fx_offset
+	- (fixP->fx_where + fixP->fx_frag->fr_address);
+	  else
+	    stack_top = 0;
+	}
       break;
 
     case BFD_RELOC_LARCH_SOP_POP_32_S_10_5:
       if (!last_reloc_is_sop_push_pcrel)
-        break;
-      if ((stack_top & ~(uint64_t) 0xf) != 0x0 &&
-          (stack_top & ~(uint64_t) 0xf) != ~(uint64_t) 0xf)
-        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+	break;
+      if ((stack_top & ~(uint64_t) 0xf) != 0x0
+	  && (stack_top & ~(uint64_t) 0xf) != ~(uint64_t) 0xf)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
       insn = bfd_getl32 (buf);
       insn = (insn & (~(uint32_t) 0x7c00)) | ((stack_top & 0x1f) << 10);
       bfd_putl32 (insn, buf);
@@ -961,9 +961,9 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 
     case BFD_RELOC_LARCH_SOP_POP_32_U_10_12:
       if (!last_reloc_is_sop_push_pcrel)
-        break;
+	break;
       if (stack_top & ~(uint64_t) 0xfff)
-        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
       insn = bfd_getl32 (buf);
       insn = (insn & (~(uint32_t) 0x3ffc00)) | ((stack_top & 0xfff) << 10);
       bfd_putl32 (insn, buf);
@@ -971,10 +971,10 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 
     case BFD_RELOC_LARCH_SOP_POP_32_S_10_12:
       if (!last_reloc_is_sop_push_pcrel)
-        break;
-      if ((stack_top & ~(uint64_t) 0x7ff) != 0x0 &&
-          (stack_top & ~(uint64_t) 0x7ff) != ~(uint64_t) 0x7ff)
-        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+	break;
+      if ((stack_top & ~(uint64_t) 0x7ff) != 0x0
+	  && (stack_top & ~(uint64_t) 0x7ff) != ~(uint64_t) 0x7ff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
       insn = bfd_getl32 (buf);
       insn = (insn & (~(uint32_t) 0x3ffc00)) | ((stack_top & 0xfff) << 10);
       bfd_putl32 (insn, buf);
@@ -982,10 +982,10 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 
     case BFD_RELOC_LARCH_SOP_POP_32_S_10_16:
       if (!last_reloc_is_sop_push_pcrel)
-        break;
-      if ((stack_top & ~(uint64_t) 0x7fff) != 0x0 &&
-          (stack_top & ~(uint64_t) 0x7fff) != ~(uint64_t) 0x7fff)
-        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+	break;
+      if ((stack_top & ~(uint64_t) 0x7fff) != 0x0
+	  && (stack_top & ~(uint64_t) 0x7fff) != ~(uint64_t) 0x7fff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
       insn = bfd_getl32 (buf);
       insn = (insn & 0xfc0003ff) | ((stack_top & 0xffff) << 10);
       bfd_putl32 (insn, buf);
@@ -993,13 +993,13 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 
     case BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2:
       if (!last_reloc_is_sop_push_pcrel)
-        break;
+	break;
       if ((stack_top & 0x3) != 0)
-        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
       stack_top >>= 2;
-      if ((stack_top & ~(uint64_t) 0x7fff) != 0x0 &&
-          (stack_top & ~(uint64_t) 0x7fff) != ~(uint64_t) 0x7fff)
-        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      if ((stack_top & ~(uint64_t) 0x7fff) != 0x0
+	  && (stack_top & ~(uint64_t) 0x7fff) != ~(uint64_t) 0x7fff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
       insn = bfd_getl32 (buf);
       insn = (insn & 0xfc0003ff) | ((stack_top & 0xffff) << 10);
       bfd_putl32 (insn, buf);
@@ -1007,25 +1007,25 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 
     case BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2:
       if (!last_reloc_is_sop_push_pcrel)
-        break;
+	break;
       if ((stack_top & 0x3) != 0)
-        break;
+	break;
       stack_top >>= 2;
-      if ((stack_top & ~(uint64_t) 0xfffff) != 0x0 &&
-          (stack_top & ~(uint64_t) 0xfffff) != ~(uint64_t) 0xfffff)
-        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      if ((stack_top & ~(uint64_t) 0xfffff) != 0x0
+	  && (stack_top & ~(uint64_t) 0xfffff) != ~(uint64_t) 0xfffff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
       insn = bfd_getl32 (buf);
       insn = (insn & 0xfc0003e0) | ((stack_top & 0xffff) << 10) |
-             ((stack_top & 0x1f0000) >> 16);
+	     ((stack_top & 0x1f0000) >> 16);
       bfd_putl32 (insn, buf);
       break;
 
     case BFD_RELOC_LARCH_SOP_POP_32_S_5_20:
       if (!last_reloc_is_sop_push_pcrel)
-        break;
-      if ((stack_top & ~(uint64_t) 0x7ffff) != 0x0 &&
-          (stack_top & ~(uint64_t) 0x7ffff) != ~(uint64_t) 0x7ffff)
-        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+	break;
+      if ((stack_top & ~(uint64_t) 0x7ffff) != 0x0
+	  && (stack_top & ~(uint64_t) 0x7ffff) != ~(uint64_t) 0x7ffff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
       insn = bfd_getl32 (buf);
       insn = (insn & (~(uint32_t) 0x1ffffe0)) | ((stack_top & 0xfffff) << 5);
       bfd_putl32 (insn, buf);
@@ -1033,74 +1033,74 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 
     case BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2:
       if (!last_reloc_is_sop_push_pcrel)
-        break;
+	break;
       if ((stack_top & 0x3) != 0)
-        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
       stack_top >>= 2;
-      if ((stack_top & ~(uint64_t) 0x1ffffff) != 0x0 &&
-          (stack_top & ~(uint64_t) 0x1ffffff) != ~(uint64_t) 0x1ffffff)
-        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+      if ((stack_top & ~(uint64_t) 0x1ffffff) != 0x0
+	  && (stack_top & ~(uint64_t) 0x1ffffff) != ~(uint64_t) 0x1ffffff)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
       insn = bfd_getl32 (buf);
       insn = (insn & 0xfc000000) | ((stack_top & 0xffff) << 10) |
-             ((stack_top & 0x3ff0000) >> 16);
+	     ((stack_top & 0x3ff0000) >> 16);
       bfd_putl32 (insn, buf);
       break;
 
     case BFD_RELOC_LARCH_SOP_POP_32_U:
       if (!last_reloc_is_sop_push_pcrel)
-        break;
+	break;
       if (stack_top & ~(uint64_t) 0xffffffff)
-        as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
+	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
       bfd_putl32 (stack_top, buf);
       break;
 
     case BFD_RELOC_64:
     case BFD_RELOC_32:
       if (fixP->fx_subsy)
-        {
-        case BFD_RELOC_24:
-        case BFD_RELOC_16:
-        case BFD_RELOC_8:
-          fixP->fx_next = xmemdup (fixP, sizeof (*fixP), sizeof (*fixP));
-          fixP->fx_next->fx_addsy = fixP->fx_subsy;
-          fixP->fx_next->fx_subsy = NULL;
-          fixP->fx_next->fx_offset = 0;
-          fixP->fx_subsy = NULL;
-
-          switch (fixP->fx_r_type)
-            {
-            case BFD_RELOC_64:
-              fixP->fx_r_type = BFD_RELOC_LARCH_ADD64;
-              fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB64;
-              break;
-            case BFD_RELOC_32:
-              fixP->fx_r_type = BFD_RELOC_LARCH_ADD32;
-              fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB32;
-              break;
-            case BFD_RELOC_24:
-              fixP->fx_r_type = BFD_RELOC_LARCH_ADD24;
-              fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB24;
-              break;
-            case BFD_RELOC_16:
-              fixP->fx_r_type = BFD_RELOC_LARCH_ADD16;
-              fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB16;
-              break;
-            case BFD_RELOC_8:
-              fixP->fx_r_type = BFD_RELOC_LARCH_ADD8;
-              fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB8;
-              break;
-            default:
-              break;
-            }
-          md_number_to_chars (buf, 0, fixP->fx_size);
-          if (fixP->fx_next->fx_addsy == NULL)
-            fixP->fx_next->fx_done = 1;
-        }
+	{
+	case BFD_RELOC_24:
+	case BFD_RELOC_16:
+	case BFD_RELOC_8:
+	  fixP->fx_next = xmemdup (fixP, sizeof (*fixP), sizeof (*fixP));
+	  fixP->fx_next->fx_addsy = fixP->fx_subsy;
+	  fixP->fx_next->fx_subsy = NULL;
+	  fixP->fx_next->fx_offset = 0;
+	  fixP->fx_subsy = NULL;
+
+	  switch (fixP->fx_r_type)
+	    {
+	    case BFD_RELOC_64:
+	      fixP->fx_r_type = BFD_RELOC_LARCH_ADD64;
+	      fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB64;
+	      break;
+	    case BFD_RELOC_32:
+	      fixP->fx_r_type = BFD_RELOC_LARCH_ADD32;
+	      fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB32;
+	      break;
+	    case BFD_RELOC_24:
+	      fixP->fx_r_type = BFD_RELOC_LARCH_ADD24;
+	      fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB24;
+	      break;
+	    case BFD_RELOC_16:
+	      fixP->fx_r_type = BFD_RELOC_LARCH_ADD16;
+	      fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB16;
+	      break;
+	    case BFD_RELOC_8:
+	      fixP->fx_r_type = BFD_RELOC_LARCH_ADD8;
+	      fixP->fx_next->fx_r_type = BFD_RELOC_LARCH_SUB8;
+	      break;
+	    default:
+	      break;
+	    }
+	  md_number_to_chars (buf, 0, fixP->fx_size);
+	  if (fixP->fx_next->fx_addsy == NULL)
+	    fixP->fx_next->fx_done = 1;
+	}
       if (fixP->fx_addsy == NULL)
-        {
-          fixP->fx_done = 1;
-          md_number_to_chars (buf, *valP, fixP->fx_size);
-        }
+	{
+	  fixP->fx_done = 1;
+	  md_number_to_chars (buf, *valP, fixP->fx_size);
+	}
       break;
 
     default:
@@ -1110,15 +1110,15 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 
 int
 loongarch_relax_frag (asection *sec ATTRIBUTE_UNUSED,
-                      fragS *fragp ATTRIBUTE_UNUSED,
-                      long stretch ATTRIBUTE_UNUSED)
+		      fragS *fragp ATTRIBUTE_UNUSED,
+		      long stretch ATTRIBUTE_UNUSED)
 {
   return 0;
 }
 
 int
 md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED,
-                               asection *segtype ATTRIBUTE_UNUSED)
+			       asection *segtype ATTRIBUTE_UNUSED)
 {
   return 0;
 }
@@ -1139,8 +1139,8 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
   if (reloc->howto == NULL)
     {
       as_bad_where (fixp->fx_file, fixp->fx_line,
-                    _ ("cannot represent %s relocation in object file"),
-                    bfd_get_reloc_code_name (fixp->fx_r_type));
+		    _ ("cannot represent %s relocation in object file"),
+		    bfd_get_reloc_code_name (fixp->fx_r_type));
       return NULL;
     }
 
@@ -1150,7 +1150,7 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
 /* Convert a machine dependent frag.  */
 void
 md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT asec ATTRIBUTE_UNUSED,
-                 fragS *fragp ATTRIBUTE_UNUSED)
+		 fragS *fragp ATTRIBUTE_UNUSED)
 {
   /* fragp->fr_fix += 8; */
 }
@@ -1195,7 +1195,7 @@ loongarch_handle_align (fragS *fragp)
     return;
 
   struct loongarch_cl_insn nop = { .name = "andi",
-                                   .arg_strs = { "$r0", "$r0", "0", NULL } };
+				   .arg_strs = { "$r0", "$r0", "0", NULL } };
 
   get_loongarch_opcode (&nop);
   gas_assert (nop.all_match);
-- 
2.30.1

