From 23113ed581a179e77d21e2940de3e8057656f736 Mon Sep 17 00:00:00 2001
From: liuzhensong <liuzhensong@loongson.cn>
Date: Thu, 12 Aug 2021 11:13:58 +0800
Subject: [PATCH 17/30] binutils: change format by check_GNU_style.sh

  bfd/cpu-loongarch.c
  bfd/elfnn-loongarch.c
  bfd/elfxx-loongarch.c
  bfd/elfxx-loongarch.h
  gas/config/loongarch-lex-wrapper.c
  gas/config/loongarch-lex.l
  gas/config/loongarch-parse.y
  gas/config/tc-loongarch.c
  gas/config/tc-loongarch.h
  gdb/arch/loongarch-linux-nat.h
  gdb/arch/loongarch.c
  gdb/loongarch-linux-nat.c
  gdb/loongarch-linux-tdep.c
  gdb/loongarch-linux-tdep.h
  gdb/loongarch-tdep.c
  gdb/loongarch-tdep.h
  gdb/nat/loongarch-linux-watch.c
  gdb/nat/loongarch-linux-watch.h
  gdbserver/linux-loongarch-low.cc
  include/elf/loongarch.h
  include/opcode/loongarch.h
  ld/emultempl/loongarchelf.em
  opcodes/loongarch-coder.c
  opcodes/loongarch-dis.c
  opcodes/loongarch-opc.c
---
 bfd/cpu-loongarch.c                |   56 +-
 bfd/elfnn-loongarch.c              | 2867 ++++++++++++++--------------
 bfd/elfxx-loongarch.c              |   42 +-
 bfd/elfxx-loongarch.h              |    2 +-
 gas/config/loongarch-lex-wrapper.c |    2 +-
 gas/config/loongarch-lex.l         |    2 +-
 gas/config/loongarch-parse.y       |   14 +-
 gas/config/tc-loongarch.c          |   53 +-
 gas/config/tc-loongarch.h          |   16 +-
 include/elf/loongarch.h            |   10 +-
 include/opcode/loongarch.h         |   44 +-
 ld/emultempl/loongarchelf.em       |    6 +-
 opcodes/loongarch-coder.c          |  346 ++--
 opcodes/loongarch-dis.c            |  134 +-
 opcodes/loongarch-opc.c            |   25 +-
 15 files changed, 1820 insertions(+), 1799 deletions(-)

diff --git a/bfd/cpu-loongarch.c b/bfd/cpu-loongarch.c
index 381c1f0c94d..0502113e04b 100644
--- a/bfd/cpu-loongarch.c
+++ b/bfd/cpu-loongarch.c
@@ -15,7 +15,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 
 #include "sysdep.h"
@@ -24,36 +24,38 @@
 
 static const bfd_arch_info_type bfd_loongarch32_arch =
 {
-  32,                     /* 32 bits in a word.  */
-  32,                     /* 64 bits in an address.  */
-  8,                      /* 8 bits in a byte.  */
-  bfd_arch_loongarch,     /* Architecture.  */
-  bfd_mach_loongarch32,   /* Machine number - 0 for now.  */
-  "loongarch32",          /* Architecture name.  */
-  "Loongarch32",          /* Printable name.  */
-  3,                      /* Section align power.  */
-  false,                  /* This is the default architecture.  */
-  bfd_default_compatible, /* Architecture comparison function.  */
-  bfd_default_scan,       /* String to architecture conversion.  */
-  bfd_arch_default_fill,  /* Default fill.  */
-  NULL,                   /* Next in list.  */
+  32,				/* 32 bits in a word.  */
+  32,				/* 64 bits in an address.  */
+  8,				/* 8 bits in a byte.  */
+  bfd_arch_loongarch,		/* Architecture.  */
+  bfd_mach_loongarch32, 	/* Machine number - 0 for now.  */
+  "loongarch32",		/* Architecture name.  */
+  "Loongarch32",		/* Printable name.  */
+  3,				/* Section align power.  */
+  false,			/* This is the default architecture.  */
+  bfd_default_compatible,	/* Architecture comparison function.  */
+  bfd_default_scan,		/* String to architecture conversion.  */
+  bfd_arch_default_fill,	/* Default fill.  */
+  NULL, 			/* Next in list.  */
   0,
 };
 
 const bfd_arch_info_type bfd_loongarch_arch =
 {
-  32,                   /* 32 bits in a word.  */
-  64,                   /* 64 bits in an address.  */
-  8,                    /* 8 bits in a byte.  */
-  bfd_arch_loongarch,   /* Architecture.  */
-  bfd_mach_loongarch64, /* Machine number of loongarch64 is larger so that loongarch64 is compatible to loongarch32  */
-  "loongarch64",        /* Architecture name.  */
-  "Loongarch64",        /* Printable name.  */
-  3,                    /* Section align power.  */
-  true,                 /* This is the default architecture.  */
-  bfd_default_compatible, /* Architecture comparison function.  */
-  bfd_default_scan,       /* String to architecture conversion.  */
-  bfd_arch_default_fill,  /* Default fill.  */
-  &bfd_loongarch32_arch,  /* Next in list.  */
+  32,				/* 32 bits in a word.  */
+  64,				/* 64 bits in an address.  */
+  8,				/* 8 bits in a byte.  */
+  bfd_arch_loongarch,		/* Architecture.  */
+  /* Machine number of loongarch64 is larger
+   * so that loongarch64 is compatible to loongarch32.  */
+  bfd_mach_loongarch64,
+  "loongarch64",		/* Architecture name.  */
+  "Loongarch64",		/* Printable name.  */
+  3,				/* Section align power.  */
+  true, 			/* This is the default architecture.  */
+  bfd_default_compatible,	/* Architecture comparison function.  */
+  bfd_default_scan,		/* String to architecture conversion.  */
+  bfd_arch_default_fill,	/* Default fill.  */
+  &bfd_loongarch32_arch,	/* Next in list.  */
   0,
 };
diff --git a/bfd/elfnn-loongarch.c b/bfd/elfnn-loongarch.c
index 55f81d2d543..d04e112ef82 100644
--- a/bfd/elfnn-loongarch.c
+++ b/bfd/elfnn-loongarch.c
@@ -15,7 +15,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 
 #include "sysdep.h"
@@ -31,7 +31,7 @@
 
 static bool
 loongarch_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
-                              Elf_Internal_Rela *dst)
+			      Elf_Internal_Rela *dst)
 {
   cache_ptr->howto = loongarch_elf_rtype_to_howto (ELFNN_R_TYPE (dst->r_info));
   return cache_ptr->howto != NULL;
@@ -53,7 +53,7 @@ struct loongarch_elf_link_hash_entry
   char tls_type;
 };
 
-#define loongarch_elf_hash_entry(ent)                                         \
+#define loongarch_elf_hash_entry(ent)	\
   ((struct loongarch_elf_link_hash_entry *) (ent))
 
 struct _bfd_loongarch_elf_obj_tdata
@@ -64,18 +64,18 @@ struct _bfd_loongarch_elf_obj_tdata
   char *local_got_tls_type;
 };
 
-#define _bfd_loongarch_elf_tdata(abfd)                                        \
+#define _bfd_loongarch_elf_tdata(abfd)	\
   ((struct _bfd_loongarch_elf_obj_tdata *) (abfd)->tdata.any)
 
-#define _bfd_loongarch_elf_local_got_tls_type(abfd)                           \
+#define _bfd_loongarch_elf_local_got_tls_type(abfd)	\
   (_bfd_loongarch_elf_tdata (abfd)->local_got_tls_type)
 
-#define _bfd_loongarch_elf_tls_type(abfd, h, symndx)                          \
-  (*((h) != NULL ? &loongarch_elf_hash_entry (h)->tls_type                    \
-                 : &_bfd_loongarch_elf_local_got_tls_type (abfd)[symndx]))
+#define _bfd_loongarch_elf_tls_type(abfd, h, symndx)			  \
+  (*((h) != NULL ? &loongarch_elf_hash_entry (h)->tls_type		  \
+		 : &_bfd_loongarch_elf_local_got_tls_type (abfd)[symndx]))
 
-#define is_loongarch_elf(bfd)                                                 \
-  (bfd_get_flavour (bfd) == bfd_target_elf_flavour &&                         \
+#define is_loongarch_elf(bfd)						 \
+  (bfd_get_flavour (bfd) == bfd_target_elf_flavour &&			 \
    elf_tdata (bfd) != NULL && elf_object_id (bfd) == LARCH_ELF_DATA)
 
 struct loongarch_elf_link_hash_table
@@ -97,10 +97,10 @@ struct loongarch_elf_link_hash_table
 };
 
 /* Get the Loongarch ELF linker hash table from a link_info structure.  */
-#define loongarch_elf_hash_table(p)                                           \
-  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) ==          \
-       LARCH_ELF_DATA                                                         \
-     ? ((struct loongarch_elf_link_hash_table *) ((p)->hash))                 \
+#define loongarch_elf_hash_table(p)					\
+  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash))	\
+    == LARCH_ELF_DATA							\
+     ? ((struct loongarch_elf_link_hash_table *) ((p)->hash))		\
      : NULL)
 
 #define MINUS_ONE ((bfd_vma) 0 - 1)
@@ -140,7 +140,7 @@ struct loongarch_elf_link_hash_table
 
 static void
 loongarch_make_plt_header (bfd_vma got_plt_addr, bfd_vma plt_header_addr,
-                           uint32_t *entry)
+			   uint32_t *entry)
 {
   int64_t pcrel = got_plt_addr - plt_header_addr;
   int64_t hi = (pcrel & 0x800 ? 1 : 0) + (pcrel >> 12);
@@ -185,7 +185,7 @@ loongarch_make_plt_header (bfd_vma got_plt_addr, bfd_vma plt_header_addr,
 
 static void
 loongarch_make_plt_entry (bfd_vma got_plt_entry_addr, bfd_vma plt_entry_addr,
-                          uint32_t *entry)
+			  uint32_t *entry)
 {
   int64_t pcrel = got_plt_entry_addr - plt_entry_addr;
   int64_t hi = (pcrel & 0x800 ? 1 : 0) + (pcrel >> 12);
@@ -196,8 +196,8 @@ loongarch_make_plt_entry (bfd_vma got_plt_entry_addr, bfd_vma plt_entry_addr,
   entry[0] = 0x1c00000f | (hi & 0xfffff) << 5;
   entry[1] = (GOT_ENTRY_SIZE == 8 ? 0x28c001ef : 0x288001ef)
 	     | (lo & 0xfff) << 10;
-  entry[2] = 0x4c0001ed;        /* jirl $r13, $15, 0 */
-  entry[3] = 0x03400000;        /* nop */
+  entry[2] = 0x4c0001ed;	/* jirl $r13, $15, 0 */
+  entry[3] = 0x03400000;	/* nop */
   /* entry[2] = 0x1c00000d; */ /* pcaddu12i $13, 4 */
   /* entry[3] = 0x4c0001e0; */ /* jirl $r0, $15, 0 */
 }
@@ -206,16 +206,16 @@ loongarch_make_plt_entry (bfd_vma got_plt_entry_addr, bfd_vma plt_entry_addr,
 
 static struct bfd_hash_entry *
 link_hash_newfunc (struct bfd_hash_entry *entry, struct bfd_hash_table *table,
-                   const char *string)
+		   const char *string)
 {
   /* Allocate the structure if it has not already been allocated by a
      subclass.  */
   if (entry == NULL)
     {
       entry = bfd_hash_allocate (
-        table, sizeof (struct loongarch_elf_link_hash_entry));
+	table, sizeof (struct loongarch_elf_link_hash_entry));
       if (entry == NULL)
-        return entry;
+	return entry;
     }
 
   /* Call the allocation method of the superclass.  */
@@ -258,8 +258,8 @@ elfNN_loongarch_local_htab_eq (const void *ptr1, const void *ptr2)
 /* Find and/or create a hash entry for local symbol.  */
 static struct elf_link_hash_entry *
 elfNN_loongarch_get_local_sym_hash (struct loongarch_elf_link_hash_table *htab,
-                                    bfd *abfd, const Elf_Internal_Rela *rel,
-                                    bool create)
+				    bfd *abfd, const Elf_Internal_Rela *rel,
+				    bool create)
 {
   struct loongarch_elf_link_hash_entry e, *ret;
   asection *sec = abfd->sections;
@@ -269,7 +269,7 @@ elfNN_loongarch_get_local_sym_hash (struct loongarch_elf_link_hash_table *htab,
   e.elf.indx = sec->id;
   e.elf.dynstr_index = ELFNN_R_SYM (rel->r_info);
   slot = htab_find_slot_with_hash (htab->loc_hash_table, &e, h,
-                                   create ? INSERT : NO_INSERT);
+				   create ? INSERT : NO_INSERT);
 
   if (!slot)
     return NULL;
@@ -333,8 +333,8 @@ loongarch_elf_link_hash_table_create (bfd *abfd)
     return NULL;
 
   if (!_bfd_elf_link_hash_table_init (
-        &ret->elf, abfd, link_hash_newfunc,
-        sizeof (struct loongarch_elf_link_hash_entry), LARCH_ELF_DATA))
+	&ret->elf, abfd, link_hash_newfunc,
+	sizeof (struct loongarch_elf_link_hash_entry), LARCH_ELF_DATA))
     {
       free (ret);
       return NULL;
@@ -343,7 +343,7 @@ loongarch_elf_link_hash_table_create (bfd *abfd)
   ret->max_alignment = MINUS_ONE;
 
   ret->loc_hash_table = htab_try_create (1024, elfNN_loongarch_local_htab_hash,
-                                         elfNN_loongarch_local_htab_eq, NULL);
+					 elfNN_loongarch_local_htab_eq, NULL);
   ret->loc_hash_memory = objalloc_create ();
   if (!ret->loc_hash_table || !ret->loc_hash_memory)
     {
@@ -370,16 +370,16 @@ elfNN_loongarch_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       /* Make sure one of ibfd or obfd e_flags must be set.  */
       /* FIXME: EF_LARCH_ABI_LP64 ? .  */
       if (!is_loongarch_elf (ibfd) && !elf_flags_init (obfd))
-        {
-          elf_flags_init (obfd) = true;
-          elf_elfheader (obfd)->e_flags = EF_LARCH_ABI_LP64;
-        }
+	{
+	  elf_flags_init (obfd) = true;
+	  elf_elfheader (obfd)->e_flags = EF_LARCH_ABI_LP64;
+	}
 
       if (!is_loongarch_elf (obfd) && !elf_flags_init (ibfd))
-        {
-          elf_flags_init (ibfd) = true;
-          elf_elfheader (ibfd)->e_flags = EF_LARCH_ABI_LP64;
-        }
+	{
+	  elf_flags_init (ibfd) = true;
+	  elf_elfheader (ibfd)->e_flags = EF_LARCH_ABI_LP64;
+	}
 
       return true;
     }
@@ -387,9 +387,9 @@ elfNN_loongarch_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
   if (strcmp (bfd_get_target (ibfd), bfd_get_target (obfd)) != 0)
     {
       _bfd_error_handler (
-        _ ("%pB: ABI is incompatible with that of the selected emulation:\n"
-           "  target emulation `%s' does not match `%s'"),
-        ibfd, bfd_get_target (ibfd), bfd_get_target (obfd));
+	_ ("%pB: ABI is incompatible with that of the selected emulation:\n"
+	   "  target emulation `%s' does not match `%s'"),
+	ibfd, bfd_get_target (ibfd), bfd_get_target (obfd));
       return false;
     }
 
@@ -453,7 +453,7 @@ loongarch_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)
     {
       s = bfd_make_section_anyway_with_flags (abfd, ".got.plt", flags);
       if (s == NULL || !bfd_set_section_alignment (s, bed->s->log_file_align))
-        return false;
+	return false;
       htab->sgotplt = s;
 
       /* Reserve room for the header.  */
@@ -463,13 +463,13 @@ loongarch_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)
   if (bed->want_got_sym)
     {
       /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
-         section.  We don't do this in the linker script because we don't want
-         to define the symbol if we are not creating a global offset table.  */
+	 section.  We don't do this in the linker script because we don't want
+	 to define the symbol if we are not creating a global offset table.  */
       h = _bfd_elf_define_linkage_sym (abfd, info, s_got,
-                                       "_GLOBAL_OFFSET_TABLE_");
+				       "_GLOBAL_OFFSET_TABLE_");
       elf_hash_table (info)->hgot = h;
       if (h == NULL)
-        return false;
+	return false;
     }
   return true;
 }
@@ -495,11 +495,11 @@ loongarch_elf_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
   if (!bfd_link_pic (info))
     {
       htab->sdyntdata = bfd_make_section_anyway_with_flags (
-        dynobj, ".tdata.dyn", SEC_ALLOC | SEC_THREAD_LOCAL);
+	dynobj, ".tdata.dyn", SEC_ALLOC | SEC_THREAD_LOCAL);
     }
 
-  if (!htab->elf.splt || !htab->elf.srelplt || !htab->elf.sdynbss ||
-      (!bfd_link_pic (info) && (!htab->elf.srelbss || !htab->sdyntdata)))
+  if (!htab->elf.splt || !htab->elf.srelplt || !htab->elf.sdynbss
+      ||(!bfd_link_pic (info) && (!htab->elf.srelbss || !htab->sdyntdata)))
     abort ();
 
   return true;
@@ -507,10 +507,10 @@ loongarch_elf_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
 
 static bool
 loongarch_elf_record_tls_and_got_reference (bfd *abfd,
-                                            struct bfd_link_info *info,
-                                            struct elf_link_hash_entry *h,
-                                            unsigned long symndx,
-                                            char tls_type)
+					    struct bfd_link_info *info,
+					    struct elf_link_hash_entry *h,
+					    unsigned long symndx,
+					    char tls_type)
 {
   struct loongarch_elf_link_hash_table *htab = loongarch_elf_hash_table (info);
   Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
@@ -519,11 +519,11 @@ loongarch_elf_record_tls_and_got_reference (bfd *abfd,
   if (elf_local_got_refcounts (abfd) == NULL)
     {
       bfd_size_type size =
-        symtab_hdr->sh_info * (sizeof (bfd_vma) + sizeof (tls_type));
+	symtab_hdr->sh_info * (sizeof (bfd_vma) + sizeof (tls_type));
       if (!(elf_local_got_refcounts (abfd) = bfd_zalloc (abfd, size)))
-        return false;
+	return false;
       _bfd_loongarch_elf_local_got_tls_type (abfd) =
-        (char *) (elf_local_got_refcounts (abfd) + symtab_hdr->sh_info);
+	(char *) (elf_local_got_refcounts (abfd) + symtab_hdr->sh_info);
     }
 
   switch (tls_type)
@@ -531,21 +531,21 @@ loongarch_elf_record_tls_and_got_reference (bfd *abfd,
     case GOT_NORMAL:
     case GOT_TLS_GD:
     case GOT_TLS_IE:
-      /* Need GOT. */
-      if (htab->elf.sgot == NULL &&
-          !loongarch_elf_create_got_section (htab->elf.dynobj, info))
-        return false;
+      /* Need GOT.  */
+      if (htab->elf.sgot == NULL
+	  && !loongarch_elf_create_got_section (htab->elf.dynobj, info))
+	return false;
       if (h)
-        {
-          if (h->got.refcount < 0)
-            h->got.refcount = 0;
-          h->got.refcount++;
-        }
+	{
+	  if (h->got.refcount < 0)
+	    h->got.refcount = 0;
+	  h->got.refcount++;
+	}
       else
-        elf_local_got_refcounts (abfd)[symndx]++;
+	elf_local_got_refcounts (abfd)[symndx]++;
       break;
     case GOT_TLS_LE:
-      /* No need for GOT. */
+      /* No need for GOT.  */
       break;
     default:
       _bfd_error_handler (_ ("Interl error: unreachable."));
@@ -557,8 +557,8 @@ loongarch_elf_record_tls_and_got_reference (bfd *abfd,
   if ((*new_tls_type & GOT_NORMAL) && (*new_tls_type & ~GOT_NORMAL))
     {
       _bfd_error_handler (
-        _ ("%pB: `%s' accessed both as normal and thread local symbol"), abfd,
-        h ? h->root.root.string : "<local>");
+	_ ("%pB: `%s' accessed both as normal and thread local symbol"), abfd,
+	h ? h->root.root.string : "<local>");
       return false;
     }
 
@@ -571,7 +571,7 @@ loongarch_elf_record_tls_and_got_reference (bfd *abfd,
 
 static bool
 loongarch_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
-                            asection *sec, const Elf_Internal_Rela *relocs)
+			    asection *sec, const Elf_Internal_Rela *relocs)
 {
   struct loongarch_elf_link_hash_table *htab;
   Elf_Internal_Shdr *symtab_hdr;
@@ -603,227 +603,227 @@ loongarch_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
       r_type = ELFNN_R_TYPE (rel->r_info);
 
       if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
-        {
-          _bfd_error_handler (_ ("%pB: bad symbol index: %d"), abfd, r_symndx);
-          return false;
-        }
+	{
+	  _bfd_error_handler (_ ("%pB: bad symbol index: %d"), abfd, r_symndx);
+	  return false;
+	}
 
       if (r_symndx < symtab_hdr->sh_info)
-        {
-          /* A local symbol.  */
-          isym = bfd_sym_from_r_symndx (&htab->sym_cache, abfd, r_symndx);
-          if (isym == NULL)
-            return false;
-
-          if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
-            {
-              h = elfNN_loongarch_get_local_sym_hash (htab, abfd, rel, true);
-              if (h == NULL)
-                return false;
-
-              h->type = STT_GNU_IFUNC;
-              h->ref_regular = 1;
-            }
-          else
-            h = NULL;
-        }
+	{
+	  /* A local symbol.  */
+	  isym = bfd_sym_from_r_symndx (&htab->sym_cache, abfd, r_symndx);
+	  if (isym == NULL)
+	    return false;
+
+	  if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
+	    {
+	      h = elfNN_loongarch_get_local_sym_hash (htab, abfd, rel, true);
+	      if (h == NULL)
+		return false;
+
+	      h->type = STT_GNU_IFUNC;
+	      h->ref_regular = 1;
+	    }
+	  else
+	    h = NULL;
+	}
       else
-        {
-          h = sym_hashes[r_symndx - symtab_hdr->sh_info];
-          while (h->root.type == bfd_link_hash_indirect ||
-                 h->root.type == bfd_link_hash_warning)
-            h = (struct elf_link_hash_entry *) h->root.u.i.link;
-        }
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	}
 
       if (h && h->type == STT_GNU_IFUNC)
-        {
-          if (htab->elf.dynobj == NULL)
-            htab->elf.dynobj = abfd;
+	{
+	  if (htab->elf.dynobj == NULL)
+	    htab->elf.dynobj = abfd;
 
-          if (!htab->elf.splt &&
-              !_bfd_elf_create_ifunc_sections (htab->elf.dynobj, info))
-            /* If '.plt' not represent, create '.iplt' to deal with ifunc. */
-            return false;
+	  if (!htab->elf.splt
+	      && !_bfd_elf_create_ifunc_sections (htab->elf.dynobj, info))
+	    /* If '.plt' not represent, create '.iplt' to deal with ifunc.  */
+	    return false;
 
-          if (h->plt.refcount < 0)
-            h->plt.refcount = 0;
-          h->plt.refcount++;
-          h->needs_plt = 1;
+	  if (h->plt.refcount < 0)
+	    h->plt.refcount = 0;
+	  h->plt.refcount++;
+	  h->needs_plt = 1;
 
-          elf_tdata (info->output_bfd)->has_gnu_osabi |= elf_gnu_osabi_ifunc;
-        }
+	  elf_tdata (info->output_bfd)->has_gnu_osabi |= elf_gnu_osabi_ifunc;
+	}
 
       need_dynreloc = 0;
       only_need_pcrel = 0;
       switch (r_type)
-        {
-        case R_LARCH_SOP_PUSH_GPREL:
-          if (!loongarch_elf_record_tls_and_got_reference (
-                abfd, info, h, r_symndx, GOT_NORMAL))
-            return false;
-          break;
-
-        case R_LARCH_SOP_PUSH_TLS_GD:
-          if (!loongarch_elf_record_tls_and_got_reference (
-                abfd, info, h, r_symndx, GOT_TLS_GD))
-            return false;
-          break;
-
-        case R_LARCH_SOP_PUSH_TLS_GOT:
-          if (bfd_link_pic (info))
-            /* May fail for lazy-bind. */
-            info->flags |= DF_STATIC_TLS;
-
-          if (!loongarch_elf_record_tls_and_got_reference (
-                abfd, info, h, r_symndx, GOT_TLS_IE))
-            return false;
-          break;
-
-        case R_LARCH_SOP_PUSH_TLS_TPREL:
-          if (!bfd_link_executable (info))
-            return false;
-
-          info->flags |= DF_STATIC_TLS;
-
-          if (!loongarch_elf_record_tls_and_got_reference (
-                abfd, info, h, r_symndx, GOT_TLS_LE))
-            return false;
-          break;
-
-        case R_LARCH_SOP_PUSH_ABSOLUTE:
-          if (h != NULL)
-            /* If this reloc is in a read-only section, we might
-               need a copy reloc.  We can't check reliably at this
-               stage whether the section is read-only, as input
-               sections have not yet been mapped to output sections.
-               Tentatively set the flag for now, and correct in
-               adjust_dynamic_symbol.  */
-            h->non_got_ref = 1;
-          break;
-
-        case R_LARCH_SOP_PUSH_PCREL:
-          if (h != NULL)
-            {
-              h->non_got_ref = 1;
-
-              /* We try to create PLT stub for all non-local function.  */
-              if (h->plt.refcount < 0)
-                h->plt.refcount = 0;
-              h->plt.refcount++;
-            }
-          break;
-
-        case R_LARCH_SOP_PUSH_PLT_PCREL:
-          /* This symbol requires a procedure linkage table entry.  We
-             actually build the entry in adjust_dynamic_symbol,
-             because this might be a case of linking PIC code without
-             linking in any dynamic objects, in which case we don't
-             need to generate a procedure linkage table after all.  */
-          if (h != NULL)
-            {
-              h->needs_plt = 1;
-              if (h->plt.refcount < 0)
-                h->plt.refcount = 0;
-              h->plt.refcount++;
-            }
-          break;
-
-        case R_LARCH_TLS_DTPREL32:
-        case R_LARCH_TLS_DTPREL64:
-          need_dynreloc = 1;
-          only_need_pcrel = 1;
-          break;
-
-        case R_LARCH_JUMP_SLOT:
-        case R_LARCH_32:
-        case R_LARCH_64:
-          need_dynreloc = 1;
-
-          /* If resolved symbol is defined in this object,
-             1. Under pie, the symbol is known. We convert it
-             into R_LARCH_RELATIVE and need load-addr still.
-             2. Under pde, the symbol is known and we can discard R_LARCH_NN.
-             3. Under dll, R_LARCH_NN can't be changed normally, since
-             its defination could be covered by the one in executable.
-             For symbolic, we convert it into R_LARCH_RELATIVE.
-             Thus, only under pde, it needs pcrel only. We discard it. */
-          only_need_pcrel = bfd_link_pde (info);
-
-          if (h != NULL)
-            h->non_got_ref = 1;
-          break;
-
-        case R_LARCH_GNU_VTINHERIT:
-          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
-            return false;
-          break;
-
-        case R_LARCH_GNU_VTENTRY:
-          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
-            return false;
-          break;
-
-        default:
-          break;
-        }
-
-      /* Record some info for sizing and allocating dynamic entry */
+	{
+	case R_LARCH_SOP_PUSH_GPREL:
+	  if (!loongarch_elf_record_tls_and_got_reference (
+		abfd, info, h, r_symndx, GOT_NORMAL))
+	    return false;
+	  break;
+
+	case R_LARCH_SOP_PUSH_TLS_GD:
+	  if (!loongarch_elf_record_tls_and_got_reference (
+		abfd, info, h, r_symndx, GOT_TLS_GD))
+	    return false;
+	  break;
+
+	case R_LARCH_SOP_PUSH_TLS_GOT:
+	  if (bfd_link_pic (info))
+	    /* May fail for lazy-bind.  */
+	    info->flags |= DF_STATIC_TLS;
+
+	  if (!loongarch_elf_record_tls_and_got_reference (
+		abfd, info, h, r_symndx, GOT_TLS_IE))
+	    return false;
+	  break;
+
+	case R_LARCH_SOP_PUSH_TLS_TPREL:
+	  if (!bfd_link_executable (info))
+	    return false;
+
+	  info->flags |= DF_STATIC_TLS;
+
+	  if (!loongarch_elf_record_tls_and_got_reference (
+		abfd, info, h, r_symndx, GOT_TLS_LE))
+	    return false;
+	  break;
+
+	case R_LARCH_SOP_PUSH_ABSOLUTE:
+	  if (h != NULL)
+	    /* If this reloc is in a read-only section, we might
+	       need a copy reloc.  We can't check reliably at this
+	       stage whether the section is read-only, as input
+	       sections have not yet been mapped to output sections.
+	       Tentatively set the flag for now, and correct in
+	       adjust_dynamic_symbol.  */
+	    h->non_got_ref = 1;
+	  break;
+
+	case R_LARCH_SOP_PUSH_PCREL:
+	  if (h != NULL)
+	    {
+	      h->non_got_ref = 1;
+
+	      /* We try to create PLT stub for all non-local function.  */
+	      if (h->plt.refcount < 0)
+		h->plt.refcount = 0;
+	      h->plt.refcount++;
+	    }
+	  break;
+
+	case R_LARCH_SOP_PUSH_PLT_PCREL:
+	  /* This symbol requires a procedure linkage table entry.  We
+	     actually build the entry in adjust_dynamic_symbol,
+	     because this might be a case of linking PIC code without
+	     linking in any dynamic objects, in which case we don't
+	     need to generate a procedure linkage table after all.  */
+	  if (h != NULL)
+	    {
+	      h->needs_plt = 1;
+	      if (h->plt.refcount < 0)
+		h->plt.refcount = 0;
+	      h->plt.refcount++;
+	    }
+	  break;
+
+	case R_LARCH_TLS_DTPREL32:
+	case R_LARCH_TLS_DTPREL64:
+	  need_dynreloc = 1;
+	  only_need_pcrel = 1;
+	  break;
+
+	case R_LARCH_JUMP_SLOT:
+	case R_LARCH_32:
+	case R_LARCH_64:
+	  need_dynreloc = 1;
+
+	  /* If resolved symbol is defined in this object,
+       	     1.  Under pie, the symbol is known.  We convert it
+	     into R_LARCH_RELATIVE and need load-addr still.
+	     2.  Under pde, the symbol is known and we can discard R_LARCH_NN.
+	     3.  Under dll, R_LARCH_NN can't be changed normally, since
+	     its defination could be covered by the one in executable.
+	     For symbolic, we convert it into R_LARCH_RELATIVE.
+	     Thus, only under pde, it needs pcrel only.  We discard it.  */
+	  only_need_pcrel = bfd_link_pde (info);
+
+	  if (h != NULL)
+	    h->non_got_ref = 1;
+	  break;
+
+	case R_LARCH_GNU_VTINHERIT:
+	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+	    return false;
+	  break;
+
+	case R_LARCH_GNU_VTENTRY:
+	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
+	    return false;
+	  break;
+
+	default:
+	  break;
+	}
+
+      /* Record some info for sizing and allocating dynamic entry.  */
       if (need_dynreloc && (sec->flags & SEC_ALLOC))
-        {
-          /* When creating a shared object, we must copy these
-             relocs into the output file.  We create a reloc
-             section in dynobj and make room for the reloc.  */
-          struct elf_dyn_relocs *p;
-          struct elf_dyn_relocs **head;
-
-          if (sreloc == NULL)
-            {
-              sreloc = _bfd_elf_make_dynamic_reloc_section (
-                sec, htab->elf.dynobj, LARCH_ELF_LOG_WORD_BYTES, abfd,
-                /*rela?*/ true);
-
-              if (sreloc == NULL)
-                return false;
-            }
-
-          /* If this is a global symbol, we count the number of
-             relocations we need for this symbol.  */
-          if (h != NULL)
-            head = &((struct loongarch_elf_link_hash_entry *) h)->dyn_relocs;
-          else
-            {
-              /* Track dynamic relocs needed for local syms too.
-                 We really need local syms available to do this
-                 easily.  Oh well.  */
-
-              asection *s;
-              void *vpp;
-
-              s = bfd_section_from_elf_index (abfd, isym->st_shndx);
-              if (s == NULL)
-                s = sec;
-
-              vpp = &elf_section_data (s)->local_dynrel;
-              head = (struct elf_dyn_relocs **) vpp;
-            }
-
-          p = *head;
-          if (p == NULL || p->sec != sec)
-            {
-              bfd_size_type amt = sizeof *p;
-              p = (struct elf_dyn_relocs *) bfd_alloc (htab->elf.dynobj, amt);
-              if (p == NULL)
-                return false;
-              p->next = *head;
-              *head = p;
-              p->sec = sec;
-              p->count = 0;
-              p->pc_count = 0;
-            }
-
-          p->count++;
-          p->pc_count += only_need_pcrel;
-        }
+	{
+	  /* When creating a shared object, we must copy these
+	     relocs into the output file.  We create a reloc
+	     section in dynobj and make room for the reloc.  */
+	  struct elf_dyn_relocs *p;
+	  struct elf_dyn_relocs **head;
+
+	  if (sreloc == NULL)
+	    {
+	      sreloc = _bfd_elf_make_dynamic_reloc_section (
+		sec, htab->elf.dynobj, LARCH_ELF_LOG_WORD_BYTES, abfd,
+		/*rela?*/ true);
+
+	      if (sreloc == NULL)
+		return false;
+	    }
+
+	  /* If this is a global symbol, we count the number of
+	     relocations we need for this symbol.  */
+	  if (h != NULL)
+	    head = &((struct loongarch_elf_link_hash_entry *) h)->dyn_relocs;
+	  else
+	    {
+	      /* Track dynamic relocs needed for local syms too.
+		 We really need local syms available to do this
+		 easily.  Oh well.  */
+
+	      asection *s;
+	      void *vpp;
+
+	      s = bfd_section_from_elf_index (abfd, isym->st_shndx);
+	      if (s == NULL)
+		s = sec;
+
+	      vpp = &elf_section_data (s)->local_dynrel;
+	      head = (struct elf_dyn_relocs **) vpp;
+	    }
+
+	  p = *head;
+	  if (p == NULL || p->sec != sec)
+	    {
+	      bfd_size_type amt = sizeof *p;
+	      p = (struct elf_dyn_relocs *) bfd_alloc (htab->elf.dynobj, amt);
+	      if (p == NULL)
+		return false;
+	      p->next = *head;
+	      *head = p;
+	      p->sec = sec;
+	      p->count = 0;
+	      p->pc_count = 0;
+	    }
+
+	  p->count++;
+	  p->pc_count += only_need_pcrel;
+	}
     }
 
   return true;
@@ -841,7 +841,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)
       asection *s = p->sec->output_section;
 
       if (s != NULL && (s->flags & SEC_READONLY) != 0)
-        return p->sec;
+	return p->sec;
     }
   return NULL;
 }
@@ -853,7 +853,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)
    understand.  */
 static bool
 loongarch_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
-                                     struct elf_link_hash_entry *h)
+				     struct elf_link_hash_entry *h)
 {
   struct loongarch_elf_link_hash_table *htab;
   struct loongarch_elf_link_hash_entry *eh;
@@ -866,30 +866,30 @@ loongarch_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
   dynobj = htab->elf.dynobj;
 
   /* Make sure we know what is going on here.  */
-  BFD_ASSERT (dynobj != NULL &&
-              (h->needs_plt || h->type == STT_GNU_IFUNC || h->is_weakalias ||
-               (h->def_dynamic && h->ref_regular && !h->def_regular)));
+  BFD_ASSERT (dynobj != NULL
+	      && (h->needs_plt || h->type == STT_GNU_IFUNC || h->is_weakalias
+		 || (h->def_dynamic && h->ref_regular && !h->def_regular)));
 
   /* If this is a function, put it in the procedure linkage table.  We
      will fill in the contents of the procedure linkage table later
      (although we could actually do it here).  */
   if (h->type == STT_FUNC || h->type == STT_GNU_IFUNC || h->needs_plt)
     {
-      if (h->plt.refcount < 0 ||
-          (h->type != STT_GNU_IFUNC &&
-           (SYMBOL_REFERENCES_LOCAL (info, h) ||
-            (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT &&
-             h->root.type == bfd_link_hash_undefweak))))
-        {
-          /* This case can occur if we saw a R_LARCH_SOP_PUSH_PLT_PCREL reloc
-             in an input file, but the symbol was never referred to by a
-             dynamic object, or if all references were garbage collected.
-             In such a case, we don't actually need to build a PLT entry.  */
-          h->plt.offset = MINUS_ONE;
-          h->needs_plt = 0;
-        }
+      if (h->plt.refcount < 0
+	  || (h->type != STT_GNU_IFUNC
+	     && (SYMBOL_REFERENCES_LOCAL (info, h)
+	     	|| (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
+		   && h->root.type == bfd_link_hash_undefweak))))
+	{
+	  /* This case can occur if we saw a R_LARCH_SOP_PUSH_PLT_PCREL reloc
+	     in an input file, but the symbol was never referred to by a
+	     dynamic object, or if all references were garbage collected.
+	     In such a case, we don't actually need to build a PLT entry.  */
+	  h->plt.offset = MINUS_ONE;
+	  h->needs_plt = 0;
+	}
       else
-        h->needs_plt = 1;
+	h->needs_plt = 1;
 
       return true;
     }
@@ -1001,39 +1001,39 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
       asection *plt, *gotplt, *relplt;
 
       if (!h->needs_plt)
-        break;
+	break;
 
       h->needs_plt = 0;
 
       if (htab->elf.splt)
-        {
-          if (h->dynindx == -1 && !h->forced_local &&
-              !bfd_elf_link_record_dynamic_symbol (info, h))
-            return false;
-
-          if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, bfd_link_pic (info), h) &&
-              h->type != STT_GNU_IFUNC)
-            break;
-
-          plt = htab->elf.splt;
-          gotplt = htab->elf.sgotplt;
-          relplt = htab->elf.srelplt;
-        }
+	{
+	  if (h->dynindx == -1 && !h->forced_local
+	      && !bfd_elf_link_record_dynamic_symbol (info, h))
+	    return false;
+
+	  if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, bfd_link_pic (info), h)
+	      && h->type != STT_GNU_IFUNC)
+	    break;
+
+	  plt = htab->elf.splt;
+	  gotplt = htab->elf.sgotplt;
+	  relplt = htab->elf.srelplt;
+	}
       else if (htab->elf.iplt)
-        {
-          /* .iplt only for IFUNC */
-          if (h->type != STT_GNU_IFUNC)
-            break;
-
-          plt = htab->elf.iplt;
-          gotplt = htab->elf.igotplt;
-          relplt = htab->elf.irelplt;
-        }
+	{
+	  /* .iplt only for IFUNC.  */
+	  if (h->type != STT_GNU_IFUNC)
+	    break;
+
+	  plt = htab->elf.iplt;
+	  gotplt = htab->elf.igotplt;
+	  relplt = htab->elf.irelplt;
+	}
       else
-        break;
+	break;
 
       if (plt->size == 0)
-        plt->size = PLT_HEADER_SIZE;
+	plt->size = PLT_HEADER_SIZE;
 
       h->plt.offset = plt->size;
       plt->size += PLT_ENTRY_SIZE;
@@ -1054,38 +1054,38 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
       int tls_type = loongarch_elf_hash_entry (h)->tls_type;
 
       /* Make sure this symbol is output as a dynamic symbol.
-         Undefined weak syms won't yet be marked as dynamic.  */
-      if (h->dynindx == -1 && !h->forced_local &&
-          !bfd_elf_link_record_dynamic_symbol (info, h))
-        return false;
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1 && !h->forced_local
+	  && !bfd_elf_link_record_dynamic_symbol (info, h))
+	return false;
 
       s = htab->elf.sgot;
       h->got.offset = s->size;
       dyn = htab->elf.dynamic_sections_created;
       if (tls_type & (GOT_TLS_GD | GOT_TLS_IE))
-        {
-          /* TLS_GD needs two dynamic relocs and two GOT slots.  */
-          if (tls_type & GOT_TLS_GD)
-            {
-              s->size += 2 * GOT_ENTRY_SIZE;
-              htab->elf.srelgot->size += 2 * sizeof (ElfNN_External_Rela);
-            }
-
-          /* TLS_IE needs one dynamic reloc and one GOT slot.  */
-          if (tls_type & GOT_TLS_IE)
-            {
-              s->size += GOT_ENTRY_SIZE;
-              htab->elf.srelgot->size += sizeof (ElfNN_External_Rela);
-            }
-        }
+	{
+	  /* TLS_GD needs two dynamic relocs and two GOT slots.  */
+	  if (tls_type & GOT_TLS_GD)
+	    {
+	      s->size += 2 * GOT_ENTRY_SIZE;
+	      htab->elf.srelgot->size += 2 * sizeof (ElfNN_External_Rela);
+	    }
+
+	  /* TLS_IE needs one dynamic reloc and one GOT slot.  */
+	  if (tls_type & GOT_TLS_IE)
+	    {
+	      s->size += GOT_ENTRY_SIZE;
+	      htab->elf.srelgot->size += sizeof (ElfNN_External_Rela);
+	    }
+	}
       else
-        {
-          s->size += GOT_ENTRY_SIZE;
-          if ((WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, bfd_link_pic (info), h) &&
-               !UNDEFWEAK_NO_DYNAMIC_RELOC (info, h)) ||
-              h->type == STT_GNU_IFUNC)
-            htab->elf.srelgot->size += sizeof (ElfNN_External_Rela);
-        }
+	{
+	  s->size += GOT_ENTRY_SIZE;
+	  if ((WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, bfd_link_pic (info), h)
+		&& !UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))
+	      || h->type == STT_GNU_IFUNC)
+	    htab->elf.srelgot->size += sizeof (ElfNN_External_Rela);
+	}
     }
   else
     h->got.offset = MINUS_ONE;
@@ -1098,26 +1098,25 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
       struct elf_dyn_relocs **pp;
 
       for (pp = &eh->dyn_relocs; (p = *pp) != NULL;)
-        {
-          p->count -= p->pc_count;
-          p->pc_count = 0;
-          if (p->count == 0)
-            *pp = p->next;
-          else
-            pp = &p->next;
-        }
+	{
+	  p->count -= p->pc_count;
+	  p->pc_count = 0;
+	  if (p->count == 0)
+	    *pp = p->next;
+	  else
+	    pp = &p->next;
+	}
     }
 
   if (h->root.type == bfd_link_hash_undefweak)
     {
       if (UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))
-        eh->dyn_relocs = NULL;
-      else if (h->dynindx == -1 &&
-               !h->forced_local
-               /* Make sure this symbol is output as a dynamic symbol.
-                  Undefined weak syms won't yet be marked as dynamic.  */
-               && !bfd_elf_link_record_dynamic_symbol (info, h))
-        return false;
+	eh->dyn_relocs = NULL;
+      else if (h->dynindx == -1 && !h->forced_local
+	/* Make sure this symbol is output as a dynamic symbol.
+	   Undefined weak syms won't yet be marked as dynamic.  */
+	       && !bfd_elf_link_record_dynamic_symbol (info, h))
+	return false;
     }
 
   for (p = eh->dyn_relocs; p != NULL; p = p->next)
@@ -1134,8 +1133,8 @@ elfNN_loongarch_allocate_local_dynrelocs (void **slot, void *inf)
 {
   struct elf_link_hash_entry *h = (struct elf_link_hash_entry *) *slot;
 
-  if (!h->def_regular || !h->ref_regular || !h->forced_local ||
-      h->root.type != bfd_link_hash_defined)
+  if (!h->def_regular || !h->ref_regular || !h->forced_local
+      || h->root.type != bfd_link_hash_defined)
     abort ();
 
   return allocate_dynrelocs (h, inf);
@@ -1159,8 +1158,8 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
       info->flags |= DF_TEXTREL;
       info->callbacks->minfo (_ ("%pB: dynamic relocation against `%pT' in "
-                                 "read-only section `%pA'\n"),
-                              sec->owner, h->root.root.string, sec);
+				 "read-only section `%pA'\n"),
+			      sec->owner, h->root.root.string, sec);
 
       /* Not an error, just cut short the traversal.  */
       return false;
@@ -1170,7 +1169,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
 
 static bool
 loongarch_elf_size_dynamic_sections (bfd *output_bfd,
-                                     struct bfd_link_info *info)
+				     struct bfd_link_info *info)
 {
   struct loongarch_elf_link_hash_table *htab;
   bfd *dynobj;
@@ -1186,20 +1185,20 @@ loongarch_elf_size_dynamic_sections (bfd *output_bfd,
     {
       /* Set the contents of the .interp section to the interpreter.  */
       if (bfd_link_executable (info) && !info->nointerp)
-        {
-          const char *interpreter;
-          flagword flags = elf_elfheader (output_bfd)->e_flags;
-          s = bfd_get_linker_section (dynobj, ".interp");
-          BFD_ASSERT (s != NULL);
-          if ((flags & EF_LARCH_ABI) == EF_LARCH_ABI_LP32)
-            interpreter = "/lib32/ld.so.1";
-          else if ((flags & EF_LARCH_ABI) == EF_LARCH_ABI_LP64)
-            interpreter = "/lib64/ld.so.1";
-          else
-            interpreter = "/lib/ld.so.1";
-          s->contents = (unsigned char *) interpreter;
-          s->size = strlen (interpreter) + 1;
-        }
+	{
+	  const char *interpreter;
+	  flagword flags = elf_elfheader (output_bfd)->e_flags;
+	  s = bfd_get_linker_section (dynobj, ".interp");
+	  BFD_ASSERT (s != NULL);
+	  if ((flags & EF_LARCH_ABI) == EF_LARCH_ABI_LP32)
+	    interpreter = "/lib32/ld.so.1";
+	  else if ((flags & EF_LARCH_ABI) == EF_LARCH_ABI_LP64)
+	    interpreter = "/lib64/ld.so.1";
+	  else
+	    interpreter = "/lib/ld.so.1";
+	  s->contents = (unsigned char *) interpreter;
+	  s->size = strlen (interpreter) + 1;
+	}
     }
 
   /* Set up .got offsets for local syms, and space for local dynamic
@@ -1214,36 +1213,36 @@ loongarch_elf_size_dynamic_sections (bfd *output_bfd,
       asection *srel;
 
       if (!is_loongarch_elf (ibfd))
-        continue;
+	continue;
 
       for (s = ibfd->sections; s != NULL; s = s->next)
-        {
-          struct elf_dyn_relocs *p;
-
-          for (p = elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
-            {
-              p->count -= p->pc_count;
-              if (!bfd_is_abs_section (p->sec) &&
-                  bfd_is_abs_section (p->sec->output_section))
-                {
-                  /* Input section has been discarded, either because
-                     it is a copy of a linkonce section or due to
-                     linker script /DISCARD/, so we'll be discarding
-                     the relocs too.  */
-                }
-              else if (0 < p->count)
-                {
-                  srel = elf_section_data (p->sec)->sreloc;
-                  srel->size += p->count * sizeof (ElfNN_External_Rela);
-                  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
-                    info->flags |= DF_TEXTREL;
-                }
-            }
-        }
+	{
+	  struct elf_dyn_relocs *p;
+
+	  for (p = elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
+	    {
+	      p->count -= p->pc_count;
+	      if (!bfd_is_abs_section (p->sec)
+		  && bfd_is_abs_section (p->sec->output_section))
+		{
+		  /* Input section has been discarded, either because
+		     it is a copy of a linkonce section or due to
+		     linker script /DISCARD/, so we'll be discarding
+		     the relocs too.  */
+		}
+	      else if (0 < p->count)
+		{
+		  srel = elf_section_data (p->sec)->sreloc;
+		  srel->size += p->count * sizeof (ElfNN_External_Rela);
+		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
+		    info->flags |= DF_TEXTREL;
+		}
+	    }
+	}
 
       local_got = elf_local_got_refcounts (ibfd);
       if (!local_got)
-        continue;
+	continue;
 
       symtab_hdr = &elf_symtab_hdr (ibfd);
       locsymcount = symtab_hdr->sh_info;
@@ -1252,24 +1251,24 @@ loongarch_elf_size_dynamic_sections (bfd *output_bfd,
       s = htab->elf.sgot;
       srel = htab->elf.srelgot;
       for (; local_got < end_local_got; ++local_got, ++local_tls_type)
-        {
-          if (0 < *local_got)
-            {
-              *local_got = s->size;
-              s->size += GOT_ENTRY_SIZE;
-
-              if (*local_tls_type & GOT_TLS_GD)
-                s->size += GOT_ENTRY_SIZE;
-
-              if (bfd_link_pic (info) /* R_LARCH_RELATIVE */
-                  ||
-                  (*local_tls_type & (GOT_TLS_GD /* R_LARCH_TLS_DTPRELNN */
-                                      | GOT_TLS_IE /* R_LARCH_TLS_TPRELNN */)))
-                srel->size += sizeof (ElfNN_External_Rela);
-            }
-          else
-            *local_got = MINUS_ONE;
-        }
+	{
+	  if (0 < *local_got)
+	    {
+	      *local_got = s->size;
+	      s->size += GOT_ENTRY_SIZE;
+
+	      if (*local_tls_type & GOT_TLS_GD)
+		s->size += GOT_ENTRY_SIZE;
+
+		/* If R_LARCH_RELATIVE.  */
+	      if (bfd_link_pic (info)
+		  /* Or R_LARCH_TLS_DTPRELNN or R_LARCH_TLS_TPRELNN.  */
+		  || (*local_tls_type & (GOT_TLS_GD | GOT_TLS_IE)))
+		srel->size += sizeof (ElfNN_External_Rela);
+	    }
+	  else
+	    *local_got = MINUS_ONE;
+	}
     }
 
   /* Allocate global sym .plt and .got entries, and space for global
@@ -1277,11 +1276,11 @@ loongarch_elf_size_dynamic_sections (bfd *output_bfd,
   elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);
   /* Allocate .plt and .got entries, and space for local ifunc symbols.  */
   htab_traverse (htab->loc_hash_table,
-                 (void *) elfNN_loongarch_allocate_local_dynrelocs, info);
+		 (void *) elfNN_loongarch_allocate_local_dynrelocs, info);
 
   /* Don't allocate .got.plt section if there are no PLT.  */
-  if (htab->elf.sgotplt && htab->elf.sgotplt->size == GOTPLT_HEADER_SIZE &&
-      (htab->elf.splt == NULL || htab->elf.splt->size == 0))
+  if (htab->elf.sgotplt && htab->elf.sgotplt->size == GOTPLT_HEADER_SIZE
+      && (htab->elf.splt == NULL || htab->elf.splt->size == 0))
     htab->elf.sgotplt->size = 0;
 
   /* The check_relocs and adjust_dynamic_symbol entry points have
@@ -1290,100 +1289,100 @@ loongarch_elf_size_dynamic_sections (bfd *output_bfd,
   for (s = dynobj->sections; s != NULL; s = s->next)
     {
       if ((s->flags & SEC_LINKER_CREATED) == 0)
-        continue;
-
-      if (s == htab->elf.splt || s == htab->elf.iplt || s == htab->elf.sgot ||
-          s == htab->elf.sgotplt || s == htab->elf.igotplt ||
-          s == htab->elf.sdynbss || s == htab->elf.sdynrelro)
-        {
-          /* Strip this section if we don't need it; see the
-             comment below.  */
-        }
+	continue;
+
+      if (s == htab->elf.splt || s == htab->elf.iplt || s == htab->elf.sgot
+	  || s == htab->elf.sgotplt || s == htab->elf.igotplt
+	  || s == htab->elf.sdynbss || s == htab->elf.sdynrelro)
+	{
+	  /* Strip this section if we don't need it; see the
+	     comment below.  */
+	}
       else if (strncmp (s->name, ".rela", 5) == 0)
-        {
-          if (s->size != 0)
-            {
-              /* We use the reloc_count field as a counter if we need
-                 to copy relocs into the output file.  */
-              s->reloc_count = 0;
-            }
-        }
+	{
+	  if (s->size != 0)
+	    {
+	      /* We use the reloc_count field as a counter if we need
+		 to copy relocs into the output file.  */
+	      s->reloc_count = 0;
+	    }
+	}
       else
-        {
-          /* It's not one of our sections.  */
-          continue;
-        }
+	{
+	  /* It's not one of our sections.  */
+	  continue;
+	}
 
       if (s->size == 0)
-        {
-          /* If we don't need this section, strip it from the
-             output file.  This is mostly to handle .rela.bss and
-             .rela.plt.  We must create both sections in
-             create_dynamic_sections, because they must be created
-             before the linker maps input sections to output
-             sections.  The linker does that before
-             adjust_dynamic_symbol is called, and it is that
-             function which decides whether anything needs to go
-             into these sections.  */
-          s->flags |= SEC_EXCLUDE;
-          continue;
-        }
+	{
+	  /* If we don't need this section, strip it from the
+	     output file.  This is mostly to handle .rela.bss and
+	     .rela.plt.  We must create both sections in
+	     create_dynamic_sections, because they must be created
+	     before the linker maps input sections to output
+	     sections.  The linker does that before
+	     adjust_dynamic_symbol is called, and it is that
+	     function which decides whether anything needs to go
+	     into these sections.  */
+	  s->flags |= SEC_EXCLUDE;
+	  continue;
+	}
 
       if ((s->flags & SEC_HAS_CONTENTS) == 0)
-        continue;
+	continue;
 
       /* Allocate memory for the section contents.  Zero the memory
-         for the benefit of .rela.plt, which has 4 unused entries
-         at the beginning, and we don't want garbage.  */
+	 for the benefit of .rela.plt, which has 4 unused entries
+	 at the beginning, and we don't want garbage.  */
       s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
       if (s->contents == NULL)
-        return false;
+	return false;
     }
 
   if (elf_hash_table (info)->dynamic_sections_created)
     {
       /* Add some entries to the .dynamic section.  We fill in the
-         values later, in loongarch_elf_finish_dynamic_sections, but we
-         must add the entries now so that we get the correct size for
-         the .dynamic section.  The DT_DEBUG entry is filled in by the
-         dynamic linker and used by the debugger.  */
+	 values later, in loongarch_elf_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
 #define add_dynamic_entry(TAG, VAL) _bfd_elf_add_dynamic_entry (info, TAG, VAL)
 
       if (bfd_link_executable (info))
-        {
-          if (!add_dynamic_entry (DT_DEBUG, 0))
-            return false;
-        }
+	{
+	  if (!add_dynamic_entry (DT_DEBUG, 0))
+	    return false;
+	}
 
       if (htab->elf.srelplt->size != 0)
-        {
-          if (!add_dynamic_entry (DT_PLTGOT, 0) ||
-              !add_dynamic_entry (DT_PLTRELSZ, 0) ||
-              !add_dynamic_entry (DT_PLTREL, DT_RELA) ||
-              !add_dynamic_entry (DT_JMPREL, 0))
-            return false;
-        }
-
-      if (!add_dynamic_entry (DT_RELA, 0) ||
-          !add_dynamic_entry (DT_RELASZ, 0) ||
-          !add_dynamic_entry (DT_RELAENT, sizeof (ElfNN_External_Rela)))
-        return false;
+	{
+	  if (!add_dynamic_entry (DT_PLTGOT, 0)
+	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
+	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
+	      || !add_dynamic_entry (DT_JMPREL, 0))
+	    return false;
+	}
+
+      if (!add_dynamic_entry (DT_RELA, 0)
+	  || !add_dynamic_entry (DT_RELASZ, 0)
+	  || !add_dynamic_entry (DT_RELAENT, sizeof (ElfNN_External_Rela)))
+	return false;
 
       /* If any dynamic relocs apply to a read-only section,
-         then we need a DT_TEXTREL entry.  */
+	 then we need a DT_TEXTREL entry.  */
       if ((info->flags & DF_TEXTREL) == 0)
-        elf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);
+	elf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);
 
       if (info->flags & DF_TEXTREL)
-        {
-          if (!add_dynamic_entry (DT_TEXTREL, 0))
-            return false;
-          /* Clear the DF_TEXTREL flag.  It will be set again if we
-             write out an actual text relocation; we may not, because
-             at this point we do not know whether e.g. any .eh_frame
-             absolute relocations have been converted to PC-relative.  */
-          info->flags &= ~DF_TEXTREL;
-        }
+	{
+	  if (!add_dynamic_entry (DT_TEXTREL, 0))
+	    return false;
+	  /* Clear the DF_TEXTREL flag.  It will be set again if we
+	     write out an actual text relocation; we may not, because
+	     at this point we do not know whether e.g.  any .eh_frame
+	     absolute relocations have been converted to PC-relative.  */
+	  info->flags &= ~DF_TEXTREL;
+	}
     }
 #undef add_dynamic_entry
 
@@ -1438,7 +1437,7 @@ loongarch_elf_append_rela (bfd *abfd, asection *s, Elf_Internal_Rela *rel)
 
 static bfd_reloc_status_type
 perform_relocation (const Elf_Internal_Rela *rel, bfd_vma value,
-                    bfd *input_bfd, bfd_byte *contents)
+		    bfd *input_bfd, bfd_byte *contents)
 {
 
   uint32_t insn1;
@@ -1458,91 +1457,91 @@ perform_relocation (const Elf_Internal_Rela *rel, bfd_vma value,
 
     case R_LARCH_SOP_PUSH_DUP:
       r = bfd_reloc_outofrange;
-      if (loongarch_pop (&opr1) != bfd_reloc_ok ||
-          loongarch_push (opr1) != bfd_reloc_ok ||
-          loongarch_push (opr1) != bfd_reloc_ok)
-        break;
+      if (loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1) != bfd_reloc_ok)
+	break;
       r = bfd_reloc_ok;
       break;
 
     case R_LARCH_SOP_ASSERT:
       r = loongarch_pop (&opr1);
       if (r != bfd_reloc_ok || opr1 == false)
-        r = bfd_reloc_notsupported;
+	r = bfd_reloc_notsupported;
       break;
 
     case R_LARCH_SOP_NOT:
       r = bfd_reloc_outofrange;
-      if (loongarch_pop (&opr1) != bfd_reloc_ok ||
-          loongarch_push (!opr1) != bfd_reloc_ok)
-        break;
+      if (loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (!opr1) != bfd_reloc_ok)
+	break;
       r = bfd_reloc_ok;
       break;
 
     case R_LARCH_SOP_SUB:
       r = bfd_reloc_outofrange;
-      if (loongarch_pop (&opr2) != bfd_reloc_ok ||
-          loongarch_pop (&opr1) != bfd_reloc_ok ||
-          loongarch_push (opr1 - opr2) != bfd_reloc_ok)
-        break;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok
+	  || loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1 - opr2) != bfd_reloc_ok)
+	break;
       r = bfd_reloc_ok;
       break;
 
     case R_LARCH_SOP_SL:
       r = bfd_reloc_outofrange;
-      if (loongarch_pop (&opr2) != bfd_reloc_ok ||
-          loongarch_pop (&opr1) != bfd_reloc_ok ||
-          loongarch_push (opr1 << opr2) != bfd_reloc_ok)
-        break;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok
+	  || loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1 << opr2) != bfd_reloc_ok)
+	break;
       r = bfd_reloc_ok;
       break;
 
     case R_LARCH_SOP_SR:
       r = bfd_reloc_outofrange;
-      if (loongarch_pop (&opr2) != bfd_reloc_ok ||
-          loongarch_pop (&opr1) != bfd_reloc_ok ||
-          loongarch_push (opr1 >> opr2) != bfd_reloc_ok)
-        break;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok
+	  || loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1 >> opr2) != bfd_reloc_ok)
+	break;
       r = bfd_reloc_ok;
       break;
 
     case R_LARCH_SOP_AND:
       r = bfd_reloc_outofrange;
-      if (loongarch_pop (&opr2) != bfd_reloc_ok ||
-          loongarch_pop (&opr1) != bfd_reloc_ok ||
-          loongarch_push (opr1 & opr2) != bfd_reloc_ok)
-        break;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok
+	  || loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1 & opr2) != bfd_reloc_ok)
+	break;
       r = bfd_reloc_ok;
       break;
 
     case R_LARCH_SOP_ADD:
       r = bfd_reloc_outofrange;
-      if (loongarch_pop (&opr2) != bfd_reloc_ok ||
-          loongarch_pop (&opr1) != bfd_reloc_ok ||
-          loongarch_push (opr1 + opr2) != bfd_reloc_ok)
-        break;
+      if (loongarch_pop (&opr2) != bfd_reloc_ok
+	  || loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1 + opr2) != bfd_reloc_ok)
+	break;
       r = bfd_reloc_ok;
       break;
 
     case R_LARCH_SOP_IF_ELSE:
       r = bfd_reloc_outofrange;
-      if (loongarch_pop (&opr3) != bfd_reloc_ok ||
-          loongarch_pop (&opr2) != bfd_reloc_ok ||
-          loongarch_pop (&opr1) != bfd_reloc_ok ||
-          loongarch_push (opr1 ? opr2 : opr3) != bfd_reloc_ok)
-        break;
+      if (loongarch_pop (&opr3) != bfd_reloc_ok
+	  || loongarch_pop (&opr2) != bfd_reloc_ok
+	  || loongarch_pop (&opr1) != bfd_reloc_ok
+	  || loongarch_push (opr1 ? opr2 : opr3) != bfd_reloc_ok)
+	break;
       r = bfd_reloc_ok;
       break;
 
     case R_LARCH_SOP_POP_32_S_10_5:
       r = loongarch_pop (&opr1);
       if (r != bfd_reloc_ok)
-        break;
-      if ((opr1 & ~(uint64_t) 0xf) != 0x0 &&
-          (opr1 & ~(uint64_t) 0xf) != ~(uint64_t) 0xf)
-        r = bfd_reloc_overflow;
+	break;
+      if ((opr1 & ~(uint64_t) 0xf) != 0x0
+	  && (opr1 & ~(uint64_t) 0xf) != ~(uint64_t) 0xf)
+	r = bfd_reloc_overflow;
       if (r != bfd_reloc_ok)
-        break;
+	break;
       insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
       insn1 = (insn1 & (~(uint32_t) 0x7c00)) | ((opr1 & 0x1f) << 10);
       bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
@@ -1551,11 +1550,11 @@ perform_relocation (const Elf_Internal_Rela *rel, bfd_vma value,
     case R_LARCH_SOP_POP_32_U_10_12:
       r = loongarch_pop (&opr1);
       if (r != bfd_reloc_ok)
-        break;
+	break;
       if (opr1 & ~(uint64_t) 0xfff)
-        r = bfd_reloc_overflow;
+	r = bfd_reloc_overflow;
       if (r != bfd_reloc_ok)
-        break;
+	break;
       insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
       insn1 = (insn1 & (~(uint32_t) 0x3ffc00)) | ((opr1 & 0xfff) << 10);
       bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
@@ -1564,12 +1563,12 @@ perform_relocation (const Elf_Internal_Rela *rel, bfd_vma value,
     case R_LARCH_SOP_POP_32_S_10_12:
       r = loongarch_pop (&opr1);
       if (r != bfd_reloc_ok)
-        break;
-      if ((opr1 & ~(uint64_t) 0x7ff) != 0x0 &&
-          (opr1 & ~(uint64_t) 0x7ff) != ~(uint64_t) 0x7ff)
-        r = bfd_reloc_overflow;
+	break;
+      if ((opr1 & ~(uint64_t) 0x7ff) != 0x0
+	  && (opr1 & ~(uint64_t) 0x7ff) != ~(uint64_t) 0x7ff)
+	r = bfd_reloc_overflow;
       if (r != bfd_reloc_ok)
-        break;
+	break;
       insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
       insn1 = (insn1 & (~(uint32_t) 0x3ffc00)) | ((opr1 & 0xfff) << 10);
       bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
@@ -1578,12 +1577,12 @@ perform_relocation (const Elf_Internal_Rela *rel, bfd_vma value,
     case R_LARCH_SOP_POP_32_S_10_16:
       r = loongarch_pop (&opr1);
       if (r != bfd_reloc_ok)
-        break;
-      if ((opr1 & ~(uint64_t) 0x7fff) != 0x0 &&
-          (opr1 & ~(uint64_t) 0x7fff) != ~(uint64_t) 0x7fff)
-        r = bfd_reloc_overflow;
+	break;
+      if ((opr1 & ~(uint64_t) 0x7fff) != 0x0
+	  && (opr1 & ~(uint64_t) 0x7fff) != ~(uint64_t) 0x7fff)
+	r = bfd_reloc_overflow;
       if (r != bfd_reloc_ok)
-        break;
+	break;
       insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
       insn1 = (insn1 & 0xfc0003ff) | ((opr1 & 0xffff) << 10);
       bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
@@ -1592,15 +1591,15 @@ perform_relocation (const Elf_Internal_Rela *rel, bfd_vma value,
     case R_LARCH_SOP_POP_32_S_10_16_S2:
       r = loongarch_pop (&opr1);
       if (r != bfd_reloc_ok)
-        break;
+	break;
       if ((opr1 & 0x3) != 0)
-        r = bfd_reloc_overflow;
+	r = bfd_reloc_overflow;
       opr1 >>= 2;
-      if ((opr1 & ~(uint64_t) 0x7fff) != 0x0 &&
-          (opr1 & ~(uint64_t) 0x7fff) != ~(uint64_t) 0x7fff)
-        r = bfd_reloc_overflow;
+      if ((opr1 & ~(uint64_t) 0x7fff) != 0x0
+	  && (opr1 & ~(uint64_t) 0x7fff) != ~(uint64_t) 0x7fff)
+	r = bfd_reloc_overflow;
       if (r != bfd_reloc_ok)
-        break;
+	break;
       insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
       insn1 = (insn1 & 0xfc0003ff) | ((opr1 & 0xffff) << 10);
       bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
@@ -1609,30 +1608,31 @@ perform_relocation (const Elf_Internal_Rela *rel, bfd_vma value,
     case R_LARCH_SOP_POP_32_S_0_5_10_16_S2:
       r = loongarch_pop (&opr1);
       if (r != bfd_reloc_ok)
-        break;
+	break;
       if ((opr1 & 0x3) != 0)
-        r = bfd_reloc_overflow;
+	r = bfd_reloc_overflow;
       opr1 >>= 2;
-      if ((opr1 & ~(uint64_t) 0xfffff) != 0x0 &&
-          (opr1 & ~(uint64_t) 0xfffff) != ~(uint64_t) 0xfffff)
-        r = bfd_reloc_overflow;
+      if ((opr1 & ~(uint64_t) 0xfffff) != 0x0
+	  && (opr1 & ~(uint64_t) 0xfffff) != ~(uint64_t) 0xfffff)
+	r = bfd_reloc_overflow;
       if (r != bfd_reloc_ok)
-        break;
+	break;
       insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
-      insn1 = (insn1 & 0xfc0003e0) | ((opr1 & 0xffff) << 10) |
-              ((opr1 & 0x1f0000) >> 16);
+      insn1 = (insn1 & 0xfc0003e0)
+	      | ((opr1 & 0xffff) << 10)
+	      | ((opr1 & 0x1f0000) >> 16);
       bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
       break;
 
     case R_LARCH_SOP_POP_32_S_5_20:
       r = loongarch_pop (&opr1);
       if (r != bfd_reloc_ok)
-        break;
-      if ((opr1 & ~(uint64_t) 0x7ffff) != 0x0 &&
-          (opr1 & ~(uint64_t) 0x7ffff) != ~(uint64_t) 0x7ffff)
-        r = bfd_reloc_overflow;
+	break;
+      if ((opr1 & ~(uint64_t) 0x7ffff) != 0x0
+	  && (opr1 & ~(uint64_t) 0x7ffff) != ~(uint64_t) 0x7ffff)
+	r = bfd_reloc_overflow;
       if (r != bfd_reloc_ok)
-        break;
+	break;
       insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
       insn1 = (insn1 & (~(uint32_t) 0x1ffffe0)) | ((opr1 & 0xfffff) << 5);
       bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
@@ -1641,29 +1641,30 @@ perform_relocation (const Elf_Internal_Rela *rel, bfd_vma value,
     case R_LARCH_SOP_POP_32_S_0_10_10_16_S2:
       r = loongarch_pop (&opr1);
       if (r != bfd_reloc_ok)
-        break;
+	break;
       if ((opr1 & 0x3) != 0)
-        r = bfd_reloc_overflow;
+	r = bfd_reloc_overflow;
       opr1 >>= 2;
-      if ((opr1 & ~(uint64_t) 0x1ffffff) != 0x0 &&
-          (opr1 & ~(uint64_t) 0x1ffffff) != ~(uint64_t) 0x1ffffff)
-        r = bfd_reloc_overflow;
+      if ((opr1 & ~(uint64_t) 0x1ffffff) != 0x0
+	  && (opr1 & ~(uint64_t) 0x1ffffff) != ~(uint64_t) 0x1ffffff)
+	r = bfd_reloc_overflow;
       if (r != bfd_reloc_ok)
-        break;
+	break;
       insn1 = bfd_get (32, input_bfd, contents + rel->r_offset);
-      insn1 = (insn1 & 0xfc000000) | ((opr1 & 0xffff) << 10) |
-              ((opr1 & 0x3ff0000) >> 16);
+      insn1 = (insn1 & 0xfc000000)
+	      | ((opr1 & 0xffff) << 10)
+	      | ((opr1 & 0x3ff0000) >> 16);
       bfd_put (32, input_bfd, insn1, contents + rel->r_offset);
       break;
 
     case R_LARCH_SOP_POP_32_U:
       r = loongarch_pop (&opr1);
       if (r != bfd_reloc_ok)
-        break;
+	break;
       if (opr1 & ~(uint64_t) 0xffffffff)
-        r = bfd_reloc_overflow;
+	r = bfd_reloc_overflow;
       if (r != bfd_reloc_ok)
-        break;
+	break;
       bfd_put (32, input_bfd, opr1, contents + rel->r_offset);
       break;
 
@@ -1740,7 +1741,7 @@ static size_t larch_reloc_queue_tail = 0;
 
 static const char *
 loongarch_sym_name (bfd *input_bfd, struct elf_link_hash_entry *h,
-                    Elf_Internal_Sym *sym)
+		    Elf_Internal_Sym *sym)
 {
   const char *ret = NULL;
   if (sym)
@@ -1756,12 +1757,12 @@ loongarch_sym_name (bfd *input_bfd, struct elf_link_hash_entry *h,
 
 static void
 loongarch_record_one_reloc (bfd *abfd, asection *section, int r_type,
-                            bfd_vma r_offset, Elf_Internal_Sym *sym,
-                            struct elf_link_hash_entry *h, bfd_vma addend)
+			    bfd_vma r_offset, Elf_Internal_Sym *sym,
+			    struct elf_link_hash_entry *h, bfd_vma addend)
 {
-  if ((larch_reloc_queue_head == 0 &&
-       larch_reloc_queue_tail == LARCH_RECENT_RELOC_QUEUE_LENGTH - 1) ||
-      (larch_reloc_queue_head == larch_reloc_queue_tail + 1))
+  if ((larch_reloc_queue_head == 0
+      && larch_reloc_queue_tail == LARCH_RECENT_RELOC_QUEUE_LENGTH - 1)
+      || (larch_reloc_queue_head == larch_reloc_queue_tail + 1))
     larch_reloc_queue_head =
       (larch_reloc_queue_head + 1) % LARCH_RECENT_RELOC_QUEUE_LENGTH;
   larch_reloc_queue[larch_reloc_queue_tail].bfd = abfd;
@@ -1788,32 +1789,32 @@ loongarch_dump_reloc_record (void (*p) (const char *fmt, ...))
   p ("stack top\t\trelocation name\t\tsymbol");
   while (i != larch_reloc_queue_tail)
     {
-      if (a_bfd != larch_reloc_queue[i].bfd ||
-          section != larch_reloc_queue[i].section ||
-          r_offset != larch_reloc_queue[i].r_offset)
-        {
-          a_bfd = larch_reloc_queue[i].bfd;
-          section = larch_reloc_queue[i].section;
-          r_offset = larch_reloc_queue[i].r_offset;
-          p ("\nat %pB(%pA+0x%v):\n", larch_reloc_queue[i].bfd,
-             larch_reloc_queue[i].section, larch_reloc_queue[i].r_offset);
-        }
+      if (a_bfd != larch_reloc_queue[i].bfd
+	  || section != larch_reloc_queue[i].section
+	  || r_offset != larch_reloc_queue[i].r_offset)
+	{
+	  a_bfd = larch_reloc_queue[i].bfd;
+	  section = larch_reloc_queue[i].section;
+	  r_offset = larch_reloc_queue[i].r_offset;
+	  p ("\nat %pB(%pA+0x%v):\n", larch_reloc_queue[i].bfd,
+	     larch_reloc_queue[i].section, larch_reloc_queue[i].r_offset);
+	}
 
       if (!inited)
-        inited = 1, p ("...\n");
+	inited = 1, p ("...\n");
 
       reloc_howto_type *howto =
-        loongarch_elf_rtype_to_howto (larch_reloc_queue[i].r_type);
+	loongarch_elf_rtype_to_howto (larch_reloc_queue[i].r_type);
       p ("0x%V %s\t`%s'", (bfd_vma) larch_reloc_queue[i].top_then,
-         howto ? howto->name : "<unknown reloc>",
-         loongarch_sym_name (larch_reloc_queue[i].bfd, larch_reloc_queue[i].h,
-                             larch_reloc_queue[i].sym));
+	 howto ? howto->name : "<unknown reloc>",
+	 loongarch_sym_name (larch_reloc_queue[i].bfd, larch_reloc_queue[i].h,
+			     larch_reloc_queue[i].sym));
 
       long addend = larch_reloc_queue[i].addend;
       if (addend < 0)
-        p (" - %ld", -addend);
+	p (" - %ld", -addend);
       else if (0 < addend)
-        p (" + %ld(0x%v)", addend, larch_reloc_queue[i].addend);
+	p (" + %ld(0x%v)", addend, larch_reloc_queue[i].addend);
 
       p ("\n");
       i = (i + 1) % LARCH_RECENT_RELOC_QUEUE_LENGTH;
@@ -1824,10 +1825,10 @@ loongarch_dump_reloc_record (void (*p) (const char *fmt, ...))
 
 static int
 loongarch_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
-                                bfd *input_bfd, asection *input_section,
-                                bfd_byte *contents, Elf_Internal_Rela *relocs,
-                                Elf_Internal_Sym *local_syms,
-                                asection **local_sections)
+				bfd *input_bfd, asection *input_section,
+				bfd_byte *contents, Elf_Internal_Rela *relocs,
+				Elf_Internal_Sym *local_syms,
+				asection **local_sections)
 {
   Elf_Internal_Rela *rel;
   Elf_Internal_Rela *relend;
@@ -1861,121 +1862,121 @@ loongarch_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
       bfd_vma off, ie_off;
       int i, j;
 
-      if (howto == NULL || r_type == R_LARCH_GNU_VTINHERIT ||
-          r_type == R_LARCH_GNU_VTENTRY)
-        continue;
+      if (howto == NULL || r_type == R_LARCH_GNU_VTINHERIT
+	  || r_type == R_LARCH_GNU_VTENTRY)
+	continue;
 
       /* This is a final link.  */
       if (r_symndx < symtab_hdr->sh_info)
-        {
-          is_undefweak = false;
-          unresolved_reloc = false;
-          sym = local_syms + r_symndx;
-          sec = local_sections[r_symndx];
-          relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
-
-          /* Relocate against local STT_GNU_IFUNC symbol.  */
-          if (!bfd_link_relocatable (info) &&
-              ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
-            {
-              h = elfNN_loongarch_get_local_sym_hash (htab, input_bfd, rel,
-                                                      false);
-              if (h == NULL)
-                abort ();
-
-              /* Set STT_GNU_IFUNC symbol value.  */
-              h->root.u.def.value = sym->st_value;
-              h->root.u.def.section = sec;
-            }
-          defined_local = true;
-          resolved_local = true;
-          resolved_dynly = false;
-          resolved_to_const = false;
-          if (bfd_link_relocatable (info) &&
-              ELF_ST_TYPE (sym->st_info) == STT_SECTION)
-            {
-              rel->r_addend += sec->output_offset;
-            }
-        }
+	{
+	  is_undefweak = false;
+	  unresolved_reloc = false;
+	  sym = local_syms + r_symndx;
+	  sec = local_sections[r_symndx];
+	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
+
+	  /* Relocate against local STT_GNU_IFUNC symbol.  */
+	  if (!bfd_link_relocatable (info)
+	      && ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
+	    {
+	      h = elfNN_loongarch_get_local_sym_hash (htab, input_bfd, rel,
+						      false);
+	      if (h == NULL)
+		abort ();
+
+	      /* Set STT_GNU_IFUNC symbol value.  */
+	      h->root.u.def.value = sym->st_value;
+	      h->root.u.def.section = sec;
+	    }
+	  defined_local = true;
+	  resolved_local = true;
+	  resolved_dynly = false;
+	  resolved_to_const = false;
+	  if (bfd_link_relocatable (info)
+	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
+	    {
+	      rel->r_addend += sec->output_offset;
+	    }
+	}
       else
-        {
-          bool warned, ignored;
-
-          RELOC_FOR_GLOBAL_SYMBOL (
-            info, input_bfd, input_section, rel, r_symndx, symtab_hdr,
-            sym_hashes, h, sec, relocation, unresolved_reloc, warned, ignored);
-          /* Here means symbol isn't local symbol only and 'h != NULL'. */
-
-          /* The 'unresolved_syms_in_objects' specify how to deal with undefined
-             symbol. And 'dynamic_undefined_weak' specify what to do when
-             meeting undefweak.  */
-
-          if ((is_undefweak = h->root.type == bfd_link_hash_undefweak))
-            {
-              defined_local = false;
-              resolved_local = false;
-              resolved_to_const = !is_dyn || h->dynindx == -1 ||
-                                  UNDEFWEAK_NO_DYNAMIC_RELOC (info, h);
-              resolved_dynly = !resolved_local && !resolved_to_const;
-            }
-          else if (warned)
-            {
-              /* Symbol undefined offen means failed already. I don't know why
-                 'warned' here but I guess it want to continue relocating as if
-                 no error occures to find other errors as more as possible. */
-
-              /* To avoid generating warning messages about truncated
-                 relocations, set the relocation's address to be the same as
-                 the start of this section.  */
-              relocation = input_section->output_section
-                             ? input_section->output_section->vma
-                             : 0;
-
-              defined_local = relocation != 0;
-              resolved_local = defined_local;
-              resolved_to_const = !resolved_local;
-              resolved_dynly = false;
-            }
-          else
-            {
-              defined_local = !unresolved_reloc && !ignored;
-              resolved_local =
-                defined_local && SYMBOL_REFERENCES_LOCAL (info, h);
-              resolved_dynly = !resolved_local;
-              resolved_to_const = !resolved_local && !resolved_dynly;
-            }
-        }
+	{
+	  bool warned, ignored;
+
+	  RELOC_FOR_GLOBAL_SYMBOL (
+	    info, input_bfd, input_section, rel, r_symndx, symtab_hdr,
+	    sym_hashes, h, sec, relocation, unresolved_reloc, warned, ignored);
+	  /* Here means symbol isn't local symbol only and 'h != NULL'.  */
+
+	  /* The 'unresolved_syms_in_objects' specify how to deal with undefined
+	     symbol.  And 'dynamic_undefined_weak' specify what to do when
+	     meeting undefweak.  */
+
+	  if ((is_undefweak = h->root.type == bfd_link_hash_undefweak))
+	    {
+	      defined_local = false;
+	      resolved_local = false;
+	      resolved_to_const = !is_dyn || h->dynindx == -1
+				  || UNDEFWEAK_NO_DYNAMIC_RELOC (info, h);
+	      resolved_dynly = !resolved_local && !resolved_to_const;
+	    }
+	  else if (warned)
+	    {
+	      /* Symbol undefined offen means failed already.  I don't know why
+		 'warned' here but I guess it want to continue relocating as if
+		 no error occures to find other errors as more as possible.  */
+
+	      /* To avoid generating warning messages about truncated
+		 relocations, set the relocation's address to be the same as
+		 the start of this section.  */
+	      relocation = input_section->output_section
+			     ? input_section->output_section->vma
+			     : 0;
+
+	      defined_local = relocation != 0;
+	      resolved_local = defined_local;
+	      resolved_to_const = !resolved_local;
+	      resolved_dynly = false;
+	    }
+	  else
+	    {
+	      defined_local = !unresolved_reloc && !ignored;
+	      resolved_local =
+		defined_local && SYMBOL_REFERENCES_LOCAL (info, h);
+	      resolved_dynly = !resolved_local;
+	      resolved_to_const = !resolved_local && !resolved_dynly;
+	    }
+	}
 
       name = loongarch_sym_name (input_bfd, h, sym);
 
       if (sec != NULL && discarded_section (sec))
-        RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section, rel,
-                                         1, relend, howto, 0, contents);
+	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section, rel,
+					 1, relend, howto, 0, contents);
 
       if (bfd_link_relocatable (info))
-        continue;
+	continue;
 
       /* The r_symndx will be STN_UNDEF (zero) only for relocs against symbols
-         from removed linkonce sections, or sections discarded by a linker
-         script. Also for R_*_SOP_PUSH_ABSOLUTE and PCREL to specify const.  */
+	 from removed linkonce sections, or sections discarded by a linker
+	 script.  Also for R_*_SOP_PUSH_ABSOLUTE and PCREL to specify const.  */
       if (r_symndx == STN_UNDEF || bfd_is_abs_section (sec))
-        resolved_dynly = resolved_local = defined_local = false,
-        resolved_to_const = true;
+	resolved_dynly = resolved_local = defined_local = false,
+	resolved_to_const = true;
 
       if (h && h->type == STT_GNU_IFUNC)
-        {
-          if (h->plt.offset == MINUS_ONE)
-            info->callbacks->info ("%X%pB(%pA+0x%v): error: %s against `%s':\n"
-                                   "STT_GNU_IFUNC must have PLT stub"
-                                   "\n",
-                                   input_bfd, input_section,
-                                   (bfd_vma) rel->r_offset, howto->name, name);
-          defined_local = true;
-          resolved_local = true;
-          resolved_dynly = false;
-          resolved_to_const = false;
-          relocation = sec_addr (plt) + h->plt.offset;
-        }
+	{
+	  if (h->plt.offset == MINUS_ONE)
+	    info->callbacks->info ("%X%pB(%pA+0x%v): error: %s against `%s':\n"
+				   "STT_GNU_IFUNC must have PLT stub"
+				   "\n",
+				   input_bfd, input_section,
+				   (bfd_vma) rel->r_offset, howto->name, name);
+	  defined_local = true;
+	  resolved_local = true;
+	  resolved_dynly = false;
+	  resolved_to_const = false;
+	  relocation = sec_addr (plt) + h->plt.offset;
+	}
 
       unresolved_reloc = resolved_dynly;
 
@@ -1987,539 +1988,539 @@ loongarch_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 
       is_ie = false;
       switch (r_type)
-        {
-#define LARCH_ASSERT(cond, bfd_fail_state, message)                           \
-  ({                                                                          \
-    if (!(cond))                                                              \
-      {                                                                       \
-        r = bfd_fail_state;                                                   \
-        switch (r)                                                            \
-          {                                                                   \
-          /* 'dangerous' means we do it but can't promise it's ok             \
-             'unsupport' means out of ability of relocation type              \
-             'undefined' means we can't deal with the undefined symbol  */    \
-          case bfd_reloc_undefined:                                           \
-            info->callbacks->undefined_symbol (                               \
-              info, name, input_bfd, input_section, rel->r_offset, true);     \
-            fatal = true;                                                     \
-            info->callbacks->info (                                           \
-              "%X%pB(%pA+0x%v): error: %s against %s`%s':\n" message "\n",    \
-              input_bfd, input_section, (bfd_vma) rel->r_offset, howto->name, \
-              is_undefweak ? "[undefweak] " : "", name);                      \
-            break;                                                            \
-          default:                                                            \
-            fatal = true;                                                     \
-            info->callbacks->info (                                           \
-              "%X%pB(%pA+0x%v): error: %s against %s`%s':\n" message "\n",    \
-              input_bfd, input_section, (bfd_vma) rel->r_offset, howto->name, \
-              is_undefweak ? "[undefweak] " : "", name);                      \
-            break;                                                            \
-          case bfd_reloc_dangerous:                                           \
-            info->callbacks->info (                                           \
-              "%pB(%pA+0x%v): warning: %s against %s`%s':\n" message "\n",    \
-              input_bfd, input_section, (bfd_vma) rel->r_offset, howto->name, \
-              is_undefweak ? "[undefweak] " : "", name);                      \
-            break;                                                            \
-          case bfd_reloc_ok:                                                  \
-          case bfd_reloc_continue:                                            \
-            info->callbacks->info (                                           \
-              "%pB(%pA+0x%v): message: %s against %s`%s':\n" message "\n",    \
-              input_bfd, input_section, (bfd_vma) rel->r_offset, howto->name, \
-              is_undefweak ? "[undefweak] " : "", name);                      \
-            break;                                                            \
-          }                                                                   \
-        if (fatal)                                                            \
-          break;                                                              \
-      }                                                                       \
+	{
+#define LARCH_ASSERT(cond, bfd_fail_state, message)			      \
+  ({									      \
+    if (!(cond))							      \
+      {									      \
+	r = bfd_fail_state;						      \
+	switch (r)							      \
+	  {								      \
+	  /* 'dangerous' means we do it but can't promise it's ok	      \
+       'unsupport' means out of ability of relocation type		      \
+       'undefined' means we can't deal with the undefined symbol.  */	      \
+	  case bfd_reloc_undefined:					      \
+	    info->callbacks->undefined_symbol (				      \
+	      info, name, input_bfd, input_section, rel->r_offset, true);     \
+	    fatal = true;						      \
+	    info->callbacks->info (					      \
+	      "%X%pB(%pA+0x%v): error: %s against %s`%s':\n" message "\n",    \
+	      input_bfd, input_section, (bfd_vma) rel->r_offset, howto->name, \
+	      is_undefweak ? "[undefweak] " : "", name);		      \
+	    break;							      \
+	  default:							      \
+	    fatal = true;						      \
+	    info->callbacks->info (					      \
+	      "%X%pB(%pA+0x%v): error: %s against %s`%s':\n" message "\n",    \
+	      input_bfd, input_section, (bfd_vma) rel->r_offset, howto->name, \
+	      is_undefweak ? "[undefweak] " : "", name);		      \
+	    break;							      \
+	  case bfd_reloc_dangerous:					      \
+	    info->callbacks->info (					      \
+	      "%pB(%pA+0x%v): warning: %s against %s`%s':\n" message "\n",    \
+	      input_bfd, input_section, (bfd_vma) rel->r_offset, howto->name, \
+	      is_undefweak ? "[undefweak] " : "", name);		      \
+	    break;							      \
+	  case bfd_reloc_ok:						      \
+	  case bfd_reloc_continue:					      \
+	    info->callbacks->info (					      \
+	      "%pB(%pA+0x%v): message: %s against %s`%s':\n" message "\n",    \
+	      input_bfd, input_section, (bfd_vma) rel->r_offset, howto->name, \
+	      is_undefweak ? "[undefweak] " : "", name);		      \
+	    break;							      \
+	  }								      \
+	if (fatal)							      \
+	  break;							      \
+      }								       	      \
   })
-        case R_LARCH_MARK_PCREL:
-        case R_LARCH_MARK_LA:
-        case R_LARCH_NONE:
-          r = bfd_reloc_continue;
-          unresolved_reloc = false;
-          break;
-
-        case R_LARCH_32:
-        case R_LARCH_64:
-          if (resolved_dynly || (is_pic && resolved_local))
-            {
-              Elf_Internal_Rela outrel;
-
-              /* When generating a shared object, these relocations are copied
-                 into the output file to be resolved at run time.  */
-
-              outrel.r_offset = _bfd_elf_section_offset (
-                output_bfd, info, input_section, rel->r_offset);
-
-              unresolved_reloc = !((bfd_vma) -2 <= outrel.r_offset) &&
-                                 (input_section->flags & SEC_ALLOC);
-
-              outrel.r_offset += sec_addr (input_section);
-              if (resolved_dynly)
-                {
-                  outrel.r_info = ELFNN_R_INFO (h->dynindx, r_type);
-                  outrel.r_addend = rel->r_addend;
-                }
-              else
-                {
-                  outrel.r_info = ELFNN_R_INFO (0, R_LARCH_RELATIVE);
-                  outrel.r_addend = relocation + rel->r_addend;
-                }
-
-              if (unresolved_reloc)
-                loongarch_elf_append_rela (output_bfd, sreloc, &outrel);
-            }
-
-          relocation += rel->r_addend;
-          break;
-
-        case R_LARCH_ADD8:
-        case R_LARCH_ADD16:
-        case R_LARCH_ADD24:
-        case R_LARCH_ADD32:
-        case R_LARCH_ADD64:
-        case R_LARCH_SUB8:
-        case R_LARCH_SUB16:
-        case R_LARCH_SUB24:
-        case R_LARCH_SUB32:
-        case R_LARCH_SUB64:
-          LARCH_ASSERT (
-            !resolved_dynly, bfd_reloc_undefined,
-            "Can't be resolved dynamically. If this procedure is hand-writing "
-            "assemble,\n"
-            "there must be something like '.dword sym1 - sym2' to generate "
-            "these relocs\n"
-            "and we can't get known link-time address of these symbols.");
-          relocation += rel->r_addend;
-          break;
-
-        case R_LARCH_TLS_DTPREL32:
-        case R_LARCH_TLS_DTPREL64:
-          if (resolved_dynly)
-            {
-              Elf_Internal_Rela outrel;
-
-              outrel.r_offset = _bfd_elf_section_offset (
-                output_bfd, info, input_section, rel->r_offset);
-
-              unresolved_reloc = !((bfd_vma) -2 <= outrel.r_offset) &&
-                                 (input_section->flags & SEC_ALLOC);
-              outrel.r_info = ELFNN_R_INFO (h->dynindx, r_type);
-              outrel.r_offset += sec_addr (input_section);
-              outrel.r_addend = rel->r_addend;
-              if (unresolved_reloc)
-                loongarch_elf_append_rela (output_bfd, sreloc, &outrel);
-              break;
-            }
-
-          LARCH_ASSERT (!resolved_to_const, bfd_reloc_notsupported,
-                        "Internal:");
-          break;
-        case R_LARCH_SOP_PUSH_TLS_TPREL:
-          if (resolved_local)
-            {
-              LARCH_ASSERT (elf_hash_table (info)->tls_sec,
-                            bfd_reloc_notsupported,
-                            "TLS section not be created");
-              relocation -= elf_hash_table (info)->tls_sec->vma;
-            }
-
-          LARCH_ASSERT (resolved_local, bfd_reloc_undefined,
-                        "TLS LE just can be resolved local only.");
-          break;
-
-        case R_LARCH_SOP_PUSH_ABSOLUTE:
-          if (is_undefweak)
-            {
-              LARCH_ASSERT (
-                !resolved_dynly, bfd_reloc_dangerous,
-                "Someone require us to resolve undefweak symbol dynamically.\n"
-                "But this reloc can't be done. I think I can't throw error "
-                "for this\n"
-                "so I resolved it to 0. I suggest to re-compile with "
-                "'-fpic'.");
-              relocation = 0;
-              unresolved_reloc = false;
-              break;
-            }
-
-          if (resolved_to_const)
-            {
-              relocation += rel->r_addend;
-              break;
-            }
-
-          LARCH_ASSERT (!is_pic, bfd_reloc_notsupported,
-                        "Under PIC we don't know load address. Re-compile src "
-                        "with '-fpic'?");
-
-          if (resolved_dynly)
-            {
-              LARCH_ASSERT (plt && h && h->plt.offset != MINUS_ONE,
-                            bfd_reloc_undefined,
-                            "Can't be resolved dynamically. Try to re-compile "
-                            "src with '-fpic'?");
-
-              LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
-                            "Shouldn't be with r_addend.");
-
-              relocation = sec_addr (plt) + h->plt.offset;
-              unresolved_reloc = false;
-              break;
-            }
-
-          if (resolved_local)
-            {
-              relocation += rel->r_addend;
-              break;
-            }
-
-          break;
-
-        case R_LARCH_SOP_PUSH_PCREL:
-        case R_LARCH_SOP_PUSH_PLT_PCREL:
-          unresolved_reloc = false;
-
-          if (resolved_to_const)
-            {
-              relocation += rel->r_addend;
-              break;
-            }
-          else if (is_undefweak)
-            {
-              i = 0, j = 0;
-              relocation = 0;
-              if (resolved_dynly)
-                {
-                  if (h && h->plt.offset != MINUS_ONE)
-                    i = 1, j = 2;
-                  else
-                    LARCH_ASSERT (0, bfd_reloc_dangerous,
-                                  "Undefweak need to be resolved dynamically, "
-                                  "but PLT stub doesn't represent.");
-                }
-            }
-          else
-            {
-              LARCH_ASSERT (
-                defined_local || (h && h->plt.offset != MINUS_ONE),
-                bfd_reloc_undefined,
-                "PLT stub does not represent and symbol not defined.");
-
-              if (resolved_local)
-                i = 0, j = 2;
-              else /* if (resolved_dynly) */
-                {
-                  LARCH_ASSERT (h && h->plt.offset != MINUS_ONE,
-                                bfd_reloc_dangerous,
-                                "Internal: PLT stub doesn't represent. "
-                                "Resolve it with pcrel");
-                  i = 1, j = 3;
-                }
-            }
-
-          for (; i < j; i++)
-            {
-              if ((i & 1) == 0 && defined_local)
-                {
-                  relocation -= pc;
-                  relocation += rel->r_addend;
-                  break;
-                }
-
-              if ((i & 1) && h && h->plt.offset != MINUS_ONE)
-                {
-                  LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
-                                "PLT shouldn't be with r_addend.");
-                  relocation = sec_addr (plt) + h->plt.offset - pc;
-                  break;
-                }
-            }
-          break;
-
-        case R_LARCH_SOP_PUSH_GPREL:
-          unresolved_reloc = false;
-
-          LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
-                        "Shouldn't be with r_addend.");
-
-          if (h != NULL)
-            {
-              off = h->got.offset;
-
-              LARCH_ASSERT (off != MINUS_ONE, bfd_reloc_notsupported,
-                            "Internal: GOT entry doesn't represent.");
-
-              if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (is_dyn, is_pic, h) ||
-                  (is_pic && SYMBOL_REFERENCES_LOCAL (info, h)))
-                {
-                  /* This is actually a static link, or it is a
-                     -Bsymbolic link and the symbol is defined
-                     locally, or the symbol was forced to be local
-                     because of a version file.  We must initialize
-                     this entry in the global offset table.  Since the
-                     offset must always be a multiple of the word size,
-                     we use the least significant bit to record whether
-                     we have initialized it already.
-
-                     When doing a dynamic link, we create a .rela.got
-                     relocation entry to initialize the value.  This
-                     is done in the finish_dynamic_symbol routine.  */
-
-                  LARCH_ASSERT (!resolved_dynly, bfd_reloc_dangerous,
-                                "Internal: here shouldn't dynamic.");
-                  LARCH_ASSERT (defined_local || resolved_to_const,
-                                bfd_reloc_undefined, "Internal: ");
-
-                  if ((off & 1) != 0)
-                    off &= ~1;
-                  else
-                    {
-                      bfd_put_NN (output_bfd, relocation, got->contents + off);
-                      h->got.offset |= 1;
-                    }
-                }
-            }
-          else
-            {
-              LARCH_ASSERT (local_got_offsets, bfd_reloc_notsupported,
-                            "Internal: local got offsets not reporesent.");
-
-              off = local_got_offsets[r_symndx];
-
-              LARCH_ASSERT (off != MINUS_ONE, bfd_reloc_notsupported,
-                            "Internal: GOT entry doesn't represent.");
-
-              /* The offset must always be a multiple of the word size.
-                 So, we can use the least significant bit to record
-                 whether we have already processed this entry.  */
-              if ((off & 1) != 0)
-                off &= ~1;
-              else
-                {
-                  if (is_pic)
-                    {
-                      asection *s;
-                      Elf_Internal_Rela outrel;
-                      /* We need to generate a R_LARCH_RELATIVE reloc
-                         for the dynamic linker.  */
-                      s = htab->elf.srelgot;
-                      LARCH_ASSERT (s, bfd_reloc_notsupported,
-                                    "Internal: '.rel.got' not represent");
-
-                      outrel.r_offset = sec_addr (got) + off;
-                      outrel.r_info = ELFNN_R_INFO (0, R_LARCH_RELATIVE);
-                      outrel.r_addend = relocation; /* Link-time addr. */
-                      loongarch_elf_append_rela (output_bfd, s, &outrel);
-                    }
-
-                  bfd_put_NN (output_bfd, relocation, got->contents + off);
-                  local_got_offsets[r_symndx] |= 1;
-                }
-            }
-          relocation = off;
-          break;
-
-        case R_LARCH_SOP_PUSH_TLS_GOT:
-        case R_LARCH_SOP_PUSH_TLS_GD:
-          if (r_type == R_LARCH_SOP_PUSH_TLS_GOT)
-            is_ie = true;
-          unresolved_reloc = false;
-
-          LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
-                        "Shouldn't be with r_addend.");
-
-          if (resolved_to_const && is_undefweak && h->dynindx != -1)
-            {
-              /* What if undefweak? Let rtld make a decision. */
-              resolved_to_const = resolved_local = false;
-              resolved_dynly = true;
-            }
-
-          LARCH_ASSERT (!resolved_to_const, bfd_reloc_notsupported,
-                        "Internal: Shouldn't be resolved to const.");
-
-          if (h != NULL)
-            {
-              off = h->got.offset;
-              h->got.offset |= 1;
-            }
-          else
-            {
-              off = local_got_offsets[r_symndx];
-              local_got_offsets[r_symndx] |= 1;
-            }
-
-          LARCH_ASSERT (off != MINUS_ONE, bfd_reloc_notsupported,
-                        "Internal: TLS GOT entry doesn't represent.");
-
-          tls_type = _bfd_loongarch_elf_tls_type (input_bfd, h, r_symndx);
-
-          /* If this symbol is referenced by both GD and IE TLS, the IE
-             reference's GOT slot follows the GD reference's slots.  */
-          ie_off = 0;
-          if ((tls_type & GOT_TLS_GD) && (tls_type & GOT_TLS_IE))
-            ie_off = 2 * GOT_ENTRY_SIZE;
-
-          if ((off & 1) != 0)
-            off &= ~1;
-          else
-            {
-              bfd_vma tls_block_off = 0;
-              Elf_Internal_Rela outrel;
-
-              if (resolved_local)
-                {
-                  LARCH_ASSERT (elf_hash_table (info)->tls_sec,
-                                bfd_reloc_notsupported,
-                                "Internal: TLS sec not represent.");
-                  tls_block_off =
-                    relocation - elf_hash_table (info)->tls_sec->vma;
-                }
-
-              if (tls_type & GOT_TLS_GD)
-                {
-                  outrel.r_offset = sec_addr (got) + off;
-                  outrel.r_addend = 0;
-                  bfd_put_NN (output_bfd, 0, got->contents + off);
-                  if (resolved_local && bfd_link_executable (info))
-                    bfd_put_NN (output_bfd, 1, got->contents + off);
-                  else if (resolved_local /* && !bfd_link_executable (info) */)
-                    {
-                      outrel.r_info = ELFNN_R_INFO (0, R_LARCH_TLS_DTPMODNN);
-                      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
-                                                 &outrel);
-                    }
-                  else /* if (resolved_dynly) */
-                    {
-                      outrel.r_info =
-                        ELFNN_R_INFO (h->dynindx, R_LARCH_TLS_DTPMODNN);
-                      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
-                                                 &outrel);
-                    }
-
-                  outrel.r_offset += GOT_ENTRY_SIZE;
-                  bfd_put_NN (output_bfd, tls_block_off,
-                              got->contents + off + GOT_ENTRY_SIZE);
-                  if (resolved_local)
-                    /* DTPREL known */;
-                  else /* if (resolved_dynly) */
-                    {
-                      outrel.r_info =
-                        ELFNN_R_INFO (h->dynindx, R_LARCH_TLS_DTPRELNN);
-                      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
-                                                 &outrel);
-                    }
-                }
-
-              if (tls_type & GOT_TLS_IE)
-                {
-                  outrel.r_offset = sec_addr (got) + off + ie_off;
-                  bfd_put_NN (output_bfd, tls_block_off,
-                              got->contents + off + ie_off);
-                  if (resolved_local && bfd_link_executable (info))
-                    /* TPREL known */;
-                  else if (resolved_local /* && !bfd_link_executable (info) */)
-                    {
-                      outrel.r_info = ELFNN_R_INFO (0, R_LARCH_TLS_TPRELNN);
-                      outrel.r_addend = tls_block_off;
-                      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
-                                                 &outrel);
-                    }
-                  else /* if (resolved_dynly) */
-                    {
-                      outrel.r_info =
-                        ELFNN_R_INFO (h->dynindx, R_LARCH_TLS_TPRELNN);
-                      outrel.r_addend = 0;
-                      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
-                                                 &outrel);
-                    }
-                }
-            }
-
-          relocation = off + (is_ie ? ie_off : 0);
-          break;
-
-        default:
-          break;
-        }
+	case R_LARCH_MARK_PCREL:
+	case R_LARCH_MARK_LA:
+	case R_LARCH_NONE:
+	  r = bfd_reloc_continue;
+	  unresolved_reloc = false;
+	  break;
+
+	case R_LARCH_32:
+	case R_LARCH_64:
+	  if (resolved_dynly || (is_pic && resolved_local))
+	    {
+	      Elf_Internal_Rela outrel;
+
+	      /* When generating a shared object, these relocations are copied
+		 into the output file to be resolved at run time.  */
+
+	      outrel.r_offset = _bfd_elf_section_offset (
+		output_bfd, info, input_section, rel->r_offset);
+
+	      unresolved_reloc = !((bfd_vma) -2 <= outrel.r_offset)
+				 && (input_section->flags & SEC_ALLOC);
+
+	      outrel.r_offset += sec_addr (input_section);
+	      if (resolved_dynly)
+		{
+		  outrel.r_info = ELFNN_R_INFO (h->dynindx, r_type);
+		  outrel.r_addend = rel->r_addend;
+		}
+	      else
+		{
+		  outrel.r_info = ELFNN_R_INFO (0, R_LARCH_RELATIVE);
+		  outrel.r_addend = relocation + rel->r_addend;
+		}
+
+	      if (unresolved_reloc)
+		loongarch_elf_append_rela (output_bfd, sreloc, &outrel);
+	    }
+
+	  relocation += rel->r_addend;
+	  break;
+
+	case R_LARCH_ADD8:
+	case R_LARCH_ADD16:
+	case R_LARCH_ADD24:
+	case R_LARCH_ADD32:
+	case R_LARCH_ADD64:
+	case R_LARCH_SUB8:
+	case R_LARCH_SUB16:
+	case R_LARCH_SUB24:
+	case R_LARCH_SUB32:
+	case R_LARCH_SUB64:
+	  LARCH_ASSERT (
+	    !resolved_dynly, bfd_reloc_undefined,
+	    "Can't be resolved dynamically.  If this procedure is hand-writing "
+	    "assemble,\n"
+	    "there must be something like '.dword sym1 - sym2' to generate "
+	    "these relocs\n"
+	    "and we can't get known link-time address of these symbols.");
+	  relocation += rel->r_addend;
+	  break;
+
+	case R_LARCH_TLS_DTPREL32:
+	case R_LARCH_TLS_DTPREL64:
+	  if (resolved_dynly)
+	    {
+	      Elf_Internal_Rela outrel;
+
+	      outrel.r_offset = _bfd_elf_section_offset (
+		output_bfd, info, input_section, rel->r_offset);
+
+	      unresolved_reloc = !((bfd_vma) -2 <= outrel.r_offset)
+				 && (input_section->flags & SEC_ALLOC);
+	      outrel.r_info = ELFNN_R_INFO (h->dynindx, r_type);
+	      outrel.r_offset += sec_addr (input_section);
+	      outrel.r_addend = rel->r_addend;
+	      if (unresolved_reloc)
+		loongarch_elf_append_rela (output_bfd, sreloc, &outrel);
+	      break;
+	    }
+
+	  LARCH_ASSERT (!resolved_to_const, bfd_reloc_notsupported,
+			"Internal:");
+	  break;
+	case R_LARCH_SOP_PUSH_TLS_TPREL:
+	  if (resolved_local)
+	    {
+	      LARCH_ASSERT (elf_hash_table (info)->tls_sec,
+			    bfd_reloc_notsupported,
+			    "TLS section not be created");
+	      relocation -= elf_hash_table (info)->tls_sec->vma;
+	    }
+
+	  LARCH_ASSERT (resolved_local, bfd_reloc_undefined,
+			"TLS LE just can be resolved local only.");
+	  break;
+
+	case R_LARCH_SOP_PUSH_ABSOLUTE:
+	  if (is_undefweak)
+	    {
+	      LARCH_ASSERT (
+		!resolved_dynly, bfd_reloc_dangerous,
+		"Someone require us to resolve undefweak symbol dynamically.\n"
+		"But this reloc can't be done.  I think I can't throw error "
+		"for this\n"
+		"so I resolved it to 0.  I suggest to re-compile with "
+		"'-fpic'.");
+	      relocation = 0;
+	      unresolved_reloc = false;
+	      break;
+	    }
+
+	  if (resolved_to_const)
+	    {
+	      relocation += rel->r_addend;
+	      break;
+	    }
+
+	  LARCH_ASSERT (!is_pic, bfd_reloc_notsupported,
+			"Under PIC we don't know load address.  Re-compile src "
+			"with '-fpic'?");
+
+	  if (resolved_dynly)
+	    {
+	      LARCH_ASSERT (plt && h && h->plt.offset != MINUS_ONE,
+			    bfd_reloc_undefined,
+			    "Can't be resolved dynamically.  Try to re-compile "
+			    "src with '-fpic'?");
+
+	      LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
+			    "Shouldn't be with r_addend.");
+
+	      relocation = sec_addr (plt) + h->plt.offset;
+	      unresolved_reloc = false;
+	      break;
+	    }
+
+	  if (resolved_local)
+	    {
+	      relocation += rel->r_addend;
+	      break;
+	    }
+
+	  break;
+
+	case R_LARCH_SOP_PUSH_PCREL:
+	case R_LARCH_SOP_PUSH_PLT_PCREL:
+	  unresolved_reloc = false;
+
+	  if (resolved_to_const)
+	    {
+	      relocation += rel->r_addend;
+	      break;
+	    }
+	  else if (is_undefweak)
+	    {
+	      i = 0, j = 0;
+	      relocation = 0;
+	      if (resolved_dynly)
+		{
+		  if (h && h->plt.offset != MINUS_ONE)
+		    i = 1, j = 2;
+		  else
+		    LARCH_ASSERT (0, bfd_reloc_dangerous,
+				  "Undefweak need to be resolved dynamically, "
+				  "but PLT stub doesn't represent.");
+		}
+	    }
+	  else
+	    {
+	      LARCH_ASSERT (
+		defined_local || (h && h->plt.offset != MINUS_ONE),
+		bfd_reloc_undefined,
+		"PLT stub does not represent and symbol not defined.");
+
+	      if (resolved_local)
+		i = 0, j = 2;
+	      else /* if (resolved_dynly) */
+		{
+		  LARCH_ASSERT (h && h->plt.offset != MINUS_ONE,
+				bfd_reloc_dangerous,
+				"Internal: PLT stub doesn't represent.  "
+				"Resolve it with pcrel");
+		  i = 1, j = 3;
+		}
+	    }
+
+	  for (; i < j; i++)
+	    {
+	      if ((i & 1) == 0 && defined_local)
+		{
+		  relocation -= pc;
+		  relocation += rel->r_addend;
+		  break;
+		}
+
+	      if ((i & 1) && h && h->plt.offset != MINUS_ONE)
+		{
+		  LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
+				"PLT shouldn't be with r_addend.");
+		  relocation = sec_addr (plt) + h->plt.offset - pc;
+		  break;
+		}
+	    }
+	  break;
+
+	case R_LARCH_SOP_PUSH_GPREL:
+	  unresolved_reloc = false;
+
+	  LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
+			"Shouldn't be with r_addend.");
+
+	  if (h != NULL)
+	    {
+	      off = h->got.offset;
+
+	      LARCH_ASSERT (off != MINUS_ONE, bfd_reloc_notsupported,
+			    "Internal: GOT entry doesn't represent.");
+
+	      if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (is_dyn, is_pic, h)
+		  || (is_pic && SYMBOL_REFERENCES_LOCAL (info, h)))
+		{
+		  /* This is actually a static link, or it is a
+		     -Bsymbolic link and the symbol is defined
+		     locally, or the symbol was forced to be local
+		     because of a version file.  We must initialize
+		     this entry in the global offset table.  Since the
+		     offset must always be a multiple of the word size,
+		     we use the least significant bit to record whether
+		     we have initialized it already.
+
+		     When doing a dynamic link, we create a .rela.got
+		     relocation entry to initialize the value.  This
+		     is done in the finish_dynamic_symbol routine.  */
+
+		  LARCH_ASSERT (!resolved_dynly, bfd_reloc_dangerous,
+				"Internal: here shouldn't dynamic.");
+		  LARCH_ASSERT (defined_local || resolved_to_const,
+				bfd_reloc_undefined, "Internal: ");
+
+		  if ((off & 1) != 0)
+		    off &= ~1;
+		  else
+		    {
+		      bfd_put_NN (output_bfd, relocation, got->contents + off);
+		      h->got.offset |= 1;
+		    }
+		}
+	    }
+	  else
+	    {
+	      LARCH_ASSERT (local_got_offsets, bfd_reloc_notsupported,
+			    "Internal: local got offsets not reporesent.");
+
+	      off = local_got_offsets[r_symndx];
+
+	      LARCH_ASSERT (off != MINUS_ONE, bfd_reloc_notsupported,
+			    "Internal: GOT entry doesn't represent.");
+
+	      /* The offset must always be a multiple of the word size.
+		 So, we can use the least significant bit to record
+		 whether we have already processed this entry.  */
+	      if ((off & 1) != 0)
+		off &= ~1;
+	      else
+		{
+		  if (is_pic)
+		    {
+		      asection *s;
+		      Elf_Internal_Rela outrel;
+		      /* We need to generate a R_LARCH_RELATIVE reloc
+			 for the dynamic linker.  */
+		      s = htab->elf.srelgot;
+		      LARCH_ASSERT (s, bfd_reloc_notsupported,
+				    "Internal: '.rel.got' not represent");
+
+		      outrel.r_offset = sec_addr (got) + off;
+		      outrel.r_info = ELFNN_R_INFO (0, R_LARCH_RELATIVE);
+		      outrel.r_addend = relocation; /* Link-time addr.  */
+		      loongarch_elf_append_rela (output_bfd, s, &outrel);
+		    }
+
+		  bfd_put_NN (output_bfd, relocation, got->contents + off);
+		  local_got_offsets[r_symndx] |= 1;
+		}
+	    }
+	  relocation = off;
+	  break;
+
+	case R_LARCH_SOP_PUSH_TLS_GOT:
+	case R_LARCH_SOP_PUSH_TLS_GD:
+	  if (r_type == R_LARCH_SOP_PUSH_TLS_GOT)
+	    is_ie = true;
+	  unresolved_reloc = false;
+
+	  LARCH_ASSERT (rel->r_addend == 0, bfd_reloc_notsupported,
+			"Shouldn't be with r_addend.");
+
+	  if (resolved_to_const && is_undefweak && h->dynindx != -1)
+	    {
+	      /* What if undefweak? Let rtld make a decision.  */
+	      resolved_to_const = resolved_local = false;
+	      resolved_dynly = true;
+	    }
+
+	  LARCH_ASSERT (!resolved_to_const, bfd_reloc_notsupported,
+			"Internal: Shouldn't be resolved to const.");
+
+	  if (h != NULL)
+	    {
+	      off = h->got.offset;
+	      h->got.offset |= 1;
+	    }
+	  else
+	    {
+	      off = local_got_offsets[r_symndx];
+	      local_got_offsets[r_symndx] |= 1;
+	    }
+
+	  LARCH_ASSERT (off != MINUS_ONE, bfd_reloc_notsupported,
+			"Internal: TLS GOT entry doesn't represent.");
+
+	  tls_type = _bfd_loongarch_elf_tls_type (input_bfd, h, r_symndx);
+
+	  /* If this symbol is referenced by both GD and IE TLS, the IE
+	     reference's GOT slot follows the GD reference's slots.  */
+	  ie_off = 0;
+	  if ((tls_type & GOT_TLS_GD) && (tls_type & GOT_TLS_IE))
+	    ie_off = 2 * GOT_ENTRY_SIZE;
+
+	  if ((off & 1) != 0)
+	    off &= ~1;
+	  else
+	    {
+	      bfd_vma tls_block_off = 0;
+	      Elf_Internal_Rela outrel;
+
+	      if (resolved_local)
+		{
+		  LARCH_ASSERT (elf_hash_table (info)->tls_sec,
+				bfd_reloc_notsupported,
+				"Internal: TLS sec not represent.");
+		  tls_block_off =
+		    relocation - elf_hash_table (info)->tls_sec->vma;
+		}
+
+	      if (tls_type & GOT_TLS_GD)
+		{
+		  outrel.r_offset = sec_addr (got) + off;
+		  outrel.r_addend = 0;
+		  bfd_put_NN (output_bfd, 0, got->contents + off);
+		  if (resolved_local && bfd_link_executable (info))
+		    bfd_put_NN (output_bfd, 1, got->contents + off);
+		  else if (resolved_local /* && !bfd_link_executable (info) */)
+		    {
+		      outrel.r_info = ELFNN_R_INFO (0, R_LARCH_TLS_DTPMODNN);
+		      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
+						 &outrel);
+		    }
+		  else /* if (resolved_dynly) */
+		    {
+		      outrel.r_info =
+			ELFNN_R_INFO (h->dynindx, R_LARCH_TLS_DTPMODNN);
+		      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
+						 &outrel);
+		    }
+
+		  outrel.r_offset += GOT_ENTRY_SIZE;
+		  bfd_put_NN (output_bfd, tls_block_off,
+			      got->contents + off + GOT_ENTRY_SIZE);
+		  if (resolved_local)
+		    /* DTPREL known.  */;
+		  else /* if (resolved_dynly) */
+		    {
+		      outrel.r_info =
+			ELFNN_R_INFO (h->dynindx, R_LARCH_TLS_DTPRELNN);
+		      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
+						 &outrel);
+		    }
+		}
+
+	      if (tls_type & GOT_TLS_IE)
+		{
+		  outrel.r_offset = sec_addr (got) + off + ie_off;
+		  bfd_put_NN (output_bfd, tls_block_off,
+			      got->contents + off + ie_off);
+		  if (resolved_local && bfd_link_executable (info))
+		    /* TPREL known.  */;
+		  else if (resolved_local /* && !bfd_link_executable (info) */)
+		    {
+		      outrel.r_info = ELFNN_R_INFO (0, R_LARCH_TLS_TPRELNN);
+		      outrel.r_addend = tls_block_off;
+		      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
+						 &outrel);
+		    }
+		  else /* if (resolved_dynly) */
+		    {
+		      outrel.r_info =
+			ELFNN_R_INFO (h->dynindx, R_LARCH_TLS_TPRELNN);
+		      outrel.r_addend = 0;
+		      loongarch_elf_append_rela (output_bfd, htab->elf.srelgot,
+						 &outrel);
+		    }
+		}
+	    }
+
+	  relocation = off + (is_ie ? ie_off : 0);
+	  break;
+
+	default:
+	  break;
+	}
 
       if (fatal)
-        break;
+	break;
 
       do
-        {
-          /* 'unresolved_reloc' means we haven't done it yet.
-             We need help of dynamic linker to fix this memory location up. */
-          if (!unresolved_reloc)
-            break;
-
-          if (_bfd_elf_section_offset (output_bfd, info, input_section,
-                                       rel->r_offset) == MINUS_ONE)
-            /* WHY? May because it's invalid so skip checking.
-               But why dynamic reloc a invalid section? */
-            break;
-
-          if (input_section->output_section->flags & SEC_DEBUGGING)
-            {
-              LARCH_ASSERT (
-                0, bfd_reloc_dangerous,
-                "Seems dynamic linker not process sections 'SEC_DEBUGGING'.");
-              break;
-            }
-          if (!is_dyn)
-            break;
-
-          if ((info->flags & DF_TEXTREL) == 0)
-            if (input_section->output_section->flags & SEC_READONLY)
-              info->flags |= DF_TEXTREL;
-        }
+	{
+	  /* 'unresolved_reloc' means we haven't done it yet.
+	     We need help of dynamic linker to fix this memory location up.  */
+	  if (!unresolved_reloc)
+	    break;
+
+	  if (_bfd_elf_section_offset (output_bfd, info, input_section,
+				       rel->r_offset) == MINUS_ONE)
+	    /* WHY? May because it's invalid so skip checking.
+	       But why dynamic reloc a invalid section? */
+	    break;
+
+	  if (input_section->output_section->flags & SEC_DEBUGGING)
+	    {
+	      LARCH_ASSERT (
+		0, bfd_reloc_dangerous,
+		"Seems dynamic linker not process sections 'SEC_DEBUGGING'.");
+	      break;
+	    }
+	  if (!is_dyn)
+	    break;
+
+	  if ((info->flags & DF_TEXTREL) == 0)
+	    if (input_section->output_section->flags & SEC_READONLY)
+	      info->flags |= DF_TEXTREL;
+	}
       while (0);
 #undef LARCH_ASSERT
 
       if (fatal)
-        break;
+	break;
 
       loongarch_record_one_reloc (input_bfd, input_section, r_type,
-                                  rel->r_offset, sym, h, rel->r_addend);
+				  rel->r_offset, sym, h, rel->r_addend);
 
       if (r != bfd_reloc_continue)
-        r = perform_relocation (rel, relocation, input_bfd, contents);
+	r = perform_relocation (rel, relocation, input_bfd, contents);
 
       switch (r)
-        {
-        case bfd_reloc_dangerous:
-        case bfd_reloc_continue:
-        case bfd_reloc_ok:
-          continue;
-
-        case bfd_reloc_overflow:
-          /* Overflow value can't be filled in */
-          loongarch_dump_reloc_record (info->callbacks->info);
-          info->callbacks->reloc_overflow (
-            info, (h ? &h->root : NULL), name, howto->name, rel->r_addend,
-            input_bfd, input_section, rel->r_offset);
-          break;
-
-        case bfd_reloc_outofrange:
-          /* Stack state incorrect */
-          loongarch_dump_reloc_record (info->callbacks->info);
-          info->callbacks->info (
-            "%X%H: Internal stack state is incorrect.\n"
-            "Want to push to full stack or pop from empty stack?\n",
-            input_bfd, input_section, rel->r_offset);
-          break;
-
-        case bfd_reloc_notsupported:
-          info->callbacks->info ("%X%H: Unknown relocation type.\n", input_bfd,
-                                 input_section, rel->r_offset);
-          break;
-
-        default:
-          info->callbacks->info ("%X%H: Internal: unknown error.\n", input_bfd,
-                                 input_section, rel->r_offset);
-          break;
-        }
+	{
+	case bfd_reloc_dangerous:
+	case bfd_reloc_continue:
+	case bfd_reloc_ok:
+	  continue;
+
+	case bfd_reloc_overflow:
+	  /* Overflow value can't be filled in.  */
+	  loongarch_dump_reloc_record (info->callbacks->info);
+	  info->callbacks->reloc_overflow (
+	    info, (h ? &h->root : NULL), name, howto->name, rel->r_addend,
+	    input_bfd, input_section, rel->r_offset);
+	  break;
+
+	case bfd_reloc_outofrange:
+	  /* Stack state incorrect.  */
+	  loongarch_dump_reloc_record (info->callbacks->info);
+	  info->callbacks->info (
+	    "%X%H: Internal stack state is incorrect.\n"
+	    "Want to push to full stack or pop from empty stack?\n",
+	    input_bfd, input_section, rel->r_offset);
+	  break;
+
+	case bfd_reloc_notsupported:
+	  info->callbacks->info ("%X%H: Unknown relocation type.\n", input_bfd,
+				 input_section, rel->r_offset);
+	  break;
+
+	default:
+	  info->callbacks->info ("%X%H: Internal: unknown error.\n", input_bfd,
+				 input_section, rel->r_offset);
+	  break;
+	}
 
       fatal = true;
       break;
@@ -2533,9 +2534,9 @@ loongarch_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
 
 static bool
 loongarch_elf_finish_dynamic_symbol (bfd *output_bfd,
-                                     struct bfd_link_info *info,
-                                     struct elf_link_hash_entry *h,
-                                     Elf_Internal_Sym *sym)
+				     struct bfd_link_info *info,
+				     struct elf_link_hash_entry *h,
+				     Elf_Internal_Sym *sym)
 {
   struct loongarch_elf_link_hash_table *htab = loongarch_elf_hash_table (info);
   const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
@@ -2552,40 +2553,40 @@ loongarch_elf_finish_dynamic_symbol (bfd *output_bfd,
 
       plt_idx = (h->plt.offset - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
 
-      /* One of '.plt' and '.iplt' represents. */
+      /* One of '.plt' and '.iplt' represents.  */
       BFD_ASSERT (!!htab->elf.splt ^ !!htab->elf.iplt);
 
       if (htab->elf.splt)
-        {
-          BFD_ASSERT (
-            (h->type == STT_GNU_IFUNC && SYMBOL_REFERENCES_LOCAL (info, h)) ||
-            h->dynindx != -1);
-
-          plt = htab->elf.splt;
-          gotplt = htab->elf.sgotplt;
-          relplt = htab->elf.srelplt;
-          got_address =
-            sec_addr (gotplt) + GOTPLT_HEADER_SIZE + plt_idx * GOT_ENTRY_SIZE;
-        }
+	{
+	  BFD_ASSERT (
+	    (h->type == STT_GNU_IFUNC && SYMBOL_REFERENCES_LOCAL (info, h))
+	    || h->dynindx != -1);
+
+	  plt = htab->elf.splt;
+	  gotplt = htab->elf.sgotplt;
+	  relplt = htab->elf.srelplt;
+	  got_address =
+	    sec_addr (gotplt) + GOTPLT_HEADER_SIZE + plt_idx * GOT_ENTRY_SIZE;
+	}
       else /* if (htab->elf.iplt) */
-        {
-          BFD_ASSERT (h->type == STT_GNU_IFUNC &&
-                      SYMBOL_REFERENCES_LOCAL (info, h));
+	{
+	  BFD_ASSERT (h->type == STT_GNU_IFUNC
+		      && SYMBOL_REFERENCES_LOCAL (info, h));
 
-          plt = htab->elf.iplt;
-          gotplt = htab->elf.igotplt;
-          relplt = htab->elf.irelplt;
-          got_address = sec_addr (gotplt) + plt_idx * GOT_ENTRY_SIZE;
-        }
+	  plt = htab->elf.iplt;
+	  gotplt = htab->elf.igotplt;
+	  relplt = htab->elf.irelplt;
+	  got_address = sec_addr (gotplt) + plt_idx * GOT_ENTRY_SIZE;
+	}
 
       /* Find out where the .plt entry should go.  */
       loc = plt->contents + h->plt.offset;
 
       /* Fill in the PLT entry itself.  */
       loongarch_make_plt_entry (got_address, sec_addr (plt) + h->plt.offset,
-                                plt_entry);
+				plt_entry);
       for (i = 0; i < PLT_ENTRY_INSNS; i++)
-        bfd_put_32 (output_bfd, plt_entry[i], loc + 4 * i);
+	bfd_put_32 (output_bfd, plt_entry[i], loc + 4 * i);
 
       /* Fill in the initial value of the .got.plt entry.  */
       loc = gotplt->contents + (got_address - sec_addr (gotplt));
@@ -2593,42 +2594,42 @@ loongarch_elf_finish_dynamic_symbol (bfd *output_bfd,
 
       rela.r_offset = got_address;
       if (h->type == STT_GNU_IFUNC && SYMBOL_REFERENCES_LOCAL (info, h))
-        {
-          rela.r_info = ELFNN_R_INFO (0, R_LARCH_IRELATIVE);
-          rela.r_addend = h->root.u.def.value +
-                          h->root.u.def.section->output_section->vma +
-                          h->root.u.def.section->output_offset;
-        }
+	{
+	  rela.r_info = ELFNN_R_INFO (0, R_LARCH_IRELATIVE);
+	  rela.r_addend = h->root.u.def.value
+			  + h->root.u.def.section->output_section->vma
+			  + h->root.u.def.section->output_offset;
+	}
       else
-        {
-          /* Fill in the entry in the .rela.plt section.  */
-          rela.r_info = ELFNN_R_INFO (h->dynindx, R_LARCH_JUMP_SLOT);
-          rela.r_addend = 0;
-        }
+	{
+	  /* Fill in the entry in the .rela.plt section.  */
+	  rela.r_info = ELFNN_R_INFO (h->dynindx, R_LARCH_JUMP_SLOT);
+	  rela.r_addend = 0;
+	}
 
       loc = relplt->contents + plt_idx * sizeof (ElfNN_External_Rela);
       bed->s->swap_reloca_out (output_bfd, &rela, loc);
 
       if (!h->def_regular)
-        {
-          /* Mark the symbol as undefined, rather than as defined in
-             the .plt section.  Leave the value alone.  */
-          sym->st_shndx = SHN_UNDEF;
-          /* If the symbol is weak, we do need to clear the value.
-             Otherwise, the PLT entry would provide a definition for
-             the symbol even if the symbol wasn't defined anywhere,
-             and so the symbol would never be NULL.  */
-          if (!h->ref_regular_nonweak)
-            sym->st_value = 0;
-        }
+	{
+	  /* Mark the symbol as undefined, rather than as defined in
+	     the .plt section.  Leave the value alone.  */
+	  sym->st_shndx = SHN_UNDEF;
+	  /* If the symbol is weak, we do need to clear the value.
+	     Otherwise, the PLT entry would provide a definition for
+	     the symbol even if the symbol wasn't defined anywhere,
+	     and so the symbol would never be NULL.  */
+	  if (!h->ref_regular_nonweak)
+	    sym->st_value = 0;
+	}
     }
 
   if (h->got.offset != MINUS_ONE
 
-      && /* TLS got entry have been handled in elf_relocate_section */
+      && /* TLS got entry have been handled in elf_relocate_section.  */
       !(loongarch_elf_hash_entry (h)->tls_type & (GOT_TLS_GD | GOT_TLS_IE))
 
-      && /* have allocated got entry but not allocated rela before */
+      && /* have allocated got entry but not allocated rela before.  */
       !UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))
     {
       asection *sgot, *srela;
@@ -2644,41 +2645,41 @@ loongarch_elf_finish_dynamic_symbol (bfd *output_bfd,
       rela.r_offset = sec_addr (sgot) + off;
 
       if (h->type == STT_GNU_IFUNC)
-        {
-          if (elf_hash_table (info)->dynamic_sections_created &&
-              SYMBOL_REFERENCES_LOCAL (info, h))
-            {
-              asection *sec = h->root.u.def.section;
-              rela.r_info = ELFNN_R_INFO (0, R_LARCH_IRELATIVE);
-              rela.r_addend = h->root.u.def.value + sec->output_section->vma +
-                              sec->output_offset;
-              bfd_put_NN (output_bfd, 0, sgot->contents + off);
-            }
-          else
-            {
-              BFD_ASSERT (plt);
-              rela.r_info = ELFNN_R_INFO (
-                0, bfd_link_pic (info) ? R_LARCH_RELATIVE : R_LARCH_NONE);
-              rela.r_addend =
-                plt->output_section->vma + plt->output_offset + h->plt.offset;
-              bfd_put_NN (output_bfd, rela.r_addend, sgot->contents + off);
-            }
-        }
+	{
+	  if (elf_hash_table (info)->dynamic_sections_created
+	      && SYMBOL_REFERENCES_LOCAL (info, h))
+	    {
+	      asection *sec = h->root.u.def.section;
+	      rela.r_info = ELFNN_R_INFO (0, R_LARCH_IRELATIVE);
+	      rela.r_addend = h->root.u.def.value + sec->output_section->vma
+			      + sec->output_offset;
+	      bfd_put_NN (output_bfd, 0, sgot->contents + off);
+	    }
+	  else
+	    {
+	      BFD_ASSERT (plt);
+	      rela.r_info = ELFNN_R_INFO (
+		0, bfd_link_pic (info) ? R_LARCH_RELATIVE : R_LARCH_NONE);
+	      rela.r_addend =
+		plt->output_section->vma + plt->output_offset + h->plt.offset;
+	      bfd_put_NN (output_bfd, rela.r_addend, sgot->contents + off);
+	    }
+	}
       else if (bfd_link_pic (info) && SYMBOL_REFERENCES_LOCAL (info, h))
-        {
-          BFD_ASSERT (h->got.offset & 1 /* Has been filled in addr. */);
-          asection *sec = h->root.u.def.section;
-          rela.r_info = ELFNN_R_INFO (0, R_LARCH_RELATIVE);
-          rela.r_addend = h->root.u.def.value + sec->output_section->vma +
-                          sec->output_offset;
-        }
+	{
+	  BFD_ASSERT (h->got.offset & 1 /* Has been filled in addr.  */);
+	  asection *sec = h->root.u.def.section;
+	  rela.r_info = ELFNN_R_INFO (0, R_LARCH_RELATIVE);
+	  rela.r_addend = h->root.u.def.value + sec->output_section->vma
+			  + sec->output_offset;
+	}
       else
-        {
-          BFD_ASSERT ((h->got.offset & 1) == 0);
-          BFD_ASSERT (h->dynindx != -1);
-          rela.r_info = ELFNN_R_INFO (h->dynindx, R_LARCH_NN);
-          rela.r_addend = 0;
-        }
+	{
+	  BFD_ASSERT ((h->got.offset & 1) == 0);
+	  BFD_ASSERT (h->dynindx != -1);
+	  rela.r_info = ELFNN_R_INFO (h->dynindx, R_LARCH_NN);
+	  rela.r_addend = 0;
+	}
 
       loongarch_elf_append_rela (output_bfd, srela, &rela);
     }
@@ -2695,9 +2696,9 @@ loongarch_elf_finish_dynamic_symbol (bfd *output_bfd,
       rela.r_info = ELFNN_R_INFO (h->dynindx, R_LARCH_COPY);
       rela.r_addend = 0;
       if (h->root.u.def.section == htab->elf.sdynrelro)
-        s = htab->elf.sreldynrelro;
+	s = htab->elf.sreldynrelro;
       else
-        s = htab->elf.srelbss;
+	s = htab->elf.srelbss;
       loongarch_elf_append_rela (output_bfd, s, &rela);
     }
 
@@ -2712,7 +2713,7 @@ loongarch_elf_finish_dynamic_symbol (bfd *output_bfd,
 
 static bool
 loongarch_finish_dyn (bfd *output_bfd, struct bfd_link_info *info, bfd *dynobj,
-                      asection *sdyn)
+		      asection *sdyn)
 {
   struct loongarch_elf_link_hash_table *htab = loongarch_elf_hash_table (info);
   const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
@@ -2729,32 +2730,32 @@ loongarch_finish_dyn (bfd *output_bfd, struct bfd_link_info *info, bfd *dynobj,
       bed->s->swap_dyn_in (dynobj, dyncon, &dyn);
 
       switch (dyn.d_tag)
-        {
-        case DT_PLTGOT:
-          s = htab->elf.sgotplt;
-          dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
-          break;
-        case DT_JMPREL:
-          s = htab->elf.srelplt;
-          dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
-          break;
-        case DT_PLTRELSZ:
-          s = htab->elf.srelplt;
-          dyn.d_un.d_val = s->size;
-          break;
-        case DT_TEXTREL:
-          if ((info->flags & DF_TEXTREL) == 0)
-            skipped = 1;
-          break;
-        case DT_FLAGS:
-          if ((info->flags & DF_TEXTREL) == 0)
-            dyn.d_un.d_val &= ~DF_TEXTREL;
-          break;
-        }
+	{
+	case DT_PLTGOT:
+	  s = htab->elf.sgotplt;
+	  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	  break;
+	case DT_JMPREL:
+	  s = htab->elf.srelplt;
+	  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	  break;
+	case DT_PLTRELSZ:
+	  s = htab->elf.srelplt;
+	  dyn.d_un.d_val = s->size;
+	  break;
+	case DT_TEXTREL:
+	  if ((info->flags & DF_TEXTREL) == 0)
+	    skipped = 1;
+	  break;
+	case DT_FLAGS:
+	  if ((info->flags & DF_TEXTREL) == 0)
+	    dyn.d_un.d_val &= ~DF_TEXTREL;
+	  break;
+	}
       if (skipped)
-        skipped_size += dynsize;
+	skipped_size += dynsize;
       else
-        bed->s->swap_dyn_out (output_bfd, &dyn, dyncon - skipped_size);
+	bed->s->swap_dyn_out (output_bfd, &dyn, dyncon - skipped_size);
     }
   /* Wipe out any trailing entries if we shifted down a dynamic tag.  */
   memset (dyncon - skipped_size, 0, skipped_size);
@@ -2775,7 +2776,7 @@ elfNN_loongarch_finish_local_dynamic_symbol (void **slot, void *inf)
 
 static bool
 loongarch_elf_finish_dynamic_sections (bfd *output_bfd,
-                                       struct bfd_link_info *info)
+				       struct bfd_link_info *info)
 {
   bfd *dynobj;
   asection *sdyn, *plt, *gotplt;
@@ -2791,7 +2792,7 @@ loongarch_elf_finish_dynamic_sections (bfd *output_bfd,
       BFD_ASSERT (htab->elf.splt && sdyn);
 
       if (!loongarch_finish_dyn (output_bfd, info, dynobj, sdyn))
-        return false;
+	return false;
     }
 
   if ((plt = htab->elf.splt))
@@ -2804,12 +2805,12 @@ loongarch_elf_finish_dynamic_sections (bfd *output_bfd,
       size_t i;
       uint32_t plt_header[PLT_HEADER_INSNS];
       loongarch_make_plt_header (sec_addr (gotplt), sec_addr (plt),
-                                 plt_header);
+				 plt_header);
       for (i = 0; i < PLT_HEADER_INSNS; i++)
-        bfd_put_32 (output_bfd, plt_header[i], plt->contents + 4 * i);
+	bfd_put_32 (output_bfd, plt_header[i], plt->contents + 4 * i);
 
       elf_section_data (plt->output_section)->this_hdr.sh_entsize =
-        PLT_ENTRY_SIZE;
+	PLT_ENTRY_SIZE;
     }
 
   if (htab->elf.sgotplt)
@@ -2817,21 +2818,21 @@ loongarch_elf_finish_dynamic_sections (bfd *output_bfd,
       asection *output_section = htab->elf.sgotplt->output_section;
 
       if (bfd_is_abs_section (output_section))
-        {
-          _bfd_error_handler (_ ("discarded output section: `%pA'"),
-                              htab->elf.sgotplt);
-          return false;
-        }
+	{
+	  _bfd_error_handler (_ ("discarded output section: `%pA'"),
+			      htab->elf.sgotplt);
+	  return false;
+	}
 
       if (0 < htab->elf.sgotplt->size)
-        {
-          /* Write the first two entries in .got.plt, needed for the dynamic
-             linker.  */
-          bfd_put_NN (output_bfd, MINUS_ONE, htab->elf.sgotplt->contents);
+	{
+	  /* Write the first two entries in .got.plt, needed for the dynamic
+	     linker.  */
+	  bfd_put_NN (output_bfd, MINUS_ONE, htab->elf.sgotplt->contents);
 
-          bfd_put_NN (output_bfd, (bfd_vma) 0,
-                      htab->elf.sgotplt->contents + GOT_ENTRY_SIZE);
-        }
+	  bfd_put_NN (output_bfd, (bfd_vma) 0,
+		      htab->elf.sgotplt->contents + GOT_ENTRY_SIZE);
+	}
 
       elf_section_data (output_section)->this_hdr.sh_entsize = GOT_ENTRY_SIZE;
     }
@@ -2841,19 +2842,19 @@ loongarch_elf_finish_dynamic_sections (bfd *output_bfd,
       asection *output_section = htab->elf.sgot->output_section;
 
       if (0 < htab->elf.sgot->size)
-        {
-          /* Set the first entry in the global offset table to the address of
-             the dynamic section.  */
-          bfd_vma val = sdyn ? sec_addr (sdyn) : 0;
-          bfd_put_NN (output_bfd, val, htab->elf.sgot->contents);
-        }
+	{
+	  /* Set the first entry in the global offset table to the address of
+	     the dynamic section.  */
+	  bfd_vma val = sdyn ? sec_addr (sdyn) : 0;
+	  bfd_put_NN (output_bfd, val, htab->elf.sgot->contents);
+	}
 
       elf_section_data (output_section)->this_hdr.sh_entsize = GOT_ENTRY_SIZE;
     }
 
   /* Fill PLT and GOT entries for local STT_GNU_IFUNC symbols.  */
   htab_traverse (htab->loc_hash_table,
-                 (void *) elfNN_loongarch_finish_local_dynamic_symbol, info);
+		 (void *) elfNN_loongarch_finish_local_dynamic_symbol, info);
 
   return true;
 }
@@ -2863,15 +2864,15 @@ loongarch_elf_finish_dynamic_sections (bfd *output_bfd,
 
 static bfd_vma
 loongarch_elf_plt_sym_val (bfd_vma i, const asection *plt,
-                           const arelent *rel ATTRIBUTE_UNUSED)
+			   const arelent *rel ATTRIBUTE_UNUSED)
 {
   return plt->vma + PLT_HEADER_SIZE + i * PLT_ENTRY_SIZE;
 }
 
 static enum elf_reloc_type_class
 loongarch_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
-                            const asection *rel_sec ATTRIBUTE_UNUSED,
-                            const Elf_Internal_Rela *rela)
+			    const asection *rel_sec ATTRIBUTE_UNUSED,
+			    const Elf_Internal_Rela *rela)
 {
   struct loongarch_elf_link_hash_table *htab;
   htab = loongarch_elf_hash_table (info);
@@ -2879,27 +2880,27 @@ loongarch_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
   if (htab->elf.dynsym != NULL && htab->elf.dynsym->contents != NULL)
     {
       /* Check relocation against STT_GNU_IFUNC symbol if there are
-         dynamic symbols. */
+	 dynamic symbols.  */
       bfd *abfd = info->output_bfd;
       const struct elf_backend_data *bed = get_elf_backend_data (abfd);
       unsigned long r_symndx = ELFNN_R_SYM (rela->r_info);
       if (r_symndx != STN_UNDEF)
-        {
-          Elf_Internal_Sym sym;
-          if (!bed->s->swap_symbol_in (abfd,
-                                       htab->elf.dynsym->contents +
-                                         r_symndx * bed->s->sizeof_sym,
-                                       0, &sym))
-            {
-              /* xgettext:c-format */
-              _bfd_error_handler (_ ("%pB symbol number %lu references"
-                                     " nonexistent SHT_SYMTAB_SHNDX section"),
-                                  abfd, r_symndx);
-              /* Ideally an error class should be returned here.  */
-            }
-          else if (ELF_ST_TYPE (sym.st_info) == STT_GNU_IFUNC)
-            return reloc_class_ifunc;
-        }
+	{
+	  Elf_Internal_Sym sym;
+	  if (!bed->s->swap_symbol_in (abfd,
+				       htab->elf.dynsym->contents
+				       + r_symndx * bed->s->sizeof_sym,
+				       0, &sym))
+	    {
+	      /* xgettext:c-format  */
+	      _bfd_error_handler (_ ("%pB symbol number %lu references"
+				     " nonexistent SHT_SYMTAB_SHNDX section"),
+				  abfd, r_symndx);
+	      /* Ideally an error class should be returned here.  */
+	    }
+	  else if (ELF_ST_TYPE (sym.st_info) == STT_GNU_IFUNC)
+	    return reloc_class_ifunc;
+	}
     }
 
   switch (ELFNN_R_TYPE (rela->r_info))
@@ -2921,8 +2922,8 @@ loongarch_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
 
 static void
 loongarch_elf_copy_indirect_symbol (struct bfd_link_info *info,
-                                    struct elf_link_hash_entry *dir,
-                                    struct elf_link_hash_entry *ind)
+				    struct elf_link_hash_entry *dir,
+				    struct elf_link_hash_entry *ind)
 {
   struct loongarch_elf_link_hash_entry *edir, *eind;
 
@@ -2932,29 +2933,29 @@ loongarch_elf_copy_indirect_symbol (struct bfd_link_info *info,
   if (eind->dyn_relocs != NULL)
     {
       if (edir->dyn_relocs != NULL)
-        {
-          struct elf_dyn_relocs **pp;
-          struct elf_dyn_relocs *p;
-
-          /* Add reloc counts against the indirect sym to the direct sym
-             list.  Merge any entries against the same section.  */
-          for (pp = &eind->dyn_relocs; (p = *pp) != NULL;)
-            {
-              struct elf_dyn_relocs *q;
-
-              for (q = edir->dyn_relocs; q != NULL; q = q->next)
-                if (q->sec == p->sec)
-                  {
-                    q->pc_count += p->pc_count;
-                    q->count += p->count;
-                    *pp = p->next;
-                    break;
-                  }
-              if (q == NULL)
-                pp = &p->next;
-            }
-          *pp = edir->dyn_relocs;
-        }
+	{
+	  struct elf_dyn_relocs **pp;
+	  struct elf_dyn_relocs *p;
+
+	  /* Add reloc counts against the indirect sym to the direct sym
+	     list.  Merge any entries against the same section.  */
+	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL;)
+	    {
+	      struct elf_dyn_relocs *q;
+
+	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
+		if (q->sec == p->sec)
+		  {
+		    q->pc_count += p->pc_count;
+		    q->count += p->count;
+		    *pp = p->next;
+		    break;
+		  }
+	      if (q == NULL)
+		pp = &p->next;
+	    }
+	  *pp = edir->dyn_relocs;
+	}
 
       edir->dyn_relocs = eind->dyn_relocs;
       eind->dyn_relocs = NULL;
@@ -2980,20 +2981,20 @@ loongarch_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
 
     case sizeof (
       prstatus_t): /* The sizeof(struct elf_prstatus) on Linux/Loongarch.  */
-      /* pr_cursig */
+      /* pr_cursig  */
       elf_tdata (abfd)->core->signal =
-        bfd_get_16 (abfd, note->descdata + offsetof (prstatus_t, pr_cursig));
+	bfd_get_16 (abfd, note->descdata + offsetof (prstatus_t, pr_cursig));
 
-      /* pr_pid */
+      /* pr_pid  */
       elf_tdata (abfd)->core->lwpid =
-        bfd_get_32 (abfd, note->descdata + offsetof (prstatus_t, pr_pid));
+	bfd_get_32 (abfd, note->descdata + offsetof (prstatus_t, pr_pid));
       break;
     }
 
   /* Make a ".reg/999" section.  */
   return _bfd_elfcore_make_pseudosection (abfd, ".reg", sizeof (elf_gregset_t),
-                                          note->descpos +
-                                            offsetof (prstatus_t, pr_reg));
+					  note->descpos
+					  + offsetof (prstatus_t, pr_reg));
 }
 
 static bool
@@ -3006,19 +3007,19 @@ loongarch_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
 
     case sizeof (
       prpsinfo_t): /* sizeof(struct elf_prpsinfo) on Linux/Loongarch.  */
-      /* pr_pid */
+      /* pr_pid  */
       elf_tdata (abfd)->core->pid =
-        bfd_get_32 (abfd, note->descdata + offsetof (prpsinfo_t, pr_pid));
+	bfd_get_32 (abfd, note->descdata + offsetof (prpsinfo_t, pr_pid));
 
-      /* pr_fname */
+      /* pr_fname  */
       elf_tdata (abfd)->core->program = _bfd_elfcore_strndup (
-        abfd, note->descdata + offsetof (prpsinfo_t, pr_fname),
-        sizeof (((prpsinfo_t *) 0)->pr_fname));
+	abfd, note->descdata + offsetof (prpsinfo_t, pr_fname),
+	sizeof (((prpsinfo_t *) 0)->pr_fname));
 
-      /* pr_psargs */
+      /* pr_psargs  */
       elf_tdata (abfd)->core->command = _bfd_elfcore_strndup (
-        abfd, note->descdata + offsetof (prpsinfo_t, pr_psargs),
-        sizeof (((prpsinfo_t *) 0)->pr_psargs));
+	abfd, note->descdata + offsetof (prpsinfo_t, pr_psargs),
+	sizeof (((prpsinfo_t *) 0)->pr_psargs));
       break;
     }
 
@@ -3051,16 +3052,16 @@ loongarch_elf_object_p (bfd *abfd)
 
 static asection *
 loongarch_elf_gc_mark_hook (asection *sec, struct bfd_link_info *info,
-                            Elf_Internal_Rela *rel,
-                            struct elf_link_hash_entry *h,
-                            Elf_Internal_Sym *sym)
+			    Elf_Internal_Rela *rel,
+			    struct elf_link_hash_entry *h,
+			    Elf_Internal_Sym *sym)
 {
   if (h != NULL)
     switch (ELFNN_R_TYPE (rel->r_info))
       {
       case R_LARCH_GNU_VTINHERIT:
       case R_LARCH_GNU_VTENTRY:
-        return NULL;
+	return NULL;
       }
 
   return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
@@ -3068,24 +3069,24 @@ loongarch_elf_gc_mark_hook (asection *sec, struct bfd_link_info *info,
 
 static bool
 _loongarch_bfd_set_section_contents (bfd *abfd, sec_ptr section,
-                                     const void *location, file_ptr offset,
-                                     bfd_size_type conut)
+				     const void *location, file_ptr offset,
+				     bfd_size_type conut)
 
 {
   if (elf_elfheader (abfd)->e_flags == 0)
     {
       if (abfd->arch_info->arch == bfd_arch_loongarch)
-        {
-          if (abfd->arch_info->mach == bfd_mach_loongarch32)
-            elf_elfheader (abfd)->e_flags = EF_LARCH_ABI_LP32;
-          else if (abfd->arch_info->mach == bfd_mach_loongarch64)
-            elf_elfheader (abfd)->e_flags = EF_LARCH_ABI_LP64;
-          else
-            return false;
-        }
+	{
+	  if (abfd->arch_info->mach == bfd_mach_loongarch32)
+	    elf_elfheader (abfd)->e_flags = EF_LARCH_ABI_LP32;
+	  else if (abfd->arch_info->mach == bfd_mach_loongarch64)
+	    elf_elfheader (abfd)->e_flags = EF_LARCH_ABI_LP64;
+	  else
+	    return false;
+	}
     }
   return _bfd_elf_set_section_contents (abfd, section, location, offset,
-                                        conut);
+					conut);
 }
 
 #define TARGET_LITTLE_SYM loongarch_elfNN_vec
@@ -3095,26 +3096,26 @@ _loongarch_bfd_set_section_contents (bfd *abfd, sec_ptr section,
 #define ELF_MACHINE_CODE EM_LOONGARCH
 #define ELF_MAXPAGESIZE 0x4000
 #define bfd_elfNN_bfd_reloc_type_lookup loongarch_reloc_type_lookup
-#define bfd_elfNN_bfd_link_hash_table_create                                  \
+#define bfd_elfNN_bfd_link_hash_table_create				  \
   loongarch_elf_link_hash_table_create
 #define bfd_elfNN_bfd_reloc_name_lookup loongarch_reloc_name_lookup
-#define elf_info_to_howto_rel NULL /* Fall through to elf_info_to_howto. */
+#define elf_info_to_howto_rel NULL /* Fall through to elf_info_to_howto.  */
 #define elf_info_to_howto loongarch_info_to_howto_rela
-#define bfd_elfNN_bfd_merge_private_bfd_data                                  \
+#define bfd_elfNN_bfd_merge_private_bfd_data				  \
   elfNN_loongarch_merge_private_bfd_data
 
 #define bfd_elfNN_set_section_contents _loongarch_bfd_set_section_contents
 
 #define elf_backend_reloc_type_class loongarch_reloc_type_class
 #define elf_backend_copy_indirect_symbol loongarch_elf_copy_indirect_symbol
-#define elf_backend_create_dynamic_sections                                   \
+#define elf_backend_create_dynamic_sections				   \
   loongarch_elf_create_dynamic_sections
 #define elf_backend_check_relocs loongarch_elf_check_relocs
 #define elf_backend_adjust_dynamic_symbol loongarch_elf_adjust_dynamic_symbol
 #define elf_backend_size_dynamic_sections loongarch_elf_size_dynamic_sections
 #define elf_backend_relocate_section loongarch_elf_relocate_section
 #define elf_backend_finish_dynamic_symbol loongarch_elf_finish_dynamic_symbol
-#define elf_backend_finish_dynamic_sections                                   \
+#define elf_backend_finish_dynamic_sections				   \
   loongarch_elf_finish_dynamic_sections
 #define elf_backend_object_p loongarch_elf_object_p
 #define elf_backend_gc_mark_hook loongarch_elf_gc_mark_hook
diff --git a/bfd/elfxx-loongarch.c b/bfd/elfxx-loongarch.c
index 004e8de1d1e..7fc46de8854 100644
--- a/bfd/elfxx-loongarch.c
+++ b/bfd/elfxx-loongarch.c
@@ -15,7 +15,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 
 #include "sysdep.h"
@@ -30,9 +30,9 @@
 
 static reloc_howto_type howto_table[] =
 {
-#define LOONGARCH_HOWTO(r_name)                                               \
-  HOWTO (R_LARCH_##r_name, 0, 3, 32, false, 0, complain_overflow_signed,      \
-         bfd_elf_generic_reloc, "R_LARCH_" #r_name, false, 0, 0, false)
+#define LOONGARCH_HOWTO(r_name)						 \
+  HOWTO (R_LARCH_##r_name, 0, 3, 32, false, 0, complain_overflow_signed, \
+	 bfd_elf_generic_reloc, "R_LARCH_" #r_name, false, 0, 0, false)
   LOONGARCH_HOWTO (NONE),
   LOONGARCH_HOWTO (32),
   LOONGARCH_HOWTO (64),
@@ -49,19 +49,19 @@ static reloc_howto_type howto_table[] =
 
   LOONGARCH_HOWTO (MARK_LA),
   LOONGARCH_HOWTO (MARK_PCREL),
-  HOWTO (R_LARCH_SOP_PUSH_PCREL,              /* type */
-         2,                                   /* rightshift */
-         3,                                   /* size */
-         32,                                  /* bitsize */
-         true /* FIXME: somewhat use this */, /* pc_relative */
-         0,                                   /* bitpos */
-         complain_overflow_signed,            /* complain_on_overflow */
-         bfd_elf_generic_reloc,               /* special_function */
-         "R_LARCH_SOP_PUSH_PCREL",            /* name */
-         false,                               /* partial_inplace */
-         0x03ffffff,                          /* src_mask */
-         0x03ffffff,                          /* dst_mask */
-         false),                              /* pcrel_offset */
+  HOWTO (R_LARCH_SOP_PUSH_PCREL,	      	/* type.  */
+	 2,				   	/* rightshift.  */
+	 3,				   	/* size.  */
+	 32,				  	/* bitsize.  */
+	 true /* FIXME: somewhat use this.  */,	/* pc_relative.  */
+	 0,				   	/* bitpos.  */
+	 complain_overflow_signed,	    	/* complain_on_overflow.  */
+	 bfd_elf_generic_reloc,	       		/* special_function.  */
+	 "R_LARCH_SOP_PUSH_PCREL",	    	/* name.  */
+	 false,			       		/* partial_inplace.  */
+	 0x03ffffff,			  	/* src_mask.  */
+	 0x03ffffff,			  	/* dst_mask.  */
+	 false),			      	/* pcrel_offset.  */
   LOONGARCH_HOWTO (SOP_PUSH_ABSOLUTE),
   LOONGARCH_HOWTO (SOP_PUSH_DUP),
   LOONGARCH_HOWTO (SOP_PUSH_GPREL),
@@ -110,9 +110,9 @@ static const struct elf_reloc_map larch_reloc_map[] =
   { BFD_RELOC_32, R_LARCH_32 },
   { BFD_RELOC_64, R_LARCH_64 },
 
-#define LOONGARCH_reloc_map(r_name)                                           \
-  {                                                                           \
-    BFD_RELOC_LARCH_##r_name, R_LARCH_##r_name                                \
+#define LOONGARCH_reloc_map(r_name)		   	\
+  {						  	\
+    BFD_RELOC_LARCH_##r_name, R_LARCH_##r_name		\
   }
   LOONGARCH_reloc_map (TLS_DTPMOD32),
   LOONGARCH_reloc_map (TLS_DTPMOD64),
@@ -172,7 +172,7 @@ loongarch_elf_rtype_to_howto (unsigned int r_type)
 
 reloc_howto_type *
 loongarch_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
-                             bfd_reloc_code_real_type code)
+			     bfd_reloc_code_real_type code)
 {
   unsigned int i;
   for (i = 0; i < ARRAY_SIZE (larch_reloc_map); i++)
diff --git a/bfd/elfxx-loongarch.h b/bfd/elfxx-loongarch.h
index c47c57fa514..375f1827013 100644
--- a/bfd/elfxx-loongarch.h
+++ b/bfd/elfxx-loongarch.h
@@ -15,7 +15,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 
 #include "elf/common.h"
diff --git a/gas/config/loongarch-lex-wrapper.c b/gas/config/loongarch-lex-wrapper.c
index e11a3d1e844..2d7509b1b20 100644
--- a/gas/config/loongarch-lex-wrapper.c
+++ b/gas/config/loongarch-lex-wrapper.c
@@ -13,7 +13,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 
 #include "sysdep.h"
diff --git a/gas/config/loongarch-lex.l b/gas/config/loongarch-lex.l
index 3adda5eeec3..b6397726e79 100644
--- a/gas/config/loongarch-lex.l
+++ b/gas/config/loongarch-lex.l
@@ -15,7 +15,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 %{
 #include "as.h"
diff --git a/gas/config/loongarch-parse.y b/gas/config/loongarch-parse.y
index 2188b437be0..99929a26c4d 100644
--- a/gas/config/loongarch-parse.y
+++ b/gas/config/loongarch-parse.y
@@ -14,12 +14,14 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 %{
 #include "as.h"
 #include "loongarch-parse.h"
-static void yyerror (const char *s ATTRIBUTE_UNUSED){};
+static void yyerror (const char *s ATTRIBUTE_UNUSED)
+{
+};
 extern int yylex (void);
 extern void yy_scan_string (const char *);
 extern void
@@ -45,10 +47,10 @@ is_const (struct reloc_info *info)
 
 int
 loongarch_parse_expr (const char *expr,
-                      struct reloc_info *reloc_stack_top,
-                      size_t max_reloc_num,
-                      size_t *reloc_num,
-                      offsetT *imm);
+		      struct reloc_info *reloc_stack_top,
+		      size_t max_reloc_num,
+		      size_t *reloc_num,
+		      offsetT *imm);
 
 int
 loongarch_parse_expr (const char *expr,
diff --git a/gas/config/tc-loongarch.c b/gas/config/tc-loongarch.c
index 690f1875447..baaa6cb4c3d 100644
--- a/gas/config/tc-loongarch.c
+++ b/gas/config/tc-loongarch.c
@@ -16,7 +16,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 
 #include "as.h"
@@ -29,17 +29,17 @@
 #include <stdio.h>
 #include <assert.h>
 
-/* All information about an instruction during assemble */
+/* All information about an instruction during assemble.  */
 struct loongarch_cl_insn
 {
-  /* First split string */
+  /* First split string.  */
   const char *name;
   const char *arg_strs[MAX_ARG_NUM_PLUS_2];
   size_t arg_num;
 
   /* Second analyze name_str and each actual args string to match the insn
      in 'loongarch-opc.c'. And actual args may need be relocated.
-     We get length of insn. If 'insn_length == 0 && insn_mo->macro != NULL',
+     We get length of insn.  If 'insn_length == 0 && insn_mo->macro != NULL',
      it's a macro insntruction and we call 'md_assemble' recursively
      after expanding it.  */
   int match_now;
@@ -52,14 +52,14 @@ struct loongarch_cl_insn
   struct reloc_info reloc_info[MAX_RELOC_NUMBER_A_INSN];
   size_t reloc_num;
 
-  /* For relax reserved. We not support relax now.
+  /* For relax reserved.  We not support relax now.
      'insn_length < relax_max_length' means need to relax.
-     And 'insn_length == relax_max_length' means no need to relax. */
+     And 'insn_length == relax_max_length' means no need to relax.  */
   size_t relax_max_length;
   relax_substateT subtype;
 
   /* Then we get the binary representation of insn
-     and write it in to section. */
+     and write it in to section.  */
   insn_t insn_bin;
 
   /* The frag that contains the instruction.  */
@@ -71,12 +71,12 @@ struct loongarch_cl_insn
 };
 
 /* This array holds the chars that always start a comment.  If the
-   pre-processor is disabled, these aren't very useful */
+   pre-processor is disabled, these aren't very useful.  */
 const char comment_chars[] = "#";
 
 /* This array holds the chars that only start a comment at the beginning of
    a line.  If the line seems to have the form '# 123 filename'
-   .line and .file directives will appear in the pre-processed output */
+   .line and .file directives will appear in the pre-processed output.  */
 /* Note that input_file.c hand checks for '#' at the beginning of the
    first line of the input file.  This is because the compiler outputs
 #NO_APP at the beginning of its output.  */
@@ -86,12 +86,12 @@ const char line_comment_chars[] = "#";
 /* This array holds machine specific line separator characters.  */
 const char line_separator_chars[] = ";";
 
-/* Chars that can be used to separate mant from exp in floating point nums */
+/* Chars that can be used to separate mant from exp in floating point nums.  */
 const char EXP_CHARS[] = "eE";
 
-/* Chars that mean this number is a floating point constant */
-/* As in 0f12.456 */
-/* or    0d1.2345e12 */
+/* Chars that mean this number is a floating point constant.  */
+/* As in 0f12.456.  */
+/* or    0d1.2345e12.  */
 const char FLT_CHARS[] = "rRsSfFdDxXpP";
 
 const char *md_shortopts = "O::g::G:";
@@ -271,7 +271,8 @@ md_begin ()
 	  }
     }
 
-  /* FIXME: expressionS use 'offsetT' as constant, we want this is 64-bit type */
+  /* FIXME: expressionS use 'offsetT' as constant,
+   * we want this is 64-bit type */
   assert (8 <= sizeof (offsetT));
 }
 
@@ -584,8 +585,8 @@ loongarch_args_parser_can_match_arg_helper (char esc_ch1, char esc_ch2,
       bits_needed_s = loongarch_bits_imm_needed (imm, 1);
       bits_needed_u = loongarch_bits_imm_needed (imm, 0);
 
-      if ((esc_ch1 == 's' && bit_width < bits_needed_s) ||
-	  (esc_ch1 != 's' && bit_width < bits_needed_u))
+      if ((esc_ch1 == 's' && bit_width < bits_needed_s)
+	  || (esc_ch1 != 's' && bit_width < bits_needed_u))
 	/* How to do after we detect overflow.  */
 	as_fatal (_ ("Immediate overflow.\n"
 		     "format: %c%c%s\n"
@@ -609,8 +610,8 @@ get_loongarch_opcode (struct loongarch_cl_insn *insn)
   struct loongarch_ase *ase;
   for (ase = loongarch_ASEs; ase->enabled; ase++)
     {
-      if (!*ase->enabled || (ase->include && !*ase->include) ||
-	  (ase->exclude && *ase->exclude))
+      if (!*ase->enabled || (ase->include && !*ase->include)
+	  || (ase->exclude && *ase->exclude))
 	continue;
 
       if (!ase->name_hash_entry)
@@ -663,7 +664,7 @@ check_this_insn_before_appending (struct loongarch_cl_insn *ip)
 	   /* ammin_db.wu  rd, rk, rj  */
 	       || (ip->insn_bin & 0xffff0000) == 0x38710000))
     {
-      /* For AMO insn amswap.[wd], amadd.[wd], etc. */
+      /* For AMO insn amswap.[wd], amadd.[wd], etc.  */
       if (ip->args[0] != 0
 	  && (ip->args[0] == ip->args[1] || ip->args[0] == ip->args[2]))
 	as_fatal (
@@ -744,7 +745,7 @@ append_fixp_and_insn (struct loongarch_cl_insn *ip)
   dwarf2_emit_insn (0);
 }
 
-/* Ask helper for returning a malloced c_str or NULL. */
+/* Ask helper for returning a malloced c_str or NULL.  */
 static char *
 assember_macro_helper (const char *const args[], void *context_ptr)
 {
@@ -1015,8 +1016,9 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 	  && (stack_top & ~(uint64_t) 0xfffff) != ~(uint64_t) 0xfffff)
 	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
       insn = bfd_getl32 (buf);
-      insn = (insn & 0xfc0003e0) | ((stack_top & 0xffff) << 10) |
-	     ((stack_top & 0x1f0000) >> 16);
+      insn = (insn & 0xfc0003e0)
+	     | ((stack_top & 0xffff) << 10)
+	     | ((stack_top & 0x1f0000) >> 16);
       bfd_putl32 (insn, buf);
       break;
 
@@ -1041,8 +1043,9 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 	  && (stack_top & ~(uint64_t) 0x1ffffff) != ~(uint64_t) 0x1ffffff)
 	as_warn_where (fixP->fx_file, fixP->fx_line, "Reloc overflow");
       insn = bfd_getl32 (buf);
-      insn = (insn & 0xfc000000) | ((stack_top & 0xffff) << 10) |
-	     ((stack_top & 0x3ff0000) >> 16);
+      insn = (insn & 0xfc000000)
+	     | ((stack_top & 0xffff) << 10)
+	     | ((stack_top & 0x3ff0000) >> 16);
       bfd_putl32 (insn, buf);
       break;
 
@@ -1210,7 +1213,7 @@ loongarch_handle_align (fragS *fragp)
   gas_assert (excess < 4);
   fragp->fr_fix += excess;
 
-  while(excess-- != 0)
+  while (excess-- != 0)
     *p++ = 0;
 
   md_number_to_chars (p, opcode, size);
diff --git a/gas/config/tc-loongarch.h b/gas/config/tc-loongarch.h
index e385836d238..f8e76cee5cf 100644
--- a/gas/config/tc-loongarch.h
+++ b/gas/config/tc-loongarch.h
@@ -15,7 +15,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 
 #ifndef TC_LOONGARCH
@@ -27,7 +27,7 @@
 #define WORKING_DOT_WORD 1
 #define REPEAT_CONS_EXPRESSIONS
 
-/* Early than md_begin. */
+/* Early than md_begin.  */
 #define md_after_parse_args loongarch_after_parse_args
 extern void loongarch_after_parse_args (void);
 
@@ -37,7 +37,7 @@ extern void loongarch_pop_insert (void);
 #define TARGET_FORMAT loongarch_target_format ()
 extern const char *loongarch_target_format (void);
 
-#define md_relax_frag(segment, fragp, stretch)                                \
+#define md_relax_frag(segment, fragp, stretch)	\
   loongarch_relax_frag (segment, fragp, stretch)
 extern int loongarch_relax_frag (asection *, struct frag *, long);
 #define md_section_align(seg, size) (size)
@@ -53,23 +53,23 @@ extern int loongarch_relax_frag (asection *, struct frag *, long);
 #define DIFF_EXPR_OK 1
 
 #define TARGET_USE_CFIPOP 1
-#define DWARF2_DEFAULT_RETURN_COLUMN 1 /* $ra */
+#define DWARF2_DEFAULT_RETURN_COLUMN 1 /* $ra.  */
 #define DWARF2_CIE_DATA_ALIGNMENT -4
 extern int loongarch_dwarf2_addr_size (void);
 #define DWARF2_FDE_RELOC_SIZE loongarch_dwarf2_addr_size ()
 #define DWARF2_ADDR_SIZE(bfd) loongarch_dwarf2_addr_size ()
 #define CFI_DIFF_EXPR_OK 0
 
-#define tc_cfi_frame_initial_instructions                                     \
+#define tc_cfi_frame_initial_instructions	\
   loongarch_cfi_frame_initial_instructions
 extern void loongarch_cfi_frame_initial_instructions (void);
 
-/* #define tc_regname_to_dw2regnum tc_loongarch_regname_to_dw2regnum */
+/* #define tc_regname_to_dw2regnum tc_loongarch_regname_to_dw2regnum  */
 #define tc_parse_to_dw2regnum tc_loongarch_parse_to_dw2regnum
 extern void tc_loongarch_parse_to_dw2regnum (expressionS *);
 
-/* A enumerated values to specific how to deal with align in '.text'. */
-/* Now we want to fill 'andi $r0,$r0,0x0'. */
+/* A enumerated values to specific how to deal with align in '.text'.  */
+/* Now we want to fill 'andi $r0,$r0,0x0'.  */
 #define loongarch_nop_opcode() 0
 #define NOP_OPCODE (loongarch_nop_opcode ())
 
diff --git a/include/elf/loongarch.h b/include/elf/loongarch.h
index d701813416d..91e8c4e53ae 100644
--- a/include/elf/loongarch.h
+++ b/include/elf/loongarch.h
@@ -14,7 +14,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 
 #ifndef _ELF_LOONGARCH_H
@@ -24,7 +24,7 @@
 #include "libiberty.h"
 
 START_RELOC_NUMBERS (elf_loongarch_reloc_type)
-/* Used by the dynamic linker. */
+/* Used by the dynamic linker.  */
 RELOC_NUMBER (R_LARCH_NONE, 0)
 RELOC_NUMBER (R_LARCH_32, 1)
 RELOC_NUMBER (R_LARCH_64, 2)
@@ -41,7 +41,7 @@ RELOC_NUMBER (R_LARCH_IRELATIVE, 12)
 
 /* Reserved for future relocs that the dynamic linker must understand.  */
 
-/* Used by the static linker for relocating .text. */
+/* Used by the static linker for relocating .text.  */
 RELOC_NUMBER (R_LARCH_MARK_LA, 20)
 RELOC_NUMBER (R_LARCH_MARK_PCREL, 21)
 
@@ -74,7 +74,7 @@ RELOC_NUMBER (R_LARCH_SOP_POP_32_S_0_5_10_16_S2, 44)
 RELOC_NUMBER (R_LARCH_SOP_POP_32_S_0_10_10_16_S2, 45)
 RELOC_NUMBER (R_LARCH_SOP_POP_32_U, 46)
 
-/* Used by the static linker for relocating non .text. */
+/* Used by the static linker for relocating non .text.  */
 RELOC_NUMBER (R_LARCH_ADD8, 47)
 RELOC_NUMBER (R_LARCH_ADD16, 48)
 RELOC_NUMBER (R_LARCH_ADD24, 49)
@@ -86,7 +86,7 @@ RELOC_NUMBER (R_LARCH_SUB24, 54)
 RELOC_NUMBER (R_LARCH_SUB32, 55)
 RELOC_NUMBER (R_LARCH_SUB64, 56)
 
-/* I don't know what it is. Existing in almost all other arch */
+/* I don't know what it is.  Existing in almost all other arch.  */
 RELOC_NUMBER (R_LARCH_GNU_VTINHERIT, 57)
 RELOC_NUMBER (R_LARCH_GNU_VTENTRY, 58)
 
diff --git a/include/opcode/loongarch.h b/include/opcode/loongarch.h
index 00a8ee5b2f0..b7fe8dd8373 100644
--- a/include/opcode/loongarch.h
+++ b/include/opcode/loongarch.h
@@ -16,7 +16,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 
 #ifndef _LOONGARCH_H_
@@ -33,12 +33,11 @@ extern "C"
   struct loongarch_opcode
   {
     const insn_t match;
-    const insn_t mask; /* High 1 byte is main opcode and it must be 0xf. */
+    const insn_t mask; /* High 1 byte is main opcode and it must be 0xf.  */
 #define LARCH_INSN_OPC(insn) ((insn & 0xf0000000) >> 28)
     const char *const name;
 
-    /*
-     ACTUAL PARAMETER:
+    /* ACTUAL PARAMETER:
 
   // BNF with regular expression.
 args : token* end
@@ -47,7 +46,8 @@ args : token* end
 token : ','
 | '('
 | ')'
-| iden             // maybe a label (include at least one alphabet), maybe a number, maybe a expr
+| iden	     // maybe a label (include at least one alphabet),
+		      maybe a number, maybe a expr
 | regname
 
 regname : '$' iden
@@ -57,11 +57,13 @@ iden : [a-zA-Z0-9\.\+\-]+
 end : '\0'
 
 
-FORMAT: A string to describe the format of actual parameter including bit field infomation.
-For example, "r5:5,r0:5,sr10:16<<2" matches "$12,$13,12345" and "$4,$7,a_label".
-That 'sr' means the instruction may need relocate. '10:16' means bit field of instruction.
-In a 'format', every 'escape's can be replaced to 'iden' or 'regname' acrroding to its meaning.
-We fill all information needed by disassembing and assembing to 'format'.
+FORMAT: A string to describe the format of actual parameter including
+bit field infomation.  For example, "r5:5,r0:5,sr10:16<<2" matches
+"$12,$13,12345" and "$4,$7,a_label".  That 'sr' means the instruction
+may need relocate. '10:16' means bit field of instruction.
+In a 'format', every 'escape's can be replaced to 'iden' or 'regname'
+acrroding to its meaning.  We fill all information needed by
+disassembing and assembing to 'format'.
 
   // BNF with regular expression.
 format : escape (literal+ escape)* literal* end
@@ -69,7 +71,8 @@ format : escape (literal+ escape)* literal* end
 
 end : '\0'       // Get here means parse end.
 
-  // The intersection between any two among FIRST (end), FIRST (literal) and FIRST (escape) must be empty.
+  // The intersection between any two among FIRST (end), FIRST
+     (literal) and FIRST (escape) must be empty.
   // So we can build a simple parser.
 literal : ','
 | '('
@@ -82,7 +85,8 @@ escape : esc_ch bit_field '<' '<' dec2
 
   // '|' means to concatenate nonadjacent bit fields
   // For example, "10:16|0:4" means
-  // "16 bits starting from the 10th bit concatenating with 4 bits starting from the 0th bit".
+  // "16 bits starting from the 10th bit concatenating with 4 bits
+     starting from the 0th bit".
   // This is to say "[25..10]||[3..0]" (little endian).
 b_field : dec2 ':' dec2
 | dec2 ':' dec2 '|' bit_field
@@ -102,9 +106,9 @@ dec2 : [1-9][0-9]?
 */
     const char *const format;
 
-    /*
-MACRO: Indicate how a macro instruction expand for assembling.
-The main is to replace the '%num'(means the 'num'th 'escape' in 'format') in 'macro' string to get the real instruction.
+    /* MACRO: Indicate how a macro instruction expand for assembling.
+The main is to replace the '%num'(means the 'num'th 'escape' in 'format')
+in 'macro' string to get the real instruction.
 
 Maybe need
 */
@@ -125,11 +129,11 @@ Maybe need
     const int *include;
     const int *exclude;
 
-    /* For disassemble to create main opcode hash table. */
+    /* For disassemble to create main opcode hash table.  */
     const struct loongarch_opcode *opc_htab[16];
     unsigned char opc_htab_inited;
 
-    /* For GAS to create hash table. */
+    /* For GAS to create hash table.  */
     struct htab *name_hash_entry;
   };
 
@@ -141,17 +145,17 @@ Maybe need
 
   extern int loongarch_get_bit_field_width (const char *bit_field, char **end);
   extern int32_t loongarch_decode_imm (const char *bit_field, insn_t insn,
-                                       int si);
+				       int si);
 
 #define MAX_ARG_NUM_PLUS_2 9
 
   extern size_t loongarch_split_args_by_comma (char *args,
-                                               const char *arg_strs[]);
+					       const char *arg_strs[]);
   extern char *loongarch_cat_splited_strs (const char *arg_strs[]);
   extern insn_t loongarch_foreach_args (
     const char *format, const char *arg_strs[],
     int32_t (*helper) (char esc1, char esc2, const char *bit_field,
-                       const char *arg, void *context),
+		       const char *arg, void *context),
     void *context);
 
   extern int loongarch_check_format (const char *format);
diff --git a/ld/emultempl/loongarchelf.em b/ld/emultempl/loongarchelf.em
index 2695f939214..8751a628306 100644
--- a/ld/emultempl/loongarchelf.em
+++ b/ld/emultempl/loongarchelf.em
@@ -74,12 +74,8 @@ larch_create_output_section_statements (void)
   /* See PR 22920 for an example of why this is necessary.  */
   if (strstr (bfd_get_target (link_info.output_bfd), "loong") == NULL)
     {
-      /* The RISC-V backend needs special fields in the output hash structure.
-	 These will only be created if the output format is a RISC-V format,
-	 hence we do not support linking and changing output formats at the
-	 same time.  Use a link followed by objcopy to change output formats.  */
       einfo (_("%F%P: error: cannot change output format"
-	       " whilst linking %s binaries\n"), "RISC-V");
+	       " whilst linking %s binaries\n"), "LoongArch");
       return;
     }
 }
diff --git a/opcodes/loongarch-coder.c b/opcodes/loongarch-coder.c
index c8292ee4472..9e3c45dc7bc 100644
--- a/opcodes/loongarch-coder.c
+++ b/opcodes/loongarch-coder.c
@@ -15,7 +15,7 @@
    License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 #include "sysdep.h"
 #include "opcode/loongarch.h"
@@ -26,10 +26,10 @@ is_unsigned (const char *c_str)
   if (c_str[0] == '0' && (c_str[1] == 'x' || c_str[1] == 'X'))
     {
       c_str += 2;
-      while (('a' <= *c_str && *c_str <= 'f') ||
-             ('A' <= *c_str && *c_str <= 'F') ||
-             ('0' <= *c_str && *c_str <= '9'))
-        c_str++;
+      while (('a' <= *c_str && *c_str <= 'f')
+	     || ('A' <= *c_str && *c_str <= 'F')
+	     || ('0' <= *c_str && *c_str <= '9'))
+	c_str++;
     }
   else if (*c_str == '\0')
     return 0;
@@ -51,14 +51,14 @@ is_internal_label (const char *c_str)
   do
     {
       if (*c_str != ':')
-        break;
+	break;
       c_str++;
       if (!('0' <= *c_str && *c_str <= '9'))
-        break;
+	break;
       while ('0' <= *c_str && *c_str <= '9')
-        c_str++;
+	c_str++;
       if (*c_str != 'b' && *c_str != 'f')
-        break;
+	break;
       c_str++;
       return *c_str == '\0';
     }
@@ -73,21 +73,25 @@ is_label (const char *c_str)
     return 1;
   else if ('0' <= *c_str && *c_str <= '9')
     {
-      /* [0-9]+[bf] */
+      /* [0-9]+[bf]  */
       while ('0' <= *c_str && *c_str <= '9')
-        c_str++;
+	c_str++;
       return *c_str == 'b' || *c_str == 'f';
     }
-  else if (('a' <= *c_str && *c_str <= 'z') ||
-           ('A' <= *c_str && *c_str <= 'Z') || *c_str == '.' ||
-           *c_str == '_' || *c_str == '$')
+  else if (('a' <= *c_str && *c_str <= 'z')
+	   || ('A' <= *c_str && *c_str <= 'Z')
+	   || *c_str == '.'
+	   || *c_str == '_'
+	   || *c_str == '$')
     {
-      /* [a-zA-Z\._\$][0-9a-zA-Z\._\$]* */
-      while (('a' <= *c_str && *c_str <= 'z') ||
-             ('A' <= *c_str && *c_str <= 'Z') ||
-             ('0' <= *c_str && *c_str <= '9') || *c_str == '.' ||
-             *c_str == '_' || *c_str == '$')
-        c_str++;
+      /* [a-zA-Z\._\$][0-9a-zA-Z\._\$]*  */
+      while (('a' <= *c_str && *c_str <= 'z')
+	     || ('A' <= *c_str && *c_str <= 'Z')
+	     || ('0' <= *c_str && *c_str <= '9')
+	     || *c_str == '.'
+	     || *c_str == '_'
+	     || *c_str == '$')
+	c_str++;
       return *c_str == '\0';
     }
   else
@@ -101,28 +105,34 @@ is_label_with_addend (const char *c_str)
     return 1;
   else if ('0' <= *c_str && *c_str <= '9')
     {
-      /* [0-9]+[bf] */
+      /* [0-9]+[bf]  */
       while ('0' <= *c_str && *c_str <= '9')
-        c_str++;
+	c_str++;
       if (*c_str == 'b' || *c_str == 'f')
-        c_str++;
+	c_str++;
       else
-        return 0;
-      return *c_str == '\0' ||
-             ((*c_str == '-' || *c_str == '+') && is_unsigned (c_str + 1));
+	return 0;
+      return *c_str == '\0'
+		       || ((*c_str == '-' || *c_str == '+')
+			   && is_unsigned (c_str + 1));
     }
-  else if (('a' <= *c_str && *c_str <= 'z') ||
-           ('A' <= *c_str && *c_str <= 'Z') || *c_str == '.' ||
-           *c_str == '_' || *c_str == '$')
+  else if (('a' <= *c_str && *c_str <= 'z')
+	   || ('A' <= *c_str && *c_str <= 'Z')
+	   || *c_str == '.'
+	   || *c_str == '_'
+	   || *c_str == '$')
     {
-      /* [a-zA-Z\._\$][0-9a-zA-Z\._\$]* */
-      while (('a' <= *c_str && *c_str <= 'z') ||
-             ('A' <= *c_str && *c_str <= 'Z') ||
-             ('0' <= *c_str && *c_str <= '9') || *c_str == '.' ||
-             *c_str == '_' || *c_str == '$')
-        c_str++;
-      return *c_str == '\0' ||
-             ((*c_str == '-' || *c_str == '+') && is_unsigned (c_str + 1));
+      /* [a-zA-Z\._\$][0-9a-zA-Z\._\$]*  */
+      while (('a' <= *c_str && *c_str <= 'z')
+	     || ('A' <= *c_str && *c_str <= 'Z')
+	     || ('0' <= *c_str && *c_str <= '9')
+	     || *c_str == '.'
+	     || *c_str == '_'
+	     || *c_str == '$')
+	c_str++;
+      return *c_str == '\0'
+		       || ((*c_str == '-' || *c_str == '+')
+			   && is_unsigned (c_str + 1));
     }
   else
     return 0;
@@ -136,18 +146,18 @@ loongarch_get_bit_field_width (const char *bit_field, char **end)
   if (bit_field_1 && *bit_field_1 != '\0')
     while (1)
       {
-        strtol (bit_field_1, &bit_field_1, 10);
+	strtol (bit_field_1, &bit_field_1, 10);
 
-        if (*bit_field_1 != ':')
-          break;
-        bit_field_1++;
+	if (*bit_field_1 != ':')
+	  break;
+	bit_field_1++;
 
-        width += strtol (bit_field_1, &bit_field_1, 10);
-        has_specify = 1;
+	width += strtol (bit_field_1, &bit_field_1, 10);
+	has_specify = 1;
 
-        if (*bit_field_1 != '|')
-          break;
-        bit_field_1++;
+	if (*bit_field_1 != '|')
+	  break;
+	bit_field_1++;
       }
   if (end)
     *end = bit_field_1;
@@ -165,7 +175,7 @@ loongarch_decode_imm (const char *bit_field, insn_t insn, int si)
     {
       b_start = strtol (bit_field_1, &bit_field_1, 10);
       if (*bit_field_1 != ':')
-        break;
+	break;
       width = strtol (bit_field_1 + 1, &bit_field_1, 10);
       len += width;
 
@@ -176,7 +186,7 @@ loongarch_decode_imm (const char *bit_field, insn_t insn, int si)
       ret |= t;
 
       if (*bit_field_1 != '|')
-        break;
+	break;
       bit_field_1++;
     }
 
@@ -219,7 +229,7 @@ loongarch_encode_imm (const char *bit_field, int32_t imm)
     {
       b_start = strtol (bit_field_1, &bit_field_1, 10);
       if (*bit_field_1 != ':')
-        break;
+	break;
       width = strtol (bit_field_1 + 1, &bit_field_1, 10);
       i = imm;
       i >>= sizeof (i) * 8 - width;
@@ -228,7 +238,7 @@ loongarch_encode_imm (const char *bit_field, int32_t imm)
       imm <<= width;
 
       if (*bit_field_1 != '|')
-        break;
+	break;
       bit_field_1++;
     }
   return ret;
@@ -243,7 +253,7 @@ loongarch_encode_imm (const char *bit_field, int32_t imm)
 */
 static int
 loongarch_parse_format (const char *format, char *esc1s, char *esc2s,
-                        const char **bit_fields)
+			const char **bit_fields)
 {
   size_t arg_num = 0;
 
@@ -252,74 +262,74 @@ loongarch_parse_format (const char *format, char *esc1s, char *esc2s,
 
   while (1)
     {
-      /*        esc1    esc2
-                for "[a-zA-Z][a-zA-Z]?" */
-      if (('a' <= *format && *format <= 'z') ||
-          ('A' <= *format && *format <= 'Z'))
-        {
-          *esc1s++ = *format++;
-          if (('a' <= *format && *format <= 'z') ||
-              ('A' <= *format && *format <= 'Z'))
-            *esc2s++ = *format++;
-          else
-            *esc2s++ = '\0';
-        }
+      /* esc1    esc2
+	 for "[a-zA-Z][a-zA-Z]?"  */
+      if (('a' <= *format && *format <= 'z')
+	  || ('A' <= *format && *format <= 'Z'))
+	{
+	  *esc1s++ = *format++;
+	  if (('a' <= *format && *format <= 'z')
+	      || ('A' <= *format && *format <= 'Z'))
+	    *esc2s++ = *format++;
+	  else
+	    *esc2s++ = '\0';
+	}
       else
-        return -1;
+	return -1;
 
       arg_num++;
       if (MAX_ARG_NUM_PLUS_2 - 2 < arg_num)
-        /* Need larger MAX_ARG_NUM_PLUS_2. */
-        return -1;
+	/* Need larger MAX_ARG_NUM_PLUS_2.  */
+	return -1;
 
       *bit_fields++ = format;
 
       if ('0' <= *format && *format <= '9')
-        {
-          /* For "[0-9]+:[0-9]+(\|[0-9]+:[0-9]+)*". */
-          while (1)
-            {
-              while ('0' <= *format && *format <= '9')
-                format++;
-
-              if (*format != ':')
-                return -1;
-              format++;
-
-              if (!('0' <= *format && *format <= '9'))
-                return -1;
-              while ('0' <= *format && *format <= '9')
-                format++;
-
-              if (*format != '|')
-                break;
-              format++;
-            }
-
-          /* For "((\+|<<)[1-9][0-9]*)?". */
-          do
-            {
-              if (*format == '+')
-                format++;
-              else if (format[0] == '<' && format[1] == '<')
-                format += 2;
-              else
-                break;
-
-              if (!('1' <= *format && *format <= '9'))
-                return -1;
-              while ('0' <= *format && *format <= '9')
-                format++;
-            }
-          while (0);
-        }
+	{
+	  /* For "[0-9]+:[0-9]+(\|[0-9]+:[0-9]+)*".  */
+	  while (1)
+	    {
+	      while ('0' <= *format && *format <= '9')
+		format++;
+
+	      if (*format != ':')
+		return -1;
+	      format++;
+
+	      if (!('0' <= *format && *format <= '9'))
+		return -1;
+	      while ('0' <= *format && *format <= '9')
+		format++;
+
+	      if (*format != '|')
+		break;
+	      format++;
+	    }
+
+	  /* For "((\+|<<)[1-9][0-9]*)?".  */
+	  do
+	    {
+	      if (*format == '+')
+		format++;
+	      else if (format[0] == '<' && format[1] == '<')
+		format += 2;
+	      else
+		break;
+
+	      if (!('1' <= *format && *format <= '9'))
+		return -1;
+	      while ('0' <= *format && *format <= '9')
+		format++;
+	    }
+	  while (0);
+	}
 
       if (*format == ',')
-        format++;
+	format++;
       else if (*format == '\0')
-        break;
+	break;
       else
-        return -1;
+	return -1;
     }
 
 end:
@@ -337,10 +347,10 @@ loongarch_split_args_by_comma (char *args, const char *arg_strs[])
   for (; *args; args++)
     if (*args == ',')
       {
-        if (MAX_ARG_NUM_PLUS_2 - 1 == num)
-          break;
-        else
-          *args = '\0', arg_strs[num++] = args + 1;
+	if (MAX_ARG_NUM_PLUS_2 - 1 == num)
+	  break;
+	else
+	  *args = '\0', arg_strs[num++] = args + 1;
       }
   arg_strs[num] = NULL;
   return num;
@@ -365,10 +375,10 @@ loongarch_cat_splited_strs (const char *arg_strs[])
 
 insn_t
 loongarch_foreach_args (const char *format, const char *arg_strs[],
-                        int32_t (*helper) (char esc1, char esc2,
-                                           const char *bit_field,
-                                           const char *arg, void *context),
-                        void *context)
+			int32_t (*helper) (char esc1, char esc2,
+					   const char *bit_field,
+					   const char *arg, void *context),
+			void *context)
 {
   char esc1s[MAX_ARG_NUM_PLUS_2 - 1], esc2s[MAX_ARG_NUM_PLUS_2 - 1];
   const char *bit_fields[MAX_ARG_NUM_PLUS_2 - 1];
@@ -378,7 +388,7 @@ loongarch_foreach_args (const char *format, const char *arg_strs[],
 
   ok = loongarch_parse_format (format, esc1s, esc2s, bit_fields) == 0;
 
-  /* Make sure the num of actual args is equal to the num of escape. */
+  /* Make sure the num of actual args is equal to the num of escape.  */
   for (i = 0; esc1s[i] && arg_strs[i]; i++)
     ;
   ok = ok && !esc1s[i] && !arg_strs[i];
@@ -386,9 +396,9 @@ loongarch_foreach_args (const char *format, const char *arg_strs[],
   if (ok && helper)
     {
       for (i = 0; arg_strs[i]; i++)
-        ret |= loongarch_encode_imm (
-          bit_fields[i],
-          helper (esc1s[i], esc2s[i], bit_fields[i], arg_strs[i], context));
+	ret |= loongarch_encode_imm (
+	  bit_fields[i],
+	  helper (esc1s[i], esc2s[i], bit_fields[i], arg_strs[i], context));
       ret |= helper ('\0', '\0', NULL, NULL, context);
     }
 
@@ -414,8 +424,8 @@ loongarch_check_macro (const char *format, const char *macro)
   char esc1s[MAX_ARG_NUM_PLUS_2 - 1], esc2s[MAX_ARG_NUM_PLUS_2 - 1];
   const char *bit_fields[MAX_ARG_NUM_PLUS_2 - 1];
 
-  if (!format || !macro ||
-      loongarch_parse_format (format, esc1s, esc2s, bit_fields) != 0)
+  if (!format || !macro
+      || loongarch_parse_format (format, esc1s, esc2s, bit_fields) != 0)
     return -1;
 
   for (num_of_args = 0; esc1s[num_of_args]; num_of_args++)
@@ -424,19 +434,19 @@ loongarch_check_macro (const char *format, const char *macro)
   for (; macro[0]; macro++)
     if (macro[0] == '%')
       {
-        macro++;
-        if ('1' <= macro[0] && macro[0] <= '9')
-          {
-            if (num_of_args < macro[0] - '0')
-              /* Out of args num. */
-              return -1;
-          }
-        else if (macro[0] == 'f')
-          ;
-        else if (macro[0] == '%')
-          ;
-        else
-          return -1;
+	macro++;
+	if ('1' <= macro[0] && macro[0] <= '9')
+	  {
+	    if (num_of_args < macro[0] - '0')
+	      /* Out of args num.  */
+	      return -1;
+	  }
+	else if (macro[0] == 'f')
+	  ;
+	else if (macro[0] == '%')
+	  ;
+	else
+	  return -1;
       }
   return 0;
 }
@@ -469,28 +479,28 @@ loongarch_expand_macro_with_format_map (
   while (*src)
     if (*src == '%')
       {
-        src++;
-        if ('1' <= *src && *src <= '9')
-          {
-            size_t i = *src - '1';
-            const char *t = map (esc1s[i], esc2s[i], arg_strs[i]);
-            while (*t)
-              *dest++ = *t++;
-          }
-        else if (*src == '%')
-          *dest++ = '%';
-        else if (*src == 'f' && helper)
-          {
-            char *b, *t;
-            t = b = (*helper) (arg_strs, context);
-            if (b)
-              {
-                while (*t)
-                  *dest++ = *t++;
-                free (b);
-              }
-          }
-        src++;
+	src++;
+	if ('1' <= *src && *src <= '9')
+	  {
+	    size_t i = *src - '1';
+	    const char *t = map (esc1s[i], esc2s[i], arg_strs[i]);
+	    while (*t)
+	      *dest++ = *t++;
+	  }
+	else if (*src == '%')
+	  *dest++ = '%';
+	else if (*src == 'f' && helper)
+	  {
+	    char *b, *t;
+	    t = b = (*helper) (arg_strs, context);
+	    if (b)
+	      {
+		while (*t)
+		  *dest++ = *t++;
+		free (b);
+	      }
+	  }
+	src++;
       }
     else
       *dest++ = *src++;
@@ -501,12 +511,12 @@ loongarch_expand_macro_with_format_map (
 
 char *
 loongarch_expand_macro (const char *macro, const char *const arg_strs[],
-                        char *(*helper) (const char *const arg_strs[],
-                                         void *context),
-                        void *context)
+			char *(*helper) (const char *const arg_strs[],
+					 void *context),
+			void *context)
 {
   return loongarch_expand_macro_with_format_map (NULL, macro, arg_strs, I,
-                                                 helper, context);
+						 helper, context);
 }
 
 size_t
@@ -516,19 +526,19 @@ loongarch_bits_imm_needed (int64_t imm, int si)
   if (si)
     {
       if (imm < 0)
-        {
-          for (ret = 0; imm < 0; imm <<= 1, ret++)
-            ;
-          ret = 64 - ret + 1;
-        }
+	{
+	  for (ret = 0; imm < 0; imm <<= 1, ret++)
+	    ;
+	  ret = 64 - ret + 1;
+	}
       else
-        ret = loongarch_bits_imm_needed (imm, 0) + 1;
+	ret = loongarch_bits_imm_needed (imm, 0) + 1;
     }
   else
     {
       uint64_t t = imm;
       for (ret = 0; t; t >>= 1, ret++)
-        ;
+	;
     }
   return ret;
 }
@@ -542,7 +552,7 @@ loongarch_eliminate_adjacent_repeat_char (char *dest, char c)
   while (*dest)
     {
       while (src[0] == c && src[0] == src[1])
-        src++;
+	src++;
       *dest++ = *src++;
     }
 }
diff --git a/opcodes/loongarch-dis.c b/opcodes/loongarch-dis.c
index e91e52af442..0bce27c038e 100644
--- a/opcodes/loongarch-dis.c
+++ b/opcodes/loongarch-dis.c
@@ -15,7 +15,7 @@
    License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 
 #include "sysdep.h"
@@ -33,27 +33,28 @@ get_loongarch_opcode_by_binfmt (insn_t insn)
   size_t i;
   for (ase = loongarch_ASEs; ase->enabled; ase++)
     {
-      if (!*ase->enabled || (ase->include && !*ase->include) ||
-          (ase->exclude && *ase->exclude))
-        continue;
+      if (!*ase->enabled || (ase->include && !*ase->include)
+	  || (ase->exclude && *ase->exclude))
+	continue;
 
       if (!ase->opc_htab_inited)
-        {
-          for (it = ase->opcodes; it->mask; it++)
-            if (!ase->opc_htab[LARCH_INSN_OPC (it->match)] &&
-                it->macro == NULL)
-              ase->opc_htab[LARCH_INSN_OPC (it->match)] = it;
-          for (i = 0; i < 16; i++)
-            if (!ase->opc_htab[i])
-              ase->opc_htab[i] = it;
-          ase->opc_htab_inited = 1;
-        }
+	{
+	  for (it = ase->opcodes; it->mask; it++)
+	    if (!ase->opc_htab[LARCH_INSN_OPC (it->match)]
+		&& it->macro == NULL)
+	      ase->opc_htab[LARCH_INSN_OPC (it->match)] = it;
+	  for (i = 0; i < 16; i++)
+	    if (!ase->opc_htab[i])
+	      ase->opc_htab[i] = it;
+	  ase->opc_htab_inited = 1;
+	}
 
       it = ase->opc_htab[LARCH_INSN_OPC (insn)];
       for (; it->name; it++)
-        if ((insn & it->mask) == it->match && it->mask &&
-            !(it->include && !*it->include) && !(it->exclude && *it->exclude))
-          return it;
+	if ((insn & it->mask) == it->match && it->mask
+	    && !(it->include && !*it->include)
+	    && !(it->exclude && *it->exclude))
+	  return it;
     }
   return NULL;
 }
@@ -102,23 +103,23 @@ parse_loongarch_dis_options (const char *opts_in)
     return 0;
 
   char *opts, *opt, *opt_end;
-  opts = xmalloc(strlen(opts_in) + 1);
+  opts = xmalloc (strlen (opts_in) + 1);
   strcpy (opts, opts_in);
 
   for (opt = opt_end = opts; opt_end != NULL; opt = opt_end + 1)
     {
       if ((opt_end = strchr (opt, ',')) != NULL)
-        *opt_end = 0;
+	*opt_end = 0;
       if (parse_loongarch_dis_option (opt) != 0)
-        return -1;
+	return -1;
     }
-  free(opts);
+  free (opts);
   return 0;
 }
 
 static int32_t
 dis_one_arg (char esc1, char esc2, const char *bit_field,
-             const char *arg ATTRIBUTE_UNUSED, void *context)
+	     const char *arg ATTRIBUTE_UNUSED, void *context)
 {
   static int need_comma = 0;
   struct disassemble_info *info = context;
@@ -128,7 +129,7 @@ dis_one_arg (char esc1, char esc2, const char *bit_field,
   if (esc1)
     {
       if (need_comma)
-        info->fprintf_func (info->stream, ", ");
+	info->fprintf_func (info->stream, ", ");
       need_comma = 1;
       imm = loongarch_decode_imm (bit_field, insn, 1);
       u_imm = loongarch_decode_imm (bit_field, insn, 0);
@@ -144,13 +145,13 @@ dis_one_arg (char esc1, char esc2, const char *bit_field,
       break;
     case 'c':
       switch (esc2)
-        {
-        case 'r':
-          info->fprintf_func (info->stream, "%s", loongarch_cr_disname[u_imm]);
-          break;
-        default:
-          info->fprintf_func (info->stream, "%s", loongarch_c_disname[u_imm]);
-        }
+	{
+	case 'r':
+	  info->fprintf_func (info->stream, "%s", loongarch_cr_disname[u_imm]);
+	  break;
+	default:
+	  info->fprintf_func (info->stream, "%s", loongarch_c_disname[u_imm]);
+	}
       break;
     case 'v':
       info->fprintf_func (info->stream, "%s", loongarch_v_disname[u_imm]);
@@ -163,15 +164,15 @@ dis_one_arg (char esc1, char esc2, const char *bit_field,
       break;
     case 's':
       if (imm == 0)
-        info->fprintf_func (info->stream, "%d", imm);
+	info->fprintf_func (info->stream, "%d", imm);
       else
-        info->fprintf_func (info->stream, "%d(0x%x)", imm, u_imm);
+	info->fprintf_func (info->stream, "%d(0x%x)", imm, u_imm);
       switch (esc2)
-        {
-        case 'b':
-          info->insn_type = dis_branch;
-          info->target += imm;
-        }
+	{
+	case 'b':
+	  info->insn_type = dis_branch;
+	  info->target += imm;
+	}
       break;
     case '\0':
       need_comma = 0;
@@ -192,24 +193,25 @@ disassemble_one (insn_t insn, struct disassemble_info *info)
   if (t_f)
     while (*t_f)
       {
-        while (('a' <= t_f[0] && t_f[0] <= 'z') ||
-               ('A' <= t_f[0] && t_f[0] <= 'Z') t_f[0] == ',')
-          t_f++;
-        while (1)
-          {
-            i = strtol (t_f, &t_f, 10);
-            have_space[i] = 1;
-            t_f++; /* ':' */
-            i += strtol (t_f, &t_f, 10);
-            have_space[i] = 1;
-            if (t_f[0] == '|')
-              t_f++;
-            else
-              break;
-          }
-        if (t_f[0] == '<')
-          t_f += 2; /* '<' '<' */
-        strtol (t_f, &t_f, 10);
+	while (('a' <= t_f[0] && t_f[0] <= 'z')
+	       || ('A' <= t_f[0] && t_f[0] <= 'Z')
+	       || t_f[0] == ',')
+	  t_f++;
+	while (1)
+	  {
+	    i = strtol (t_f, &t_f, 10);
+	    have_space[i] = 1;
+	    t_f++; /* ':' */
+	    i += strtol (t_f, &t_f, 10);
+	    have_space[i] = 1;
+	    if (t_f[0] == '|')
+	      t_f++;
+	    else
+	      break;
+	  }
+	if (t_f[0] == '<')
+	  t_f += 2; /* '<' '<' */
+	strtol (t_f, &t_f, 10);
       }
 
   have_space[28] = 1;
@@ -218,11 +220,11 @@ disassemble_one (insn_t insn, struct disassemble_info *info)
   for (i = 31; 0 <= i; i--)
     {
       if (t & insn)
-        info->fprintf_func (info->stream, "1");
+	info->fprintf_func (info->stream, "1");
       else
-        info->fprintf_func (info->stream, "0");
+	info->fprintf_func (info->stream, "0");
       if (have_space[i])
-        info->fprintf_func (info->stream, " ");
+	info->fprintf_func (info->stream, " ");
       t = t >> 1;
     }
   info->fprintf_func (info->stream, "\t");
@@ -239,18 +241,18 @@ disassemble_one (insn_t insn, struct disassemble_info *info)
   info->fprintf_func (info->stream, "%-12s", opc->name);
 
   {
-    char *fake_args = xmalloc(strlen(opc->format) + 1);
+    char *fake_args = xmalloc (strlen (opc->format) + 1);
     const char *fake_arg_strs[MAX_ARG_NUM_PLUS_2];
     strcpy (fake_args, opc->format);
     if (0 < loongarch_split_args_by_comma (fake_args, fake_arg_strs))
       info->fprintf_func (info->stream, "\t");
     info->private_data = &insn;
     loongarch_foreach_args (opc->format, fake_arg_strs, dis_one_arg, info);
-    free(fake_args);
+    free (fake_args);
   }
 
   if (info->insn_type == dis_branch || info->insn_type == dis_condbranch
-      /* || someother if we have extra info to print */)
+      /* Someother if we have extra info to print.  */)
     info->fprintf_func (info->stream, "\t#");
 
   if (info->insn_type == dis_branch || info->insn_type == dis_condbranch)
@@ -280,7 +282,7 @@ print_insn_loongarch (bfd_vma memaddr, struct disassemble_info *info)
   info->target = memaddr;
 
   if ((status = info->read_memory_func (memaddr, (bfd_byte *) &insn,
-                                        sizeof (insn), info)) != 0)
+					sizeof (insn), info)) != 0)
     {
       info->memory_error_func (status, memaddr, info);
       return -1; /* loongarch_insn_length (0); */
@@ -299,7 +301,7 @@ The following LoongArch disassembler options are supported for use\n\
 with the -M switch (multiple options should be separated by commas):\n"));
 
   fprintf (stream, _ ("\n\
-           numeric       Print numeric register names, rather than ABI names.\n"));
+    numeric       Print numeric register names, rather than ABI names.\n"));
   fprintf (stream, _ ("\n"));
 }
 
@@ -317,9 +319,9 @@ my_print_address_func (bfd_vma addr, struct disassemble_info *dinfo)
 
 void
 loongarch_disassemble_one (int64_t pc, insn_t insn,
-                           int (*fprintf_func) (void *stream,
-                                                const char *format, ...),
-                           void *stream)
+			   int (*fprintf_func) (void *stream,
+						const char *format, ...),
+			   void *stream)
 {
   static struct disassemble_info my_disinfo =
   {
diff --git a/opcodes/loongarch-opc.c b/opcodes/loongarch-opc.c
index 27be1e68dfe..c24fa65f1d1 100644
--- a/opcodes/loongarch-opc.c
+++ b/opcodes/loongarch-opc.c
@@ -15,7 +15,7 @@
    License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3. If not,
+   along with this program; see the file COPYING3.  If not,
    see <http://www.gnu.org/licenses/>.  */
 
 #include <stddef.h>
@@ -44,7 +44,7 @@ struct loongarch_ASEs_option LARCH_opts =
 size_t
 loongarch_insn_length (insn_t insn)
 {
-  return insn ? 4 : 4; /* eliminate warning */
+  return insn ? 4 : 4; /* Eliminate warning.  */
 }
 
 const char *const loongarch_r_normal_name[32] =
@@ -122,7 +122,7 @@ const char *const loongarch_x_normal_name[32] =
 
 static struct loongarch_opcode loongarch_macro_opcodes[] =
 {
-  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  /* match,    mask,       name, format, macro, include, exclude, pinfo.  */
   { 0, 0, "li.w", "r,sc", "%f", 0, 0, 0},
   { 0, 0, "li.d", "r,sc", "%f", 0, 0, 0},
   { 0, 0, "la", "r,la", "la.global %1,%2", 0, 0, 0 },
@@ -204,7 +204,7 @@ static struct loongarch_opcode loongarch_macro_opcodes[] =
     "lu12i.w %1,%%tprel(%2)>>12;"
     "ori %1,%1,%%tprel(%2)&0xfff",
     &LARCH_opts.addrwidth_is_32, 0, 0 },
-  /* {0, 0, "la.tls.le", "r,la",
+  /* { 0, 0, "la.tls.le", "r,la",
   * "lu12i.w %1,%%tprel(%2)>>12;"
   * "ori %1,%1,%%tprel(%2)&0xfff"
   * , &LARCH_opts.addrwidth_is_64, 0, 0}, */
@@ -278,7 +278,7 @@ static struct loongarch_opcode loongarch_macro_opcodes[] =
 
 static struct loongarch_opcode loongarch_fix_opcodes[] =
 {
-  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  /* match,    mask,       name, format, macro, include, exclude, pinfo.  */
   { 0x00001000, 0xfffffc00, "clo.w", "r0:5,r5:5", 0, 0, 0, 0 },
   { 0x00001400, 0xfffffc00, "clz.w", "r0:5,r5:5", 0, 0, 0, 0 },
   { 0x00001800, 0xfffffc00, "cto.w", "r0:5,r5:5", 0, 0, 0, 0 },
@@ -299,7 +299,8 @@ static struct loongarch_opcode loongarch_fix_opcodes[] =
   { 0x00005400, 0xfffffc00, "bitrev.d", "r0:5,r5:5", 0, 0, 0, 0 },
   { 0x00005800, 0xfffffc00, "ext.w.h", "r0:5,r5:5", 0, 0, 0, 0 },
   { 0x00005c00, 0xfffffc00, "ext.w.b", "r0:5,r5:5", 0, 0, 0, 0 },
-  { 0x00150000, 0xfffffc00, "move", "r0:5,r5:5", 0 /* or %1,%2,$r0 */, 0, 0, 0 },
+  /* or %1,%2,$r0  */
+  { 0x00150000, 0xfffffc00, "move", "r0:5,r5:5", 0, 0, 0, 0 },
   { 0x00006000, 0xfffffc00, "rdtimel.w", "r0:5,r5:5", 0, 0, 0, 0 },
   { 0x00006400, 0xfffffc00, "rdtimeh.w", "r0:5,r5:5", 0, 0, 0, 0 },
   { 0x00006800, 0xfffffc00, "rdtime.d", "r0:5,r5:5", 0, 0, 0, 0 },
@@ -377,7 +378,7 @@ static struct loongarch_opcode loongarch_fix_opcodes[] =
 
 static struct loongarch_opcode loongarch_float_opcodes[] =
 {
-  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  /* match,    mask,       name, format, macro, include, exclude, pinfo.  */
   { 0x01008000, 0xffff8000, "fadd.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
   { 0x01010000, 0xffff8000, "fadd.d", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
   { 0x01028000, 0xffff8000, "fsub.s", "f0:5,f5:5,f10:5", 0, 0, 0, 0 },
@@ -459,7 +460,7 @@ static struct loongarch_opcode loongarch_float_opcodes[] =
 
 static struct loongarch_opcode loongarch_lmm_opcodes[] =
 {
-  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  /* match,    mask,       name, format, macro, include, exclude, pinfo.  */
   { 0x02000000, 0xffc00000, "slti", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
   { 0x02400000, 0xffc00000, "sltui", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
   { 0x02800000, 0xffc00000, "addi.w", "r0:5,r5:5,s10:12", 0, 0, 0, 0 },
@@ -481,7 +482,7 @@ static struct loongarch_opcode loongarch_lmm_opcodes[] =
 
 static struct loongarch_opcode loongarch_privilege_opcodes[] =
 {
-  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  /* match,    mask,       name, format, macro, include, exclude, pinfo.  */
   { 0x04000000, 0xff0003e0, "csrrd", "r0:5,u10:14", 0, 0, 0, 0 },
   { 0x04000020, 0xff0003e0, "csrwr", "r0:5,u10:14", 0, 0, 0, 0 },
   { 0x04000000, 0xff000000, "csrxchg", "r0:5,r5:5,u10:14", 0, 0, 0, 0 },
@@ -510,7 +511,7 @@ static struct loongarch_opcode loongarch_privilege_opcodes[] =
 
 static struct loongarch_opcode loongarch_4opt_opcodes[] =
 {
-  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  /* match,    mask,       name, format, macro, include, exclude, pinfo.  */
   { 0x08100000, 0xfff00000, "fmadd.s", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0 },
   { 0x08200000, 0xfff00000, "fmadd.d", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0 },
   { 0x08500000, 0xfff00000, "fmsub.s", "f0:5,f5:5,f10:5,f15:5", 0, 0, 0, 0 },
@@ -577,7 +578,7 @@ static struct loongarch_opcode loongarch_4opt_opcodes[] =
 
 static struct loongarch_opcode loongarch_load_store_opcodes[] =
 {
-  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  /* match,    mask,       name, format, macro, include, exclude, pinfo.  */
   { 0x20000000, 0xff000000, "ll.w", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0 },
   { 0x21000000, 0xff000000, "sc.w", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0 },
   { 0x22000000, 0xff000000, "ll.d", "r0:5,r5:5,s10:14<<2", 0, 0, 0, 0 },
@@ -721,7 +722,7 @@ static struct loongarch_opcode loongarch_load_store_opcodes[] =
 
 static struct loongarch_opcode loongarch_jmp_opcodes[] =
 {
-  /* match,    mask,       name, format, macro, include, exclude, pinfo */
+  /* match,    mask,       name, format, macro, include, exclude, pinfo.  */
   { 0, 0, "bltz", "r,la", "bltz %1,%%pcrel(%2)", 0, 0, 0 },
   { 0x60000000, 0xfc00001f, "bltz", "r5:5,sb10:16<<2", 0, 0, 0, 0 },
   { 0, 0, "bgtz", "r,la", "bgtz %1,%%pcrel(%2)", 0, 0, 0 },
-- 
2.30.1

